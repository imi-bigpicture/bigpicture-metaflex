#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Nov 17 11:19:07 2021 by generateDS.py version 2.40.5.
# Python 3.8.9 (tags/v3.8.9:a743f81, Apr  6 2021, 14:02:34) [MSC v.1928 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'schema.py')
#
# Command line arguments:
#   .\combined.xsd
#
# Command line:
#   C:\Users\er-gac\AppData\Local\Programs\Python\Python38\Scripts\generateDS.py -o "schema.py" .\combined.xsd
#
# Current working directory (os.getcwd()):
#   metadata-schema
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass

    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': None,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    setattr(settings[n], self[n])
            from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""


    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ACTIONSType(str, Enum):
    ADD='ADD'
    MODIFY='MODIFY'
    RELEASE='RELEASE'
    HOLD='HOLD'
    VALIDATE='VALIDATE'
    PROTECT='PROTECT'
    RECEIPT='RECEIPT'
    ROLLBACK='ROLLBACK'


class ASSEMBLY_LEVELType(str, Enum):
    COMPLETEGENOME='complete genome'
    CHROMOSOME='chromosome'
    SCAFFOLD='scaffold'
    CONTIG='contig'


class DATASET_TYPEType(str, Enum):
    WHOLESLIDEIMAGING='Whole slide imaging'


class DATASET_TYPEType9(str, Enum):
    WHOLEGENOMESEQUENCING='Whole genome sequencing'
    EXOMESEQUENCING='Exome sequencing'
    GENOTYPINGBYARRAY='Genotyping by array'
    TRANSCRIPTOMEPROFILINGBYHIGHTHROUGHPUTSEQUENCING='Transcriptome profiling by high-throughput sequencing'
    TRANSCRIPTOMEPROFILINGBYARRAY='Transcriptome profiling by array'
    AMPLICONSEQUENCING='Amplicon sequencing'
    METHYLATIONBINDINGDOMAINSEQUENCING='Methylation binding domain sequencing'
    METHYLATIONPROFILINGBYHIGHTHROUGHPUTSEQUENCING='Methylation profiling by high-throughput sequencing'
    PHENOTYPEINFORMATION='Phenotype information'
    STUDYSUMMARYINFORMATION='Study summary information'
    GENOMICVARIANTCALLING='Genomic variant calling'
    CHROMATINACCESSIBILITYPROFILINGBYHIGHTHROUGHPUTSEQUENCING='Chromatin accessibility profiling by high-throughput sequencing'
    HISTONEMODIFICATIONPROFILINGBYHIGHTHROUGHPUTSEQUENCING='Histone modification profiling by high-throughput sequencing'
    CHIP_SEQ='Chip-Seq'


class EXPERIMENT_TYPEType(str, Enum):
    WHOLEGENOMESEQUENCING='Whole genome sequencing'
    WHOLETRANSCRIPTOMESEQUENCING='Whole transcriptome sequencing'
    EXOMESEQUENCING='Exome sequencing'
    GENOTYPINGBYARRAY='Genotyping by array'
    TRANSCRIPTOMICS='transcriptomics'
    CURATION='Curation'
    GENOTYPINGBYSEQUENCING='Genotyping by sequencing'
    TARGETSEQUENCING='Target sequencing'


class GENOME_REPRESENTATIONType(str, Enum):
    FULL='full'
    PARTIAL='partial'


class MANDATORYType(str, Enum):
    """MANDATORYType -- Defines if the attribute is mandatory, recommended or optional.

    """
    MANDATORY='mandatory' # Random sequencing of the whole genome.
    RECOMMENDED='recommended' # Random sequencing of exonic regions selected from the genome.
    OPTIONAL='optional' # Random sequencing of whole transcriptome.


class MOL_TYPEType(str, Enum):
    GENOMICDNA='genomic DNA'
    GENOMICRNA='genomic RNA'
    VIRALC_RNA='viral cRNA'


class MULTIPLICITYType(str, Enum):
    """MULTIPLICITYType -- The attribute can appear more than once if the multiplicity value is set to multiple and at most once if the value is set to single. By default an attribute can occur no more than once.

    """
    SINGLE='single'
    MULTIPLE='multiple'


class PLATFORMType(str, Enum):
    BIO_NANO='BioNano'


class READ_CLASSType(str, Enum):
    APPLICATION_READ='Application Read'
    TECHNICAL_READ='Technical Read'


class READ_TYPEType(str, Enum):
    FORWARD='Forward'
    REVERSE='Reverse'
    ADAPTER='Adapter'
    PRIMER='Primer'
    LINKER='Linker'
    BAR_CODE='BarCode'
    OTHER='Other'


class READ_TYPEType27(str, Enum):
    SINGLE='single'
    PAIRED='paired'
    CELL_BARCODE='cell_barcode'
    UMI_BARCODE='umi_barcode'
    FEATURE_BARCODE='feature_barcode'
    SAMPLE_BARCODE='sample_barcode'
    _=''


class SAMPLE_DEMUX_DIRECTIVEType(str, Enum):
    """SAMPLE_DEMUX_DIRECTIVEType --
    Tells the Archive who will execute the sample demultiplexing operation..

    """
    LEAVE_AS_POOL='leave_as_pool' # There shall be no sample de-multiplexing at the level of assiging individual reads to sample pool members.
    SUBMITTER_DEMULTIPLEXED='submitter_demultiplexed' # The submitter has assigned individual reads to sample pool members by providing individual files containing reads with the same member assignment.


class TYPEType(str, Enum):
    PLASTID='Plastid'
    KINETOPLAST='Kinetoplast'
    SEGMENT='Segment'
    APICOPLAST='Apicoplast'
    VIRUS='Virus'
    MITOCHONDRIAL_MISCELLANEOUS='Mitochondrial Miscellaneous'
    PLASMID='Plasmid'
    NUCLEOMORPH='Nucleomorph'
    MACRONUCLEUS='Macronucleus'
    CHLOROPLAST='Chloroplast'
    MITOCHONDRION='Mitochondrion'
    VIRUS_CHROMOSOME='Virus Chromosome'
    EXTRACHROMOSOMAL_ELEMENT='Extrachromosomal Element'
    MISCELLANEOUS='Miscellaneous'
    PROVIRUS='Provirus'
    CHROMOSOME='Chromosome'
    NONNUCLEAR_MISCELLANEOUS='Non-nuclear Miscellaneous'
    CHROMATOPHORE='Chromatophore'
    PROVIRUS_CHROMOSOME='Provirus Chromosome'
    MITOCHONDRIAL_PLASMID='Mitochondrial Plasmid'
    LINKAGE_GROUP='Linkage Group'
    CYANELLE='Cyanelle'


class TYPEType19(str, Enum):
    CLONEORISOLATE='clone or isolate' # An assembly of reads from an isolated cultured organism, tissues, cells or a cell line.
    PRIMARYMETAGENOME='primary metagenome' # An original metagenome assembly prior to binning from a sampled biome or collection of sampled biomes without attempt to separate taxa.
    BINNEDMETAGENOME='binned metagenome' # A set of contigs drawn from primary or unbinned metagenomes grouped into a single-taxon set.
    METAGENOME_ASSEMBLED_GENOMEMAG='Metagenome-Assembled Genome (MAG)' # A single-taxon assembly based on a binned metagenome asserted to be a close representation to an actual individual genome (that could match an already existing isolate or represent a novel isolate).
    ENVIRONMENTAL_SINGLE_CELL_AMPLIFIED_GENOMESAG='Environmental Single-Cell Amplified Genome (SAG)' # A genome assembly from amplified environmental sampled single-cell DNA.
    COVID_19OUTBREAK='COVID-19 outbreak' # A genome assembly specific to COVID-19 outbreak.
    CLINICALISOLATEASSEMBLY='clinical isolate assembly' # A bacterial pathogen genome assembly.


class TYPEType20(str, Enum):
    ISOLATE='isolate' # An assembly of reads from an isolated cultured organism, tissues, cells or a cell line.
    METATRANSCRIPTOME='metatranscriptome' # An original metatranscriptome assembly from a sampled biome or collection of sampled biomes without attempt to separate taxa.


class ascii_offsetType(str, Enum):
    """ascii_offsetType --
    Character used in representing the minimum quality value.  Helps specify how to decode text rendering of quality data.

    """
    _='!' # ASCII value 33. Typically used for range 0..63.
    __1='@' # ASCII value 64. Typically used for range 0..60.


class checksum_methodType(str, Enum):
    """checksum_methodType -- The checksum method.

    """
    MD_5='MD5' # Checksum generated by the MD5 method (md5sum in unix).


class checksum_methodType14(str, Enum):
    """checksum_methodType14 -- The checksum method.

    """
    MD_5='MD5' # Checksum generated by the MD5 method (md5sum in unix).


class checksum_methodType29(str, Enum):
    """checksum_methodType29 --
    Checksum method used.

    """
    MD_5='MD5' # Checksum generated by the MD5 method (md5sum in unix).
    SHA_256='SHA-256' # Checksum generated by the SHA-256 method .


class checksum_methodType4(str, Enum):
    """checksum_methodType4 -- The checksum method.

    """
    MD_5='MD5' # Checksum generated by the MD5 method (md5sum in unix).


class existing_study_typeType(str, Enum):
    WHOLE_GENOME_SEQUENCING='Whole Genome Sequencing' # Sequencing of a single organism.
    METAGENOMICS='Metagenomics' # Sequencing of a community.
    TRANSCRIPTOME_ANALYSIS='Transcriptome Analysis' # Sequencing and characterization of transcription elements.
    RESEQUENCING='Resequencing' # Sequencing of a sample with respect to a reference.
    EPIGENETICS='Epigenetics' # Cellular differentiation study.
    SYNTHETIC_GENOMICS='Synthetic Genomics' # Sequencing of modified, synthetic, or transplanted genomes.
    FORENSICOR_PALEOGENOMICS='Forensic or Paleo-genomics' # Sequencing of recovered genomic material.
    GENE_REGULATION_STUDY='Gene Regulation Study' # Study of gene expression regulation.
    CANCER_GENOMICS='Cancer Genomics' # Study of cancer genomics.
    POPULATION_GENOMICS='Population Genomics' # Study of populations and evolution through genomics.
    RNA_SEQ='RNASeq' # RNA sequencing study.
    EXOME_SEQUENCING='Exome Sequencing' # The study investigates the exons of the genome.
    POOLED_CLONE_SEQUENCING='Pooled Clone Sequencing' # The study is sequencing clone pools (BACs, fosmids, other constructs).
    TRANSCRIPTOME_SEQUENCING='Transcriptome Sequencing' # Sequencing of transcription elements.
    OTHER='Other' # Study type not listed.


class filetypeType(str, Enum):
    """filetypeType -- The type of the file.

    """
    DCM='dcm'


class filetypeType13(str, Enum):
    """filetypeType13 -- The type of the file.

    """
    TAB='tab'
    BAM='bam'
    BAI='bai'
    CRAM='cram'
    CRAI='crai'
    VCF='vcf'
    VCF_AGGREGATE='vcf_aggregate'
    BCF='bcf'
    TABIX='tabix'
    WIG='wig'
    BED='bed'
    GFF='gff'
    FASTA='fasta'
    FASTQ='fastq'
    FLATFILE='flatfile'
    CHROMOSOME_LIST='chromosome_list'
    SAMPLE_LIST='sample_list'
    README_FILE='readme_file'
    PHENOTYPE_FILE='phenotype_file'
    BIO_NANO_NATIVE='BioNano_native'
    KALLISTO_NATIVE='Kallisto_native'
    AGP='agp'
    UNLOCALISED_LIST='unlocalised_list'
    INFO='info'
    MANIFEST='manifest'
    CSI='csi'
    BCF_AGGREGATE='bcf_aggregate'
    OTHER='other'


class filetypeType28(str, Enum):
    """filetypeType28 --  The run data file model.

    """
    SRA='sra' # Sequence Read Archives native format in serialized (single file) form.
    SRF='srf' # Standard Short Read Format file (.srf), all platforms
    SFF='sff' # 454 Standard Flowgram Format file (.sff)
    FASTQ='fastq' # Combined nucleotide/qualities sequence file in .fastq form. Please see SRA File Formats Guide for definitions of the definition and restrictions on this form.
    FASTA='fasta' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    TAB='tab' # Tab delimited text file used to deliver certain auxiliary data along with sequencing submissions (only needed for certain use cases). The first line is devoted to column headers. Each column is dedicated to an INDSC data series type. Please see SRA File Formats Guide for definitions of the definition and restrictions on this form.
    _4_54_NATIVE='454_native' # A combination of 454 primary analysis output files, including seq qual Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    _4_54_NATIVE_SEQ='454_native_seq' # 454 base calls (for example .seq or .fna). Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    _4_54_NATIVE_QUAL='454_native_qual' # 454 quality scores (for example .qual). Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    HELICOS_NATIVE='Helicos_native' # A kind of fastq format specific to the Helicos platform. Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE='Illumina_native' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE_SEQ='Illumina_native_seq' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE_PRB='Illumina_native_prb' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE_INT='Illumina_native_int' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE_QSEQ='Illumina_native_qseq' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    ILLUMINA_NATIVE_SCARF='Illumina_native_scarf' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    SO_LI_D_NATIVE='SOLiD_native' # A combination of SOLiD primary analysis output files, including: csfasta _QV.qual _intensity.ScaledCY3.fasta _intensity.ScaledCY5.fasta _intensity.ScaledFTC.fasta _intensity.ScaledTXR.fasta Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    SO_LI_D_NATIVE_CSFASTA='SOLiD_native_csfasta' # Colorspace calls (for example .csfasta) Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    SO_LI_D_NATIVE_QUAL='SOLiD_native_qual' # Colorspace quality scores (for example .qual) Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    PAC_BIO_HDF_5='PacBio_HDF5' # Pacific Biosciences Hierarchical Data Format. Please see SRA File Formats Guide for definitions of these file formats.
    BAM='bam' # Binary SAM format that combines alignment and sequencing data. Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    CRAM='cram' # Binary CRAM format that combines alignment and sequencing data. Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    COMPLETE_GENOMICS_NATIVE='CompleteGenomics_native' # Please see SRA File Formats Guide for definitions of these file formats, and the SRA Submission Guidelines document for data series that are appropriate for your study. Sequence and qualities are minimally required.
    OXFORD_NANOPORE_NATIVE='OxfordNanopore_native' # Oxford Nanopore data format.


class filetypeType3(str, Enum):
    """filetypeType3 -- The type of the file.

    """
    DCM='dcm'


class locus_nameType(str, Enum):
    _1_6_SR_RNA='16S rRNA' # Bacterial small subunit ribosomal RNA, a locus used for phylogenetic studies of bacteria and as a target for random target PCR in environmental biodiversity screening.
    _1_8_SR_RNA='18S rRNA' # Eukaryotic small subunit ribosomal RNA, a locus used for phylogenetic studies of eukaryotes and as a target for random target PCR in environmental biodiversity screening.
    _2_8_SR_RNA='28S rRNA' # Structural ribosomal RNA for the large component, or large subunit (LSU) of eukaryotic cytoplasmic ribosomes..
    RBCL='RBCL' # RuBisCO large subunit : ribulose-1,5-bisphosphate carboxylase/oxygenase large subunit, a locus used for phylogenetic studies of plants.
    MAT_K='matK' # Maturase K gene, a locus used for phylogenetic studies of plants.
    COX_1='COX1' # Mitochondrial cytochrome c oxidase 1 gene, a locus used for phylogenetic studies of animals
    ITS_1_5_8_SITS_2='ITS1-5.8S-ITS2' # Internal transcribed spacers 1 and 2 plus 5.8S rRNA region, a locus used for phylogenetic studies of fungi.
    EXOME='exome' # All exonic regions of the genome.
    OTHER='other' # Other locus, please describe.


class match_edgeType(str, Enum):
    """match_edgeType --
    Where the match should occur. Changes the rules on how min_match and max_mismatch are counted.

    """
    FULL='full' # Only @max_mismatch influences matching process
    START='start' # Both matches and mismatches are counted. When @max_mismatch is exceeded - it is not a match. When @min_match is reached - match is declared.
    END='end' # Both matches and mismatches are counted. When @max_mismatch is exceeded - it is not a match. When @min_match is reached - match is declared.


class quality_encodingType(str, Enum):
    """quality_encodingType --
    Character used in representing the minimum quality value.
    Helps specify how to decode text rendering of quality data.

    """
    ASCII='ascii' # ASCII character based encoding.
    DECIMAL='decimal' # Single decimal value per quality score.
    HEXADECIMAL='hexadecimal' # Single hexadecimal value per quality score.


class quality_scoring_systemType(str, Enum):
    """quality_scoring_systemType --
    How the input data are scored for quality.

    """
    PHRED='phred' # The quality score is expressed as a probability of error in log form: -10 log(1/p) where p is the probability of error, with value range 0..63, 0 meaning no base call.
    LOGODDS='log-odds' # The quality score is expressed as the ratio of error to non-error in log form: -10 log(p/(1-p)) where p is the probability of error, with value range -40..40. The SRA will convert these into phred scale during loadtime.


class restrictionTypeType(str, Enum):
    """restrictionTypeType -- Taxon restriction type.

    """
    PERMITTEDTAXA='Permitted taxa'
    NOTPERMITTEDTAXA='Not permitted taxa'


class restrictionTypeType12(str, Enum):
    ANYNUMBERORNONEOFTHEFIELDS='Any number or none of the fields'
    ONEOFTHEFIELDS='One of the fields'
    ATLEASTONEOFTHEFIELDS='At least one of the fields'
    ONEORNONEOFTHEFIELDS='One or none of the fields'


class schemaType(str, Enum):
    """schemaType -- The type of the XML file being submitted.

    """
    STUDY='study'
    EXPERIMENT='experiment'
    SAMPLE='sample'
    RUN='run'
    ANALYSIS='analysis'
    DATASET='dataset'
    POLICY='policy'
    DAC='dac'
    PROJECT='project'
    CHECKLIST='checklist'
    SAMPLE_GROUP='sampleGroup'


class schemaType34(str, Enum):
    """schemaType34 -- The type of the XML file being updated.

    """
    STUDY='study'
    EXPERIMENT='experiment'
    SAMPLE='sample'
    RUN='run'
    ANALYSIS='analysis'
    DATASET='dataset'
    POLICY='policy'
    DAC='dac'
    PROJECT='project'
    CHECKLIST='checklist'
    SAMPLE_GROUP='sampleGroup'


class schemaType35(str, Enum):
    """schemaType35 -- The type of the XML file being validated.

    """
    STUDY='study'
    EXPERIMENT='experiment'
    SAMPLE='sample'
    RUN='run'
    ANALYSIS='analysis'
    DATASET='dataset'
    POLICY='policy'
    DAC='dac'
    PROJECT='project'
    CHECKLIST='checklist'
    SAMPLE_GROUP='sampleGroup'


class statusType(str, Enum):
    DRAFT='DRAFT'
    PRIVATE='PRIVATE'
    CANCELLED='CANCELLED'
    PUBLIC='PUBLIC'
    SUPPRESSED='SUPPRESSED'
    KILLED='KILLED'
    TEMPORARY_SUPPRESSED='TEMPORARY_SUPPRESSED'
    TEMPORARY_KILLED='TEMPORARY_KILLED'


class type454Model(str, Enum):
    _4_54GS='454 GS'
    _4_54GS_20='454 GS 20'
    _4_54GSFLX='454 GS FLX'
    _4_54GSFLX_1='454 GS FLX+'
    _4_54GSFLX_TITANIUM='454 GS FLX Titanium'
    _4_54GS_JUNIOR='454 GS Junior'
    UNSPECIFIED='unspecified'


class typeAbiSolidModel(str, Enum):
    ABSO_LI_D_SYSTEM='AB SOLiD System' # Undifferentiated early AB SOLiD system
    ABSO_LI_D_SYSTEM_2_0='AB SOLiD System 2.0'
    ABSO_LI_D_SYSTEM_3_0='AB SOLiD System 3.0'
    ABSO_LI_D_3_PLUS_SYSTEM='AB SOLiD 3 Plus System'
    ABSO_LI_D_4_SYSTEM='AB SOLiD 4 System'
    ABSO_LI_D_4_HQ_SYSTEM='AB SOLiD 4hq System'
    ABSO_LI_DPI_SYSTEM='AB SOLiD PI System'
    AB_5500_GENETIC_ANALYZER='AB 5500 Genetic Analyzer'
    AB_5500_XL_GENETIC_ANALYZER='AB 5500xl Genetic Analyzer'
    AB_5500_XLW_GENETIC_ANALYSIS_SYSTEM='AB 5500xl-W Genetic Analysis System'
    UNSPECIFIED='unspecified'


class typeBGISEQModel(str, Enum):
    BGISEQ_50='BGISEQ-50'
    BGISEQ_500='BGISEQ-500'
    MGISEQ_2000_RS='MGISEQ-2000RS'


class typeCGModel(str, Enum):
    COMPLETE_GENOMICS='Complete Genomics'
    UNSPECIFIED='unspecified'


class typeCapillaryModel(str, Enum):
    AB_3730_X_L_GENETIC_ANALYZER='AB 3730xL Genetic Analyzer'
    AB_3730_GENETIC_ANALYZER='AB 3730 Genetic Analyzer'
    AB_3500_X_L_GENETIC_ANALYZER='AB 3500xL Genetic Analyzer'
    AB_3500_GENETIC_ANALYZER='AB 3500 Genetic Analyzer'
    AB_3130_X_L_GENETIC_ANALYZER='AB 3130xL Genetic Analyzer'
    AB_3130_GENETIC_ANALYZER='AB 3130 Genetic Analyzer'
    AB_310_GENETIC_ANALYZER='AB 310 Genetic Analyzer'
    UNSPECIFIED='unspecified'


class typeDnbSeqModel(str, Enum):
    DNBSEQT_7='DNBSEQ-T7'
    DNBSEQG_400='DNBSEQ-G400'
    DNBSEQG_50='DNBSEQ-G50'
    DNBSEQG_400FAST='DNBSEQ-G400 FAST'
    UNSPECIFIED='unspecified'


class typeHelicosModel(str, Enum):
    HELICOS_HELI_SCOPE='Helicos HeliScope'
    UNSPECIFIED='unspecified'


class typeIlluminaModel(str, Enum):
    HI_SEQX_FIVE='HiSeq X Five'
    HI_SEQX_TEN='HiSeq X Ten'
    ILLUMINA_GENOME_ANALYZER='Illumina Genome Analyzer'
    ILLUMINA_GENOME_ANALYZERII='Illumina Genome Analyzer II'
    ILLUMINA_GENOME_ANALYZERI_IX='Illumina Genome Analyzer IIx'
    ILLUMINA_HI_SCAN_SQ='Illumina HiScanSQ'
    ILLUMINA_HI_SEQ_1000='Illumina HiSeq 1000'
    ILLUMINA_HI_SEQ_1500='Illumina HiSeq 1500'
    ILLUMINA_HI_SEQ_2000='Illumina HiSeq 2000'
    ILLUMINA_HI_SEQ_2500='Illumina HiSeq 2500'
    ILLUMINA_HI_SEQ_3000='Illumina HiSeq 3000'
    ILLUMINA_HI_SEQ_4000='Illumina HiSeq 4000'
    ILLUMINA_HI_SEQX='Illumina HiSeq X'
    ILLUMINAI_SEQ_100='Illumina iSeq 100'
    ILLUMINA_MI_SEQ='Illumina MiSeq'
    ILLUMINA_MINI_SEQ='Illumina MiniSeq'
    ILLUMINA_NOVA_SEQ_6000='Illumina NovaSeq 6000'
    NEXT_SEQ_500='NextSeq 500'
    NEXT_SEQ_550='NextSeq 550'
    NEXT_SEQ_1000='NextSeq 1000'
    NEXT_SEQ_2000='NextSeq 2000'
    UNSPECIFIED='unspecified'


class typeIontorrentModel(str, Enum):
    ION_TORRENTPGM='Ion Torrent PGM'
    ION_TORRENT_PROTON='Ion Torrent Proton'
    ION_TORRENTS_5='Ion Torrent S5'
    ION_TORRENTS_5XL='Ion Torrent S5 XL'
    ION_TORRENT_GENEXUS='Ion Torrent Genexus'
    ION_GENE_STUDIOS_5='Ion GeneStudio S5'
    ION_GENE_STUDIOS_5_PRIME='Ion GeneStudio S5 Prime'
    ION_GENE_STUDIOS_5_PLUS='Ion GeneStudio S5 Plus'
    UNSPECIFIED='unspecified'


class typeLibrarySelection(str, Enum):
    """typeLibrarySelection --  Method used to enrich the target in the sequence library preparation

    """
    RANDOM='RANDOM' # No Selection or Random selection
    PCR='PCR' # target enrichment via PCR
    RANDOMPCR='RANDOM PCR' # Source material was selected by randomly generated primers.
    RTPCR='RT-PCR' # target enrichment via
    HMPR='HMPR' # Hypo-methylated partial restriction digest
    MF='MF' # Methyl Filtrated
    REPEATFRACTIONATION='repeat fractionation' # Selection for less repetitive (and more gene rich) sequence through Cot filtration (CF) or other fractionation techniques based on DNA kinetics.
    SIZEFRACTIONATION='size fractionation' # Physical selection of size appropriate targets.
    MSLL='MSLL' # Methylation Spanning Linking Library
    C_DNA='cDNA' # PolyA selection or enrichment for messenger RNA (mRNA); synonymize with PolyA
    C_DNA_RANDOM_PRIMING='cDNA_randomPriming'
    C_DNA_OLIGO_D_T='cDNA_oligo_dT'
    POLY_A='PolyA' # PolyA selection or enrichment for messenger RNA (mRNA); should replace cDNA enumeration.
    OLIGOD_T='Oligo-dT' # enrichment of messenger RNA (mRNA) by hybridization to Oligo-dT.
    INVERSER_RNA='Inverse rRNA' # depletion of ribosomal RNA by oligo hybridization.
    INVERSER_RNASELECTION='Inverse rRNA selection' # depletion of ribosomal RNA by inverse oligo hybridization.
    CH_IP='ChIP' # Chromatin immunoprecipitation
    CH_IP_SEQ='ChIP-Seq' # Chromatin immunoPrecipitation, reveals binding sites of specific proteins, typically transcription factors (TFs) using antibodies to extract DNA fragments bound to the target protein.
    M_NASE='MNase' # Identifies well-positioned nucleosomes. uses Micrococcal Nuclease (MNase) is an endo-exonuclease that processively digests DNA until an obstruction, such as a nucleosome, is reached.
    D_NASE='DNase' # DNase I endonuclease digestion and size selection reveals regions of chromatin where the DNA is highly sensitive to DNase I.
    HYBRID_SELECTION='Hybrid Selection' # Selection by hybridization in array or solution.
    REDUCED_REPRESENTATION='Reduced Representation' # Reproducible genomic subsets, often generated by restriction fragment size selection, containing a manageable number of loci to facilitate re-sampling.
    RESTRICTION_DIGEST='Restriction Digest' # DNA fractionation using restriction enzymes.
    _5METHYLCYTIDINEANTIBODY='5-methylcytidine antibody' # Selection of methylated DNA fragments using an antibody raised against 5-methylcytosine or 5-methylcytidine (m5C).
    MBD_2PROTEINMETHYL_CP_GBINDINGDOMAIN='MBD2 protein methyl-CpG binding domain' # Enrichment by methyl-CpG binding domain.
    CAGE='CAGE' # Cap-analysis gene expression.
    RACE='RACE' # Rapid Amplification of cDNA Ends.
    MDA='MDA' # Multiple Displacement Amplification, a non-PCR based DNA amplification technique that amplifies a minute quantifies of DNA to levels suitable for genomic analysis.
    PADLOCKPROBESCAPTUREMETHOD='padlock probes capture method' # Targeted sequence capture protocol covering an arbitrary set of nonrepetitive genomics targets. An example is capture bisulfite sequencing using padlock probes (BSPP).
    OTHER='other' # Other library enrichment, screening, or selection process.
    UNSPECIFIED='unspecified' # Library enrichment, screening, or selection is not specified.


class typeLibrarySource(str, Enum):
    """typeLibrarySource --  The LIBRARY_SOURCE specifies the type of source material that is being sequenced.

    """
    GENOMIC='GENOMIC' # Genomic DNA (includes PCR products from genomic DNA).
    GENOMICSINGLECELL='GENOMIC SINGLE CELL'
    TRANSCRIPTOMIC='TRANSCRIPTOMIC' # Transcription products or non genomic DNA (EST, cDNA, RT-PCR, screened libraries).
    TRANSCRIPTOMICSINGLECELL='TRANSCRIPTOMIC SINGLE CELL'
    METAGENOMIC='METAGENOMIC' # Mixed material from metagenome.
    METATRANSCRIPTOMIC='METATRANSCRIPTOMIC' # Transcription products from community targets
    SYNTHETIC='SYNTHETIC' # Synthetic DNA.
    VIRALRNA='VIRAL RNA' # Viral RNA.
    OTHER='OTHER' # Other, unspecified, or unknown library source material.


class typeLibraryStrategy(str, Enum):
    """typeLibraryStrategy -- Sequencing technique intended for this library.

    """
    WGS='WGS' # Whole Genome Sequencing - random sequencing of the whole genome (see pubmed 10731132 for details)
    WGA='WGA' # Whole Genome Amplification followed by random sequencing. (see pubmed 1631067,8962113 for details)
    WXS='WXS' # Random sequencing of exonic regions selected from the genome. (see pubmed 20111037 for details)
    RNA_SEQ='RNA-Seq' # Random sequencing of whole transcriptome, also known as Whole Transcriptome Shotgun Sequencing, or WTSS). (see pubmed 18611170 for details)
    SS_RNASEQ='ssRNA-seq' # Strand-specific RNA sequencing.
    MI_RNA_SEQ='miRNA-Seq' # Micro RNA sequencing strategy designed to capture post-transcriptional RNA elements and include non-coding functional elements. (see pubmed 21787409 for details)
    NC_RNA_SEQ='ncRNA-Seq' # Capture of other non-coding RNA types, including post-translation modification types such as snRNA (small nuclear RNA) or snoRNA (small nucleolar RNA), or expression regulation types such as siRNA (small interfering RNA) or piRNA/piwi/RNA (piwi-interacting RNA).
    FLC_DNA='FL-cDNA' # Full-length sequencing of cDNA templates
    EST='EST' # Single pass sequencing of cDNA templates
    HIC='Hi-C' # Chromosome Conformation Capture technique where a biotin-labeled nucleotide is incorporated at the ligation junction, enabling selective purification of chimeric DNA ligation junctions followed by deep sequencing.
    ATACSEQ='ATAC-seq' # Assay for Transposase-Accessible Chromatin (ATAC) strategy is used to study genome-wide chromatin accessibility. alternative method to DNase-seq that uses an engineered Tn5 transposase to cleave DNA and to integrate primer DNA sequences into the cleaved genomic DNA.
    WCS='WCS' # Random sequencing of a whole chromosome or other replicon isolated from a genome.
    RAD_SEQ='RAD-Seq'
    CLONE='CLONE' # Genomic clone based (hierarchical) sequencing.
    POOLCLONE='POOLCLONE' # Shotgun of pooled clones (usually BACs and Fosmids).
    AMPLICON='AMPLICON' # Sequencing of overlapping or distinct PCR or RT-PCR products. For example, metagenomic community profiling using SSU rRNA .
    CLONEEND='CLONEEND' # Clone end (5', 3', or both) sequencing.
    FINISHING='FINISHING' # Sequencing intended to finish (close) gaps in existing coverage.
    CH_IP_SEQ='ChIP-Seq' # ChIP-seq, Chromatin ImmunoPrecipitation, reveals binding sites of specific proteins, typically transcription factors (TFs) using antibodies to extract DNA fragments bound to the target protein.
    M_NASE_SEQ='MNase-Seq' # Identifies well-positioned nucleosomes. uses Micrococcal Nuclease (MNase) is an endo-exonuclease that processively digests DNA until an obstruction, such as a nucleosome, is reached.
    D_NASE_HYPERSENSITIVITY='DNase-Hypersensitivity' # Sequencing of hypersensitive sites, or segments of open chromatin that are more readily cleaved by DNaseI.
    BISULFITE_SEQ='Bisulfite-Seq' # MethylC-seq. Sequencing following treatment of DNA with bisulfite to convert cytosine residues to uracil depending on methylation status.
    CTS='CTS' # Concatenated Tag Sequencing
    MRE_SEQ='MRE-Seq' # Methylation-Sensitive Restriction Enzyme Sequencing.
    ME_DIP_SEQ='MeDIP-Seq' # Methylated DNA Immunoprecipitation Sequencing.
    MBD_SEQ='MBD-Seq' # Methyl CpG Binding Domain Sequencing.
    TN_SEQ='Tn-Seq' # Quantitatively determine fitness of bacterial genes based on how many times a purposely seeded transposon gets inserted into each gene of a colony after some time.
    VALIDATION='VALIDATION' # CGHub special request: Independent experiment to re-evaluate putative variants.
    FAIRESEQ='FAIRE-seq' # Formaldehyde Assisted Isolation of Regulatory Elements. Reveals regions of open chromatin.
    SELEX='SELEX' # Systematic Evolution of Ligands by Exponential enrichment
    RIP_SEQ='RIP-Seq' # Direct sequencing of RNA immunoprecipitates (includes CLIP-Seq, HITS-CLIP and PAR-CLIP).
    CH_IAPET='ChIA-PET' # Direct sequencing of proximity-ligated chromatin immunoprecipitates.
    SYNTHETIC_LONG_READ='Synthetic-Long-Read' # binning and barcoding of large DNA fragments to facilitate assembly of the fragment
    TARGETED_CAPTURE='Targeted-Capture' # Enrichment of a targeted subset of loci.
    TETHERED_CHROMATIN_CONFORMATION_CAPTURE='Tethered Chromatin Conformation Capture'
    NO_ME_SEQ='NOMe-Seq' # Nucleosome Occupancy and Methylome sequencing.
    CH_M_SEQ='ChM-Seq' # ChIPmentation combines chromatin immunoprecipitation with sequencing library preparation by Tn5 transposase (see pubmed 26280331 for details)
    GBS='GBS' # Genotyping by sequencing is a method to discover single nucleotide polymorphisms for genotyping studies.
    OTHER='OTHER' # Library strategy not listed.


class typeOxfordNanoporeModel(str, Enum):
    MIN_ION='MinION'
    GRID_ION='GridION'
    PROMETH_ION='PromethION'
    UNSPECIFIED='unspecified'


class typePacBioModel(str, Enum):
    PAC_BIORS='PacBio RS'
    PAC_BIORSII='PacBio RS II'
    SEQUEL='Sequel'
    SEQUELII='Sequel II'
    UNSPECIFIED='unspecified'


class typeType(str, Enum):
    STUDY='study'
    EXPERIMENT='experiment'
    SAMPLE='sample'
    SAMPLE_GROUP='sampleGroup'
    RUN='run'
    ANALYSIS='analysis'
    DATASET='dataset'
    POLICY='policy'
    DAC='dac'
    ARRAY_EXPRESS='ArrayExpress'
    LOCUS_TAG_PREFIX='LocusTagPrefix'
    TAXON='Taxon'
    PROJECT='Project'
    CHECKLIST='checklist'
    BIOSAMPLE='biosample'


class AnnotationFileType(GeneratedsSuper):
    """filename -- The file name.
    filetype -- The type of the file.
    checksum_method -- The checksum method.
    checksum -- The file checksum.
    unencrypted_checksum -- The checksum of the unencrypted file (used in conjunction with the checksum of an encrypted file).
    checklist -- The name of the checklist.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filename=None, filetype=None, checksum_method=None, checksum=None, unencrypted_checksum=None, checklist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filename = _cast(None, filename)
        self.filename_nsprefix_ = None
        self.filetype = _cast(None, filetype)
        self.filetype_nsprefix_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.checksum_method_nsprefix_ = None
        self.checksum = _cast(None, checksum)
        self.checksum_nsprefix_ = None
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.unencrypted_checksum_nsprefix_ = None
        self.checklist = _cast(None, checklist)
        self.checklist_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnotationFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnotationFileType.subclass:
            return AnnotationFileType.subclass(*args_, **kwargs_)
        else:
            return AnnotationFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def get_filetype(self):
        return self.filetype
    def set_filetype(self, filetype):
        self.filetype = filetype
    def get_checksum_method(self):
        return self.checksum_method
    def set_checksum_method(self, checksum_method):
        self.checksum_method = checksum_method
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    def get_unencrypted_checksum(self):
        return self.unencrypted_checksum
    def set_unencrypted_checksum(self, unencrypted_checksum):
        self.unencrypted_checksum = unencrypted_checksum
    def get_checklist(self):
        return self.checklist
    def set_checklist(self, checklist):
        self.checklist = checklist
    def validate_filetypeType(self, value):
        # Validate type filetypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['dcm']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on filetypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_checksum_methodType(self, value):
        # Validate type checksum_methodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MD5']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on checksum_methodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnotationFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnotationFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationFileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnotationFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnotationFileType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filetype), input_name='filetype')), ))
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum_method), input_name='checksum_method')), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum), input_name='checksum')), ))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unencrypted_checksum), input_name='unencrypted_checksum')), ))
        if self.checklist is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            outfile.write(' checklist=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checklist), input_name='checklist')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
            self.validate_filetypeType(self.filetype)    # validate type filetypeType
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
            self.validate_checksum_methodType(self.checksum_method)    # validate type checksum_methodType
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
        value = find_attr_value_('checklist', node)
        if value is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            self.checklist = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AnnotationFileType


class AnnotationSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANNOTATION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANNOTATION is None:
            self.ANNOTATION = []
        else:
            self.ANNOTATION = ANNOTATION
        self.ANNOTATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnotationSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnotationSetType.subclass:
            return AnnotationSetType.subclass(*args_, **kwargs_)
        else:
            return AnnotationSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANNOTATION(self):
        return self.ANNOTATION
    def set_ANNOTATION(self, ANNOTATION):
        self.ANNOTATION = ANNOTATION
    def add_ANNOTATION(self, value):
        self.ANNOTATION.append(value)
    def insert_ANNOTATION_at(self, index, value):
        self.ANNOTATION.insert(index, value)
    def replace_ANNOTATION_at(self, index, value):
        self.ANNOTATION[index] = value
    def _hasContent(self):
        if (
            self.ANNOTATION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnotationSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnotationSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnotationSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnotationSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANNOTATION_ in self.ANNOTATION:
            namespaceprefix_ = self.ANNOTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_nsprefix_) else ''
            ANNOTATION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANNOTATION':
            obj_ = AnnotationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION'
# end class AnnotationSetType


class CodedAttributeType(GeneratedsSuper):
    """CodedAttributeType --
    Reusable attributes to encode tag-code value pairs with optional units.

    * TAG --
      Name of the attribute.

    * VALUE --
      Code value of the attribute.

    * UNITS --
      Optional scientific units.

    * SCHEME --
      Scheme designator of the attribute.

    * MEANING --
      Cleartext meaning of the attribute.

    * SCHEME_VERSION --
      Optional scheme version of the attribute.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TAG=None, VALUE=None, UNITS=None, SCHEME=None, MEANING=None, SCHEME_VERSION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TAG = TAG
        self.TAG_nsprefix_ = None
        self.VALUE = VALUE
        self.VALUE_nsprefix_ = None
        self.UNITS = UNITS
        self.UNITS_nsprefix_ = None
        self.SCHEME = SCHEME
        self.SCHEME_nsprefix_ = None
        self.MEANING = MEANING
        self.MEANING_nsprefix_ = None
        self.SCHEME_VERSION = SCHEME_VERSION
        self.SCHEME_VERSION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CodedAttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CodedAttributeType.subclass:
            return CodedAttributeType.subclass(*args_, **kwargs_)
        else:
            return CodedAttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAG(self):
        return self.TAG
    def set_TAG(self, TAG):
        self.TAG = TAG
    def get_VALUE(self):
        return self.VALUE
    def set_VALUE(self, VALUE):
        self.VALUE = VALUE
    def get_UNITS(self):
        return self.UNITS
    def set_UNITS(self, UNITS):
        self.UNITS = UNITS
    def get_SCHEME(self):
        return self.SCHEME
    def set_SCHEME(self, SCHEME):
        self.SCHEME = SCHEME
    def get_MEANING(self):
        return self.MEANING
    def set_MEANING(self, MEANING):
        self.MEANING = MEANING
    def get_SCHEME_VERSION(self):
        return self.SCHEME_VERSION
    def set_SCHEME_VERSION(self, SCHEME_VERSION):
        self.SCHEME_VERSION = SCHEME_VERSION
    def _hasContent(self):
        if (
            self.TAG is not None or
            self.VALUE is not None or
            self.UNITS is not None or
            self.SCHEME is not None or
            self.MEANING is not None or
            self.SCHEME_VERSION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CodedAttributeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CodedAttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CodedAttributeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CodedAttributeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CodedAttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CodedAttributeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CodedAttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            namespaceprefix_ = self.TAG_nsprefix_ + ':' if (UseCapturedNS_ and self.TAG_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TAG), input_name='TAG')), namespaceprefix_ , eol_))
        if self.VALUE is not None:
            namespaceprefix_ = self.VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), namespaceprefix_ , eol_))
        if self.UNITS is not None:
            namespaceprefix_ = self.UNITS_nsprefix_ + ':' if (UseCapturedNS_ and self.UNITS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNITS), input_name='UNITS')), namespaceprefix_ , eol_))
        if self.SCHEME is not None:
            namespaceprefix_ = self.SCHEME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHEME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHEME>%s</%sSCHEME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHEME), input_name='SCHEME')), namespaceprefix_ , eol_))
        if self.MEANING is not None:
            namespaceprefix_ = self.MEANING_nsprefix_ + ':' if (UseCapturedNS_ and self.MEANING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMEANING>%s</%sMEANING>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MEANING), input_name='MEANING')), namespaceprefix_ , eol_))
        if self.SCHEME_VERSION is not None:
            namespaceprefix_ = self.SCHEME_VERSION_nsprefix_ + ':' if (UseCapturedNS_ and self.SCHEME_VERSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCHEME_VERSION>%s</%sSCHEME_VERSION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCHEME_VERSION), input_name='SCHEME_VERSION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAG':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TAG')
            value_ = self.gds_validate_string(value_, node, 'TAG')
            self.TAG = value_
            self.TAG_nsprefix_ = child_.prefix
        elif nodeName_ == 'VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VALUE')
            value_ = self.gds_validate_string(value_, node, 'VALUE')
            self.VALUE = value_
            self.VALUE_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNITS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNITS')
            value_ = self.gds_validate_string(value_, node, 'UNITS')
            self.UNITS = value_
            self.UNITS_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHEME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHEME')
            value_ = self.gds_validate_string(value_, node, 'SCHEME')
            self.SCHEME = value_
            self.SCHEME_nsprefix_ = child_.prefix
        elif nodeName_ == 'MEANING':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MEANING')
            value_ = self.gds_validate_string(value_, node, 'MEANING')
            self.MEANING = value_
            self.MEANING_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCHEME_VERSION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCHEME_VERSION')
            value_ = self.gds_validate_string(value_, node, 'SCHEME_VERSION')
            self.SCHEME_VERSION = value_
            self.SCHEME_VERSION_nsprefix_ = child_.prefix
# end class CodedAttributeType


class BPDatasetsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BPDATASET=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if BPDATASET is None:
            self.BPDATASET = []
        else:
            self.BPDATASET = BPDATASET
        self.BPDATASET_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BPDatasetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BPDatasetsType.subclass:
            return BPDatasetsType.subclass(*args_, **kwargs_)
        else:
            return BPDatasetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BPDATASET(self):
        return self.BPDATASET
    def set_BPDATASET(self, BPDATASET):
        self.BPDATASET = BPDATASET
    def add_BPDATASET(self, value):
        self.BPDATASET.append(value)
    def insert_BPDATASET_at(self, index, value):
        self.BPDATASET.insert(index, value)
    def replace_BPDATASET_at(self, index, value):
        self.BPDATASET[index] = value
    def _hasContent(self):
        if (
            self.BPDATASET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPDatasetsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BPDatasetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BPDatasetsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPDatasetsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BPDatasetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BPDatasetsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPDatasetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BPDATASET_ in self.BPDATASET:
            namespaceprefix_ = self.BPDATASET_nsprefix_ + ':' if (UseCapturedNS_ and self.BPDATASET_nsprefix_) else ''
            BPDATASET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BPDATASET', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BPDATASET':
            obj_ = BPDatasetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BPDATASET.append(obj_)
            obj_.original_tagname_ = 'BPDATASET'
# end class BPDatasetsType


class ImageFileType(GeneratedsSuper):
    """filename -- The file name.
    filetype -- The type of the file.
    checksum_method -- The checksum method.
    checksum -- The file checksum.
    unencrypted_checksum -- The checksum of the unencrypted file (used in conjunction with the checksum of an encrypted file).

    * checklist -- The name of the checklist.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filename=None, filetype=None, checksum_method=None, checksum=None, unencrypted_checksum=None, checklist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filename = _cast(None, filename)
        self.filename_nsprefix_ = None
        self.filetype = _cast(None, filetype)
        self.filetype_nsprefix_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.checksum_method_nsprefix_ = None
        self.checksum = _cast(None, checksum)
        self.checksum_nsprefix_ = None
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.unencrypted_checksum_nsprefix_ = None
        self.checklist = _cast(None, checklist)
        self.checklist_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImageFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImageFileType.subclass:
            return ImageFileType.subclass(*args_, **kwargs_)
        else:
            return ImageFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def get_filetype(self):
        return self.filetype
    def set_filetype(self, filetype):
        self.filetype = filetype
    def get_checksum_method(self):
        return self.checksum_method
    def set_checksum_method(self, checksum_method):
        self.checksum_method = checksum_method
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    def get_unencrypted_checksum(self):
        return self.unencrypted_checksum
    def set_unencrypted_checksum(self, unencrypted_checksum):
        self.unencrypted_checksum = unencrypted_checksum
    def get_checklist(self):
        return self.checklist
    def set_checklist(self, checklist):
        self.checklist = checklist
    def validate_filetypeType3(self, value):
        # Validate type filetypeType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['dcm']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on filetypeType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_checksum_methodType4(self, value):
        # Validate type checksum_methodType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MD5']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on checksum_methodType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImageFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImageFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImageFileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImageFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImageFileType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filetype), input_name='filetype')), ))
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum_method), input_name='checksum_method')), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum), input_name='checksum')), ))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unencrypted_checksum), input_name='unencrypted_checksum')), ))
        if self.checklist is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            outfile.write(' checklist=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checklist), input_name='checklist')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
            self.validate_filetypeType3(self.filetype)    # validate type filetypeType3
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
            self.validate_checksum_methodType4(self.checksum_method)    # validate type checksum_methodType4
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
        value = find_attr_value_('checklist', node)
        if value is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            self.checklist = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ImageFileType


class ImageSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE is None:
            self.IMAGE = []
        else:
            self.IMAGE = IMAGE
        self.IMAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImageSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImageSetType.subclass:
            return ImageSetType.subclass(*args_, **kwargs_)
        else:
            return ImageSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE(self):
        return self.IMAGE
    def set_IMAGE(self, IMAGE):
        self.IMAGE = IMAGE
    def add_IMAGE(self, value):
        self.IMAGE.append(value)
    def insert_IMAGE_at(self, index, value):
        self.IMAGE.insert(index, value)
    def replace_IMAGE_at(self, index, value):
        self.IMAGE[index] = value
    def _hasContent(self):
        if (
            self.IMAGE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImageSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImageSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImageSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImageSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImageSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ in self.IMAGE:
            namespaceprefix_ = self.IMAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_nsprefix_) else ''
            IMAGE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE':
            obj_ = ImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE.append(obj_)
            obj_.original_tagname_ = 'IMAGE'
# end class ImageSetType


class BPSampleSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BP_SAMPLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if BP_SAMPLE is None:
            self.BP_SAMPLE = []
        else:
            self.BP_SAMPLE = BP_SAMPLE
        self.BP_SAMPLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BPSampleSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BPSampleSetType.subclass:
            return BPSampleSetType.subclass(*args_, **kwargs_)
        else:
            return BPSampleSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BP_SAMPLE(self):
        return self.BP_SAMPLE
    def set_BP_SAMPLE(self, BP_SAMPLE):
        self.BP_SAMPLE = BP_SAMPLE
    def add_BP_SAMPLE(self, value):
        self.BP_SAMPLE.append(value)
    def insert_BP_SAMPLE_at(self, index, value):
        self.BP_SAMPLE.insert(index, value)
    def replace_BP_SAMPLE_at(self, index, value):
        self.BP_SAMPLE[index] = value
    def _hasContent(self):
        if (
            self.BP_SAMPLE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPSampleSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BPSampleSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BPSampleSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPSampleSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BPSampleSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BPSampleSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPSampleSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BP_SAMPLE_ in self.BP_SAMPLE:
            namespaceprefix_ = self.BP_SAMPLE_nsprefix_ + ':' if (UseCapturedNS_ and self.BP_SAMPLE_nsprefix_) else ''
            BP_SAMPLE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BP_SAMPLE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BP_SAMPLE':
            obj_ = BPSampleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BP_SAMPLE.append(obj_)
            obj_.original_tagname_ = 'BP_SAMPLE'
# end class BPSampleSetType


class DacSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DAC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DAC is None:
            self.DAC = []
        else:
            self.DAC = DAC
        self.DAC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DacSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DacSetType.subclass:
            return DacSetType.subclass(*args_, **kwargs_)
        else:
            return DacSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DAC(self):
        return self.DAC
    def set_DAC(self, DAC):
        self.DAC = DAC
    def add_DAC(self, value):
        self.DAC.append(value)
    def insert_DAC_at(self, index, value):
        self.DAC.insert(index, value)
    def replace_DAC_at(self, index, value):
        self.DAC[index] = value
    def _hasContent(self):
        if (
            self.DAC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DacSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DacSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DacSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DacSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DacSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DacSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DacSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DAC_ in self.DAC:
            namespaceprefix_ = self.DAC_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_nsprefix_) else ''
            DAC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DAC':
            obj_ = DacType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC.append(obj_)
            obj_.original_tagname_ = 'DAC'
# end class DacSetType


class DatasetsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASET=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASET is None:
            self.DATASET = []
        else:
            self.DATASET = DATASET
        self.DATASET_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatasetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatasetsType.subclass:
            return DatasetsType.subclass(*args_, **kwargs_)
        else:
            return DatasetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASET(self):
        return self.DATASET
    def set_DATASET(self, DATASET):
        self.DATASET = DATASET
    def add_DATASET(self, value):
        self.DATASET.append(value)
    def insert_DATASET_at(self, index, value):
        self.DATASET.insert(index, value)
    def replace_DATASET_at(self, index, value):
        self.DATASET[index] = value
    def _hasContent(self):
        if (
            self.DATASET
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DatasetsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatasetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DatasetsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatasetsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DatasetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DatasetsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DatasetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASET_ in self.DATASET:
            namespaceprefix_ = self.DATASET_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_nsprefix_) else ''
            DATASET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASET':
            class_obj_ = self.get_class_obj_(child_, DatasetType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET.append(obj_)
            obj_.original_tagname_ = 'DATASET'
# end class DatasetsType


class DataUseType(GeneratedsSuper):
    """ontology --
    Ontology abbreviation, e.g. DUO for Data Use Ontology

    * code --
      Code for the ontology

    * version --
      Data Use Ontology code version

    * MODIFIER --
      Describes modifiers to the Data Use Restriction

    * URL --
      Link to URL describing the Data Use

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ontology=None, code=None, version=None, MODIFIER=None, URL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ontology = _cast(None, ontology)
        self.ontology_nsprefix_ = None
        self.code = _cast(None, code)
        self.code_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        if MODIFIER is None:
            self.MODIFIER = []
        else:
            self.MODIFIER = MODIFIER
        self.MODIFIER_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataUseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataUseType.subclass:
            return DataUseType.subclass(*args_, **kwargs_)
        else:
            return DataUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MODIFIER(self):
        return self.MODIFIER
    def set_MODIFIER(self, MODIFIER):
        self.MODIFIER = MODIFIER
    def add_MODIFIER(self, value):
        self.MODIFIER.append(value)
    def insert_MODIFIER_at(self, index, value):
        self.MODIFIER.insert(index, value)
    def replace_MODIFIER_at(self, index, value):
        self.MODIFIER[index] = value
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def get_ontology(self):
        return self.ontology
    def set_ontology(self, ontology):
        self.ontology = ontology
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.MODIFIER or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataUseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataUseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataUseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataUseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataUseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataUseType'):
        if self.ontology is not None and 'ontology' not in already_processed:
            already_processed.add('ontology')
            outfile.write(' ontology=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ontology), input_name='ontology')), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataUseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MODIFIER_ in self.MODIFIER:
            namespaceprefix_ = self.MODIFIER_nsprefix_ + ':' if (UseCapturedNS_ and self.MODIFIER_nsprefix_) else ''
            MODIFIER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MODIFIER', pretty_print=pretty_print)
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ontology', node)
        if value is not None and 'ontology' not in already_processed:
            already_processed.add('ontology')
            self.ontology = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MODIFIER':
            obj_ = XRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MODIFIER.append(obj_)
            obj_.original_tagname_ = 'MODIFIER'
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
# end class DataUseType


class PolicySetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, POLICY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if POLICY is None:
            self.POLICY = []
        else:
            self.POLICY = POLICY
        self.POLICY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolicySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolicySetType.subclass:
            return PolicySetType.subclass(*args_, **kwargs_)
        else:
            return PolicySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_POLICY(self):
        return self.POLICY
    def set_POLICY(self, POLICY):
        self.POLICY = POLICY
    def add_POLICY(self, value):
        self.POLICY.append(value)
    def insert_POLICY_at(self, index, value):
        self.POLICY.insert(index, value)
    def replace_POLICY_at(self, index, value):
        self.POLICY[index] = value
    def _hasContent(self):
        if (
            self.POLICY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolicySetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolicySetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolicySetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolicySetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolicySetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolicySetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolicySetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for POLICY_ in self.POLICY:
            namespaceprefix_ = self.POLICY_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_nsprefix_) else ''
            POLICY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'POLICY':
            obj_ = PolicyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY.append(obj_)
            obj_.original_tagname_ = 'POLICY'
# end class PolicySetType


class AssemblySetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ASSEMBLY is None:
            self.ASSEMBLY = []
        else:
            self.ASSEMBLY = ASSEMBLY
        self.ASSEMBLY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssemblySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssemblySetType.subclass:
            return AssemblySetType.subclass(*args_, **kwargs_)
        else:
            return AssemblySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ASSEMBLY(self):
        return self.ASSEMBLY
    def set_ASSEMBLY(self, ASSEMBLY):
        self.ASSEMBLY = ASSEMBLY
    def add_ASSEMBLY(self, value):
        self.ASSEMBLY.append(value)
    def insert_ASSEMBLY_at(self, index, value):
        self.ASSEMBLY.insert(index, value)
    def replace_ASSEMBLY_at(self, index, value):
        self.ASSEMBLY[index] = value
    def _hasContent(self):
        if (
            self.ASSEMBLY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblySetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssemblySetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssemblySetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblySetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssemblySetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssemblySetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblySetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ASSEMBLY_ in self.ASSEMBLY:
            namespaceprefix_ = self.ASSEMBLY_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_nsprefix_) else ''
            ASSEMBLY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ASSEMBLY':
            obj_ = AssemblyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY.append(obj_)
            obj_.original_tagname_ = 'ASSEMBLY'
# end class AssemblySetType


class ChecklistSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CHECKLIST=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CHECKLIST is None:
            self.CHECKLIST = []
        else:
            self.CHECKLIST = CHECKLIST
        self.CHECKLIST_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChecklistSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChecklistSetType.subclass:
            return ChecklistSetType.subclass(*args_, **kwargs_)
        else:
            return ChecklistSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CHECKLIST(self):
        return self.CHECKLIST
    def set_CHECKLIST(self, CHECKLIST):
        self.CHECKLIST = CHECKLIST
    def add_CHECKLIST(self, value):
        self.CHECKLIST.append(value)
    def insert_CHECKLIST_at(self, index, value):
        self.CHECKLIST.insert(index, value)
    def replace_CHECKLIST_at(self, index, value):
        self.CHECKLIST[index] = value
    def _hasContent(self):
        if (
            self.CHECKLIST
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChecklistSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChecklistSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChecklistSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChecklistSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChecklistSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChecklistSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChecklistSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CHECKLIST_ in self.CHECKLIST:
            namespaceprefix_ = self.CHECKLIST_nsprefix_ + ':' if (UseCapturedNS_ and self.CHECKLIST_nsprefix_) else ''
            CHECKLIST_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CHECKLIST', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CHECKLIST':
            obj_ = ChecklistType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CHECKLIST.append(obj_)
            obj_.original_tagname_ = 'CHECKLIST'
# end class ChecklistSetType


class OrganismType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TAXON_ID=None, SCIENTIFIC_NAME=None, COMMON_NAME=None, STRAIN=None, BREED=None, CULTIVAR=None, ISOLATE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TAXON_ID = TAXON_ID
        self.TAXON_ID_nsprefix_ = None
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
        self.SCIENTIFIC_NAME_nsprefix_ = None
        self.COMMON_NAME = COMMON_NAME
        self.COMMON_NAME_nsprefix_ = None
        self.STRAIN = STRAIN
        self.STRAIN_nsprefix_ = None
        self.BREED = BREED
        self.BREED_nsprefix_ = None
        self.CULTIVAR = CULTIVAR
        self.CULTIVAR_nsprefix_ = None
        self.ISOLATE = ISOLATE
        self.ISOLATE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganismType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganismType.subclass:
            return OrganismType.subclass(*args_, **kwargs_)
        else:
            return OrganismType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAXON_ID(self):
        return self.TAXON_ID
    def set_TAXON_ID(self, TAXON_ID):
        self.TAXON_ID = TAXON_ID
    def get_SCIENTIFIC_NAME(self):
        return self.SCIENTIFIC_NAME
    def set_SCIENTIFIC_NAME(self, SCIENTIFIC_NAME):
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
    def get_COMMON_NAME(self):
        return self.COMMON_NAME
    def set_COMMON_NAME(self, COMMON_NAME):
        self.COMMON_NAME = COMMON_NAME
    def get_STRAIN(self):
        return self.STRAIN
    def set_STRAIN(self, STRAIN):
        self.STRAIN = STRAIN
    def get_BREED(self):
        return self.BREED
    def set_BREED(self, BREED):
        self.BREED = BREED
    def get_CULTIVAR(self):
        return self.CULTIVAR
    def set_CULTIVAR(self, CULTIVAR):
        self.CULTIVAR = CULTIVAR
    def get_ISOLATE(self):
        return self.ISOLATE
    def set_ISOLATE(self, ISOLATE):
        self.ISOLATE = ISOLATE
    def _hasContent(self):
        if (
            self.TAXON_ID is not None or
            self.SCIENTIFIC_NAME is not None or
            self.COMMON_NAME is not None or
            self.STRAIN is not None or
            self.BREED is not None or
            self.CULTIVAR is not None or
            self.ISOLATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganismType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganismType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OrganismType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OrganismType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OrganismType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OrganismType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OrganismType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAXON_ID is not None:
            namespaceprefix_ = self.TAXON_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXON_ID>%s</%sTAXON_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.TAXON_ID, input_name='TAXON_ID'), namespaceprefix_ , eol_))
        if self.SCIENTIFIC_NAME is not None:
            namespaceprefix_ = self.SCIENTIFIC_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCIENTIFIC_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCIENTIFIC_NAME>%s</%sSCIENTIFIC_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCIENTIFIC_NAME), input_name='SCIENTIFIC_NAME')), namespaceprefix_ , eol_))
        if self.COMMON_NAME is not None:
            namespaceprefix_ = self.COMMON_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMON_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMON_NAME>%s</%sCOMMON_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMMON_NAME), input_name='COMMON_NAME')), namespaceprefix_ , eol_))
        if self.STRAIN is not None:
            namespaceprefix_ = self.STRAIN_nsprefix_ + ':' if (UseCapturedNS_ and self.STRAIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTRAIN>%s</%sSTRAIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STRAIN), input_name='STRAIN')), namespaceprefix_ , eol_))
        if self.BREED is not None:
            namespaceprefix_ = self.BREED_nsprefix_ + ':' if (UseCapturedNS_ and self.BREED_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBREED>%s</%sBREED>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BREED), input_name='BREED')), namespaceprefix_ , eol_))
        if self.CULTIVAR is not None:
            namespaceprefix_ = self.CULTIVAR_nsprefix_ + ':' if (UseCapturedNS_ and self.CULTIVAR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCULTIVAR>%s</%sCULTIVAR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CULTIVAR), input_name='CULTIVAR')), namespaceprefix_ , eol_))
        if self.ISOLATE is not None:
            namespaceprefix_ = self.ISOLATE_nsprefix_ + ':' if (UseCapturedNS_ and self.ISOLATE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISOLATE>%s</%sISOLATE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISOLATE), input_name='ISOLATE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAXON_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TAXON_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'TAXON_ID')
            self.TAXON_ID = ival_
            self.TAXON_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCIENTIFIC_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCIENTIFIC_NAME')
            value_ = self.gds_validate_string(value_, node, 'SCIENTIFIC_NAME')
            self.SCIENTIFIC_NAME = value_
            self.SCIENTIFIC_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMON_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMMON_NAME')
            value_ = self.gds_validate_string(value_, node, 'COMMON_NAME')
            self.COMMON_NAME = value_
            self.COMMON_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STRAIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STRAIN')
            value_ = self.gds_validate_string(value_, node, 'STRAIN')
            self.STRAIN = value_
            self.STRAIN_nsprefix_ = child_.prefix
        elif nodeName_ == 'BREED':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BREED')
            value_ = self.gds_validate_string(value_, node, 'BREED')
            self.BREED = value_
            self.BREED_nsprefix_ = child_.prefix
        elif nodeName_ == 'CULTIVAR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CULTIVAR')
            value_ = self.gds_validate_string(value_, node, 'CULTIVAR')
            self.CULTIVAR = value_
            self.CULTIVAR_nsprefix_ = child_.prefix
        elif nodeName_ == 'ISOLATE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ISOLATE')
            value_ = self.gds_validate_string(value_, node, 'ISOLATE')
            self.ISOLATE = value_
            self.ISOLATE_nsprefix_ = child_.prefix
# end class OrganismType


class ProjectSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PROJECT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PROJECT is None:
            self.PROJECT = []
        else:
            self.PROJECT = PROJECT
        self.PROJECT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectSetType.subclass:
            return ProjectSetType.subclass(*args_, **kwargs_)
        else:
            return ProjectSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROJECT(self):
        return self.PROJECT
    def set_PROJECT(self, PROJECT):
        self.PROJECT = PROJECT
    def add_PROJECT(self, value):
        self.PROJECT.append(value)
    def insert_PROJECT_at(self, index, value):
        self.PROJECT.insert(index, value)
    def replace_PROJECT_at(self, index, value):
        self.PROJECT[index] = value
    def _hasContent(self):
        if (
            self.PROJECT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PROJECT_ in self.PROJECT:
            namespaceprefix_ = self.PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_nsprefix_) else ''
            PROJECT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROJECT':
            obj_ = ProjectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT.append(obj_)
            obj_.original_tagname_ = 'PROJECT'
# end class ProjectSetType


class AnalysisFileType(GeneratedsSuper):
    """filename -- The file name.
    filetype -- The type of the file.
    checksum_method -- The checksum method.
    checksum -- The file checksum.
    unencrypted_checksum -- The checksum of the unencrypted file (used in conjunction with the checksum of an encrypted file).

    * checklist -- The name of the checklist.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filename=None, filetype=None, checksum_method=None, checksum=None, unencrypted_checksum=None, checklist=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filename = _cast(None, filename)
        self.filename_nsprefix_ = None
        self.filetype = _cast(None, filetype)
        self.filetype_nsprefix_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.checksum_method_nsprefix_ = None
        self.checksum = _cast(None, checksum)
        self.checksum_nsprefix_ = None
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.unencrypted_checksum_nsprefix_ = None
        self.checklist = _cast(None, checklist)
        self.checklist_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnalysisFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnalysisFileType.subclass:
            return AnalysisFileType.subclass(*args_, **kwargs_)
        else:
            return AnalysisFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def get_filetype(self):
        return self.filetype
    def set_filetype(self, filetype):
        self.filetype = filetype
    def get_checksum_method(self):
        return self.checksum_method
    def set_checksum_method(self, checksum_method):
        self.checksum_method = checksum_method
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    def get_unencrypted_checksum(self):
        return self.unencrypted_checksum
    def set_unencrypted_checksum(self, unencrypted_checksum):
        self.unencrypted_checksum = unencrypted_checksum
    def get_checklist(self):
        return self.checklist
    def set_checklist(self, checklist):
        self.checklist = checklist
    def validate_filetypeType13(self, value):
        # Validate type filetypeType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['tab', 'bam', 'bai', 'cram', 'crai', 'vcf', 'vcf_aggregate', 'bcf', 'tabix', 'wig', 'bed', 'gff', 'fasta', 'fastq', 'flatfile', 'chromosome_list', 'sample_list', 'readme_file', 'phenotype_file', 'BioNano_native', 'Kallisto_native', 'agp', 'unlocalised_list', 'info', 'manifest', 'csi', 'bcf_aggregate', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on filetypeType13' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_checksum_methodType14(self, value):
        # Validate type checksum_methodType14, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MD5']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on checksum_methodType14' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnalysisFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnalysisFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnalysisFileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnalysisFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnalysisFileType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filetype), input_name='filetype')), ))
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum_method), input_name='checksum_method')), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum), input_name='checksum')), ))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unencrypted_checksum), input_name='unencrypted_checksum')), ))
        if self.checklist is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            outfile.write(' checklist=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checklist), input_name='checklist')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
            self.validate_filetypeType13(self.filetype)    # validate type filetypeType13
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
            self.validate_checksum_methodType14(self.checksum_method)    # validate type checksum_methodType14
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
        value = find_attr_value_('checklist', node)
        if value is not None and 'checklist' not in already_processed:
            already_processed.add('checklist')
            self.checklist = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AnalysisFileType


class AnalysisSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANALYSIS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANALYSIS is None:
            self.ANALYSIS = []
        else:
            self.ANALYSIS = ANALYSIS
        self.ANALYSIS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnalysisSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnalysisSetType.subclass:
            return AnalysisSetType.subclass(*args_, **kwargs_)
        else:
            return AnalysisSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANALYSIS(self):
        return self.ANALYSIS
    def set_ANALYSIS(self, ANALYSIS):
        self.ANALYSIS = ANALYSIS
    def add_ANALYSIS(self, value):
        self.ANALYSIS.append(value)
    def insert_ANALYSIS_at(self, index, value):
        self.ANALYSIS.insert(index, value)
    def replace_ANALYSIS_at(self, index, value):
        self.ANALYSIS[index] = value
    def _hasContent(self):
        if (
            self.ANALYSIS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnalysisSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnalysisSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnalysisSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnalysisSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnalysisSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_ in self.ANALYSIS:
            namespaceprefix_ = self.ANALYSIS_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_nsprefix_) else ''
            ANALYSIS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANALYSIS':
            obj_ = AnalysisType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS'
# end class AnalysisSetType


class ObjectType(GeneratedsSuper):
    """alias --
    Submitter designated name for the object. The name must be unique within the submission account.

    * center_name --
      The center name of the submitter.

    * broker_name --
      The center name of the broker.

    * accession --
      The object accession assigned by the archive.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        self.center_name = _cast(None, center_name)
        self.center_name_nsprefix_ = None
        self.broker_name = _cast(None, broker_name)
        self.broker_name_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.IDENTIFIERS = IDENTIFIERS
        self.IDENTIFIERS_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_center_name(self):
        return self.center_name
    def set_center_name(self, center_name):
        self.center_name = center_name
    def get_broker_name(self):
        return self.broker_name
    def set_broker_name(self, broker_name):
        self.broker_name = broker_name
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ObjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ObjectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ObjectType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ObjectType'):
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.center_name), input_name='center_name')), ))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.broker_name), input_name='broker_name')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            namespaceprefix_ = self.IDENTIFIERS_nsprefix_ + ':' if (UseCapturedNS_ and self.IDENTIFIERS_nsprefix_) else ''
            self.IDENTIFIERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IDENTIFIERS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class ObjectType


class RefObjectType(GeneratedsSuper):
    """refname --
    Identifies an object by name within the namespace defined by attribute "refcenter".

    * refcenter --
      The namespace of the attribute "refname".

    * accession --
      Identifies a record by its accession.  The scope of resolution is the entire Archive.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refname = _cast(None, refname)
        self.refname_nsprefix_ = None
        self.refcenter = _cast(None, refcenter)
        self.refcenter_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.IDENTIFIERS = IDENTIFIERS
        self.IDENTIFIERS_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RefObjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RefObjectType.subclass:
            return RefObjectType.subclass(*args_, **kwargs_)
        else:
            return RefObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS
    def get_refname(self):
        return self.refname
    def set_refname(self, refname):
        self.refname = refname
    def get_refcenter(self):
        return self.refcenter
    def set_refcenter(self, refcenter):
        self.refcenter = refcenter
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefObjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RefObjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RefObjectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RefObjectType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RefObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RefObjectType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refname), input_name='refname')), ))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refcenter), input_name='refcenter')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RefObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            namespaceprefix_ = self.IDENTIFIERS_nsprefix_ + ':' if (UseCapturedNS_ and self.IDENTIFIERS_nsprefix_) else ''
            self.IDENTIFIERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IDENTIFIERS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class RefObjectType


class NameType(GeneratedsSuper):
    """Alternative/explanatory description of the same object/identifier.
    label -- Alternative/explanatory description of the same object/identifier.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, label=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NameType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NameType


class QualifiedNameType(NameType):
    """namespace -- A string value that constrains the domain of named
    identifiers (namespace).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = NameType
    def __init__(self, label=None, namespace=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("QualifiedNameType"), self).__init__(label, valueOf_,  **kwargs_)
        self.namespace = _cast(None, namespace)
        self.namespace_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QualifiedNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QualifiedNameType.subclass:
            return QualifiedNameType.subclass(*args_, **kwargs_)
        else:
            return QualifiedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_namespace(self):
        return self.namespace
    def set_namespace(self, namespace):
        self.namespace = namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(QualifiedNameType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QualifiedNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QualifiedNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'QualifiedNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QualifiedNameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='QualifiedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='QualifiedNameType'):
        super(QualifiedNameType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QualifiedNameType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.namespace), input_name='namespace')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='QualifiedNameType', fromsubclass_=False, pretty_print=True):
        super(QualifiedNameType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        super(QualifiedNameType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class QualifiedNameType


class IdentifierType(GeneratedsSuper):
    """IdentifierType -- Set of record identifiers.
    PRIMARY_ID -- A primary identifier in the INSDC namespace.
    SECONDARY_ID -- A secondary identifier in the INSDC namespace.
    EXTERNAL_ID -- An identifer rom a public non-INSDC resource.
    SUBMITTER_ID -- A submitter provided identifier.
    UUID -- A universally unique identifier that requires no namespace.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PRIMARY_ID=None, SECONDARY_ID=None, EXTERNAL_ID=None, SUBMITTER_ID=None, UUID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PRIMARY_ID = PRIMARY_ID
        self.PRIMARY_ID_nsprefix_ = None
        if SECONDARY_ID is None:
            self.SECONDARY_ID = []
        else:
            self.SECONDARY_ID = SECONDARY_ID
        self.SECONDARY_ID_nsprefix_ = None
        if EXTERNAL_ID is None:
            self.EXTERNAL_ID = []
        else:
            self.EXTERNAL_ID = EXTERNAL_ID
        self.EXTERNAL_ID_nsprefix_ = None
        self.SUBMITTER_ID = SUBMITTER_ID
        self.SUBMITTER_ID_nsprefix_ = None
        if UUID is None:
            self.UUID = []
        else:
            self.UUID = UUID
        self.UUID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PRIMARY_ID(self):
        return self.PRIMARY_ID
    def set_PRIMARY_ID(self, PRIMARY_ID):
        self.PRIMARY_ID = PRIMARY_ID
    def get_SECONDARY_ID(self):
        return self.SECONDARY_ID
    def set_SECONDARY_ID(self, SECONDARY_ID):
        self.SECONDARY_ID = SECONDARY_ID
    def add_SECONDARY_ID(self, value):
        self.SECONDARY_ID.append(value)
    def insert_SECONDARY_ID_at(self, index, value):
        self.SECONDARY_ID.insert(index, value)
    def replace_SECONDARY_ID_at(self, index, value):
        self.SECONDARY_ID[index] = value
    def get_EXTERNAL_ID(self):
        return self.EXTERNAL_ID
    def set_EXTERNAL_ID(self, EXTERNAL_ID):
        self.EXTERNAL_ID = EXTERNAL_ID
    def add_EXTERNAL_ID(self, value):
        self.EXTERNAL_ID.append(value)
    def insert_EXTERNAL_ID_at(self, index, value):
        self.EXTERNAL_ID.insert(index, value)
    def replace_EXTERNAL_ID_at(self, index, value):
        self.EXTERNAL_ID[index] = value
    def get_SUBMITTER_ID(self):
        return self.SUBMITTER_ID
    def set_SUBMITTER_ID(self, SUBMITTER_ID):
        self.SUBMITTER_ID = SUBMITTER_ID
    def get_UUID(self):
        return self.UUID
    def set_UUID(self, UUID):
        self.UUID = UUID
    def add_UUID(self, value):
        self.UUID.append(value)
    def insert_UUID_at(self, index, value):
        self.UUID.insert(index, value)
    def replace_UUID_at(self, index, value):
        self.UUID[index] = value
    def _hasContent(self):
        if (
            self.PRIMARY_ID is not None or
            self.SECONDARY_ID or
            self.EXTERNAL_ID or
            self.SUBMITTER_ID is not None or
            self.UUID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifierType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifierType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PRIMARY_ID is not None:
            namespaceprefix_ = self.PRIMARY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PRIMARY_ID_nsprefix_) else ''
            self.PRIMARY_ID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PRIMARY_ID', pretty_print=pretty_print)
        for SECONDARY_ID_ in self.SECONDARY_ID:
            namespaceprefix_ = self.SECONDARY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.SECONDARY_ID_nsprefix_) else ''
            SECONDARY_ID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SECONDARY_ID', pretty_print=pretty_print)
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            namespaceprefix_ = self.EXTERNAL_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.EXTERNAL_ID_nsprefix_) else ''
            EXTERNAL_ID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXTERNAL_ID', pretty_print=pretty_print)
        if self.SUBMITTER_ID is not None:
            namespaceprefix_ = self.SUBMITTER_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMITTER_ID_nsprefix_) else ''
            self.SUBMITTER_ID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMITTER_ID', pretty_print=pretty_print)
        for UUID_ in self.UUID:
            namespaceprefix_ = self.UUID_nsprefix_ + ':' if (UseCapturedNS_ and self.UUID_nsprefix_) else ''
            UUID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UUID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PRIMARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PRIMARY_ID = obj_
            obj_.original_tagname_ = 'PRIMARY_ID'
        elif nodeName_ == 'SECONDARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SECONDARY_ID.append(obj_)
            obj_.original_tagname_ = 'SECONDARY_ID'
        elif nodeName_ == 'EXTERNAL_ID':
            obj_ = QualifiedNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXTERNAL_ID.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_ID'
        elif nodeName_ == 'SUBMITTER_ID':
            obj_ = QualifiedNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMITTER_ID = obj_
            obj_.original_tagname_ = 'SUBMITTER_ID'
        elif nodeName_ == 'UUID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UUID.append(obj_)
            obj_.original_tagname_ = 'UUID'
# end class IdentifierType


class XRefType(GeneratedsSuper):
    """DB --  INSDC controlled vocabulary of permitted cross references.
    Please see http://www.insdc.org/db_xref.html . For example, FLYBASE.
    ID --
    Accession in the referenced database.    For example,  FBtr0080008 (in FLYBASE).

    * LABEL --
      Text label to display for the link.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, LABEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DB = DB
        self.DB_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XRefType.subclass:
            return XRefType.subclass(*args_, **kwargs_)
        else:
            return XRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DB(self):
        return self.DB
    def set_DB(self, DB):
        self.DB = DB
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def _hasContent(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XRefType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='XRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            namespaceprefix_ = self.DB_nsprefix_ + ':' if (UseCapturedNS_ and self.DB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DB), input_name='DB')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ID), input_name='ID')), namespaceprefix_ , eol_))
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DB':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DB')
            value_ = self.gds_validate_string(value_, node, 'DB')
            self.DB = value_
            self.DB_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ID')
            value_ = self.gds_validate_string(value_, node, 'ID')
            self.ID = value_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
# end class XRefType


class URLType(GeneratedsSuper):
    """LABEL --
    Text label to display for the link.

    * URL --
      The internet service link (file:, http:, ftp:, etc).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URLType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='URLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
# end class URLType


class AttributeType(GeneratedsSuper):
    """AttributeType --
    Reusable attributes to encode tag-value pairs with optional units.

    * TAG --
      Name of the attribute.

    * VALUE --
      Value of the attribute.

    * UNITS --
      Optional scientific units.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TAG=None, VALUE=None, UNITS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TAG = TAG
        self.TAG_nsprefix_ = None
        self.VALUE = VALUE
        self.VALUE_nsprefix_ = None
        self.UNITS = UNITS
        self.UNITS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAG(self):
        return self.TAG
    def set_TAG(self, TAG):
        self.TAG = TAG
    def get_VALUE(self):
        return self.VALUE
    def set_VALUE(self, VALUE):
        self.VALUE = VALUE
    def get_UNITS(self):
        return self.UNITS
    def set_UNITS(self, UNITS):
        self.UNITS = UNITS
    def _hasContent(self):
        if (
            self.TAG is not None or
            self.VALUE is not None or
            self.UNITS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AttributeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            namespaceprefix_ = self.TAG_nsprefix_ + ':' if (UseCapturedNS_ and self.TAG_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TAG), input_name='TAG')), namespaceprefix_ , eol_))
        if self.VALUE is not None:
            namespaceprefix_ = self.VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), namespaceprefix_ , eol_))
        if self.UNITS is not None:
            namespaceprefix_ = self.UNITS_nsprefix_ + ':' if (UseCapturedNS_ and self.UNITS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UNITS), input_name='UNITS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAG':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TAG')
            value_ = self.gds_validate_string(value_, node, 'TAG')
            self.TAG = value_
            self.TAG_nsprefix_ = child_.prefix
        elif nodeName_ == 'VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VALUE')
            value_ = self.gds_validate_string(value_, node, 'VALUE')
            self.VALUE = value_
            self.VALUE_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNITS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNITS')
            value_ = self.gds_validate_string(value_, node, 'UNITS')
            self.UNITS = value_
            self.UNITS_nsprefix_ = child_.prefix
# end class AttributeType


class LinkType(GeneratedsSuper):
    """LinkType --
    Reusable external links type to encode URL links, Entrez links, and db_xref links.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, URL_LINK=None, XREF_LINK=None, ENTREZ_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.URL_LINK = URL_LINK
        self.URL_LINK_nsprefix_ = None
        self.XREF_LINK = XREF_LINK
        self.XREF_LINK_nsprefix_ = None
        self.ENTREZ_LINK = ENTREZ_LINK
        self.ENTREZ_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_URL_LINK(self):
        return self.URL_LINK
    def set_URL_LINK(self, URL_LINK):
        self.URL_LINK = URL_LINK
    def get_XREF_LINK(self):
        return self.XREF_LINK
    def set_XREF_LINK(self, XREF_LINK):
        self.XREF_LINK = XREF_LINK
    def get_ENTREZ_LINK(self):
        return self.ENTREZ_LINK
    def set_ENTREZ_LINK(self, ENTREZ_LINK):
        self.ENTREZ_LINK = ENTREZ_LINK
    def _hasContent(self):
        if (
            self.URL_LINK is not None or
            self.XREF_LINK is not None or
            self.ENTREZ_LINK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinkType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinkType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL_LINK is not None:
            namespaceprefix_ = self.URL_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_LINK_nsprefix_) else ''
            self.URL_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='URL_LINK', pretty_print=pretty_print)
        if self.XREF_LINK is not None:
            namespaceprefix_ = self.XREF_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.XREF_LINK_nsprefix_) else ''
            self.XREF_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XREF_LINK', pretty_print=pretty_print)
        if self.ENTREZ_LINK is not None:
            namespaceprefix_ = self.ENTREZ_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.ENTREZ_LINK_nsprefix_) else ''
            self.ENTREZ_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ENTREZ_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
        elif nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'ENTREZ_LINK':
            obj_ = ENTREZ_LINKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ENTREZ_LINK = obj_
            obj_.original_tagname_ = 'ENTREZ_LINK'
# end class LinkType


class SpotDescriptorType(GeneratedsSuper):
    """SpotDescriptorType --
    The SPOT_DESCRIPTOR specifies how to decode the individual reads of interest from the
    monolithic spot sequence.  The spot descriptor contains aspects of the experimental design,
    platform, and processing information.  There will be two methods of specification: one
    will be an index into a table of typical decodings, the other being an exact specification.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SPOT_DECODE_SPEC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
        self.SPOT_DECODE_SPEC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpotDescriptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpotDescriptorType.subclass:
            return SpotDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SpotDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SPOT_DECODE_SPEC(self):
        return self.SPOT_DECODE_SPEC
    def set_SPOT_DECODE_SPEC(self, SPOT_DECODE_SPEC):
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def _hasContent(self):
        if (
            self.SPOT_DECODE_SPEC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpotDescriptorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpotDescriptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpotDescriptorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpotDescriptorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpotDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpotDescriptorType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpotDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_DECODE_SPEC is not None:
            namespaceprefix_ = self.SPOT_DECODE_SPEC_nsprefix_ + ':' if (UseCapturedNS_ and self.SPOT_DECODE_SPEC_nsprefix_) else ''
            self.SPOT_DECODE_SPEC.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SPOT_DECODE_SPEC', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SPOT_DECODE_SPEC':
            obj_ = SPOT_DECODE_SPECType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SPOT_DECODE_SPEC = obj_
            obj_.original_tagname_ = 'SPOT_DECODE_SPEC'
# end class SpotDescriptorType


class PlatformType(GeneratedsSuper):
    """PlatformType --  The PLATFORM record selects which sequencing platform and platform-specific runtime parameters. This will be
    determined by the Center.
    LS454 --  454 technology use 1-color sequential flows
    ILLUMINA --  Illumina is 4-channel flowgram with 1-to-1 mapping between basecalls and flows
    HELICOS --  Helicos is similar to 454 technology - uses 1-color sequential flows
    ABI_SOLID --  ABI is 4-channel flowgram with 1-to-1 mapping between basecalls and flows
    COMPLETE_GENOMICS --  CompleteGenomics platform type. At present there is no instrument model.
    OXFORD_NANOPORE --  Oxford Nanopore platform type. nanopore-based electronic single molecule analysis
    PACBIO_SMRT --  PacificBiosciences platform type for the single molecule real time (SMRT) technology.
    ION_TORRENT --  Ion Torrent Personal Genome Machine (PGM) from Life Technologies.
    CAPILLARY --  Sequencers based on capillary electrophoresis technology manufactured by LifeTech (formerly Applied
    BioSciences).
    DNBSEQ --  Sequencers based on DNBSEQ by MGI Tech.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LS454=None, ILLUMINA=None, HELICOS=None, ABI_SOLID=None, COMPLETE_GENOMICS=None, BGISEQ=None, OXFORD_NANOPORE=None, PACBIO_SMRT=None, ION_TORRENT=None, CAPILLARY=None, DNBSEQ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LS454 = LS454
        self.LS454_nsprefix_ = None
        self.ILLUMINA = ILLUMINA
        self.ILLUMINA_nsprefix_ = None
        self.HELICOS = HELICOS
        self.HELICOS_nsprefix_ = None
        self.ABI_SOLID = ABI_SOLID
        self.ABI_SOLID_nsprefix_ = None
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
        self.COMPLETE_GENOMICS_nsprefix_ = None
        self.BGISEQ = BGISEQ
        self.BGISEQ_nsprefix_ = None
        self.OXFORD_NANOPORE = OXFORD_NANOPORE
        self.OXFORD_NANOPORE_nsprefix_ = None
        self.PACBIO_SMRT = PACBIO_SMRT
        self.PACBIO_SMRT_nsprefix_ = None
        self.ION_TORRENT = ION_TORRENT
        self.ION_TORRENT_nsprefix_ = None
        self.CAPILLARY = CAPILLARY
        self.CAPILLARY_nsprefix_ = None
        self.DNBSEQ = DNBSEQ
        self.DNBSEQ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlatformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LS454(self):
        return self.LS454
    def set_LS454(self, LS454):
        self.LS454 = LS454
    def get_ILLUMINA(self):
        return self.ILLUMINA
    def set_ILLUMINA(self, ILLUMINA):
        self.ILLUMINA = ILLUMINA
    def get_HELICOS(self):
        return self.HELICOS
    def set_HELICOS(self, HELICOS):
        self.HELICOS = HELICOS
    def get_ABI_SOLID(self):
        return self.ABI_SOLID
    def set_ABI_SOLID(self, ABI_SOLID):
        self.ABI_SOLID = ABI_SOLID
    def get_COMPLETE_GENOMICS(self):
        return self.COMPLETE_GENOMICS
    def set_COMPLETE_GENOMICS(self, COMPLETE_GENOMICS):
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
    def get_BGISEQ(self):
        return self.BGISEQ
    def set_BGISEQ(self, BGISEQ):
        self.BGISEQ = BGISEQ
    def get_OXFORD_NANOPORE(self):
        return self.OXFORD_NANOPORE
    def set_OXFORD_NANOPORE(self, OXFORD_NANOPORE):
        self.OXFORD_NANOPORE = OXFORD_NANOPORE
    def get_PACBIO_SMRT(self):
        return self.PACBIO_SMRT
    def set_PACBIO_SMRT(self, PACBIO_SMRT):
        self.PACBIO_SMRT = PACBIO_SMRT
    def get_ION_TORRENT(self):
        return self.ION_TORRENT
    def set_ION_TORRENT(self, ION_TORRENT):
        self.ION_TORRENT = ION_TORRENT
    def get_CAPILLARY(self):
        return self.CAPILLARY
    def set_CAPILLARY(self, CAPILLARY):
        self.CAPILLARY = CAPILLARY
    def get_DNBSEQ(self):
        return self.DNBSEQ
    def set_DNBSEQ(self, DNBSEQ):
        self.DNBSEQ = DNBSEQ
    def _hasContent(self):
        if (
            self.LS454 is not None or
            self.ILLUMINA is not None or
            self.HELICOS is not None or
            self.ABI_SOLID is not None or
            self.COMPLETE_GENOMICS is not None or
            self.BGISEQ is not None or
            self.OXFORD_NANOPORE is not None or
            self.PACBIO_SMRT is not None or
            self.ION_TORRENT is not None or
            self.CAPILLARY is not None or
            self.DNBSEQ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlatformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlatformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PlatformType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlatformType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PlatformType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LS454 is not None:
            namespaceprefix_ = self.LS454_nsprefix_ + ':' if (UseCapturedNS_ and self.LS454_nsprefix_) else ''
            self.LS454.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LS454', pretty_print=pretty_print)
        if self.ILLUMINA is not None:
            namespaceprefix_ = self.ILLUMINA_nsprefix_ + ':' if (UseCapturedNS_ and self.ILLUMINA_nsprefix_) else ''
            self.ILLUMINA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ILLUMINA', pretty_print=pretty_print)
        if self.HELICOS is not None:
            namespaceprefix_ = self.HELICOS_nsprefix_ + ':' if (UseCapturedNS_ and self.HELICOS_nsprefix_) else ''
            self.HELICOS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HELICOS', pretty_print=pretty_print)
        if self.ABI_SOLID is not None:
            namespaceprefix_ = self.ABI_SOLID_nsprefix_ + ':' if (UseCapturedNS_ and self.ABI_SOLID_nsprefix_) else ''
            self.ABI_SOLID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ABI_SOLID', pretty_print=pretty_print)
        if self.COMPLETE_GENOMICS is not None:
            namespaceprefix_ = self.COMPLETE_GENOMICS_nsprefix_ + ':' if (UseCapturedNS_ and self.COMPLETE_GENOMICS_nsprefix_) else ''
            self.COMPLETE_GENOMICS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COMPLETE_GENOMICS', pretty_print=pretty_print)
        if self.BGISEQ is not None:
            namespaceprefix_ = self.BGISEQ_nsprefix_ + ':' if (UseCapturedNS_ and self.BGISEQ_nsprefix_) else ''
            self.BGISEQ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BGISEQ', pretty_print=pretty_print)
        if self.OXFORD_NANOPORE is not None:
            namespaceprefix_ = self.OXFORD_NANOPORE_nsprefix_ + ':' if (UseCapturedNS_ and self.OXFORD_NANOPORE_nsprefix_) else ''
            self.OXFORD_NANOPORE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OXFORD_NANOPORE', pretty_print=pretty_print)
        if self.PACBIO_SMRT is not None:
            namespaceprefix_ = self.PACBIO_SMRT_nsprefix_ + ':' if (UseCapturedNS_ and self.PACBIO_SMRT_nsprefix_) else ''
            self.PACBIO_SMRT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PACBIO_SMRT', pretty_print=pretty_print)
        if self.ION_TORRENT is not None:
            namespaceprefix_ = self.ION_TORRENT_nsprefix_ + ':' if (UseCapturedNS_ and self.ION_TORRENT_nsprefix_) else ''
            self.ION_TORRENT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ION_TORRENT', pretty_print=pretty_print)
        if self.CAPILLARY is not None:
            namespaceprefix_ = self.CAPILLARY_nsprefix_ + ':' if (UseCapturedNS_ and self.CAPILLARY_nsprefix_) else ''
            self.CAPILLARY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CAPILLARY', pretty_print=pretty_print)
        if self.DNBSEQ is not None:
            namespaceprefix_ = self.DNBSEQ_nsprefix_ + ':' if (UseCapturedNS_ and self.DNBSEQ_nsprefix_) else ''
            self.DNBSEQ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DNBSEQ', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LS454':
            obj_ = LS454Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LS454 = obj_
            obj_.original_tagname_ = 'LS454'
        elif nodeName_ == 'ILLUMINA':
            obj_ = ILLUMINAType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ILLUMINA = obj_
            obj_.original_tagname_ = 'ILLUMINA'
        elif nodeName_ == 'HELICOS':
            obj_ = HELICOSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HELICOS = obj_
            obj_.original_tagname_ = 'HELICOS'
        elif nodeName_ == 'ABI_SOLID':
            obj_ = ABI_SOLIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ABI_SOLID = obj_
            obj_.original_tagname_ = 'ABI_SOLID'
        elif nodeName_ == 'COMPLETE_GENOMICS':
            obj_ = COMPLETE_GENOMICSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COMPLETE_GENOMICS = obj_
            obj_.original_tagname_ = 'COMPLETE_GENOMICS'
        elif nodeName_ == 'BGISEQ':
            obj_ = BGISEQType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BGISEQ = obj_
            obj_.original_tagname_ = 'BGISEQ'
        elif nodeName_ == 'OXFORD_NANOPORE':
            obj_ = OXFORD_NANOPOREType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OXFORD_NANOPORE = obj_
            obj_.original_tagname_ = 'OXFORD_NANOPORE'
        elif nodeName_ == 'PACBIO_SMRT':
            obj_ = PACBIO_SMRTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PACBIO_SMRT = obj_
            obj_.original_tagname_ = 'PACBIO_SMRT'
        elif nodeName_ == 'ION_TORRENT':
            obj_ = ION_TORRENTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ION_TORRENT = obj_
            obj_.original_tagname_ = 'ION_TORRENT'
        elif nodeName_ == 'CAPILLARY':
            obj_ = CAPILLARYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CAPILLARY = obj_
            obj_.original_tagname_ = 'CAPILLARY'
        elif nodeName_ == 'DNBSEQ':
            obj_ = DNBSEQType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DNBSEQ = obj_
            obj_.original_tagname_ = 'DNBSEQ'
# end class PlatformType


class SequencingDirectivesType(GeneratedsSuper):
    """SAMPLE_DEMUX_DIRECTIVE --
    Tells the Archive who will execute the sample demultiplexing operation..

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_DEMUX_DIRECTIVE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
        self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
        self.SAMPLE_DEMUX_DIRECTIVE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequencingDirectivesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequencingDirectivesType.subclass:
            return SequencingDirectivesType.subclass(*args_, **kwargs_)
        else:
            return SequencingDirectivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE_DEMUX_DIRECTIVE(self):
        return self.SAMPLE_DEMUX_DIRECTIVE
    def set_SAMPLE_DEMUX_DIRECTIVE(self, SAMPLE_DEMUX_DIRECTIVE):
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
    def validate_SAMPLE_DEMUX_DIRECTIVEType(self, value):
        result = True
        # Validate type SAMPLE_DEMUX_DIRECTIVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['leave_as_pool', 'submitter_demultiplexed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SAMPLE_DEMUX_DIRECTIVEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.SAMPLE_DEMUX_DIRECTIVE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequencingDirectivesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequencingDirectivesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequencingDirectivesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequencingDirectivesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequencingDirectivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequencingDirectivesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SequencingDirectivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            namespaceprefix_ = self.SAMPLE_DEMUX_DIRECTIVE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_DEMUX_DIRECTIVE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSAMPLE_DEMUX_DIRECTIVE>%s</%sSAMPLE_DEMUX_DIRECTIVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SAMPLE_DEMUX_DIRECTIVE), input_name='SAMPLE_DEMUX_DIRECTIVE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE_DEMUX_DIRECTIVE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            value_ = self.gds_validate_string(value_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            self.SAMPLE_DEMUX_DIRECTIVE = value_
            self.SAMPLE_DEMUX_DIRECTIVE_nsprefix_ = child_.prefix
            # validate type SAMPLE_DEMUX_DIRECTIVEType
            self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
# end class SequencingDirectivesType


class PipelineType(GeneratedsSuper):
    """PipelineType --  The PipelineType identifies the sequence or tree of actions to
    process the sequencing data.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PIPE_SECTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PIPE_SECTION is None:
            self.PIPE_SECTION = []
        else:
            self.PIPE_SECTION = PIPE_SECTION
        self.PIPE_SECTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PipelineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PipelineType.subclass:
            return PipelineType.subclass(*args_, **kwargs_)
        else:
            return PipelineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PIPE_SECTION(self):
        return self.PIPE_SECTION
    def set_PIPE_SECTION(self, PIPE_SECTION):
        self.PIPE_SECTION = PIPE_SECTION
    def add_PIPE_SECTION(self, value):
        self.PIPE_SECTION.append(value)
    def insert_PIPE_SECTION_at(self, index, value):
        self.PIPE_SECTION.insert(index, value)
    def replace_PIPE_SECTION_at(self, index, value):
        self.PIPE_SECTION[index] = value
    def _hasContent(self):
        if (
            self.PIPE_SECTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PipelineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PipelineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PipelineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PipelineType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PipelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PipelineType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PipelineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PIPE_SECTION_ in self.PIPE_SECTION:
            namespaceprefix_ = self.PIPE_SECTION_nsprefix_ + ':' if (UseCapturedNS_ and self.PIPE_SECTION_nsprefix_) else ''
            PIPE_SECTION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PIPE_SECTION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PIPE_SECTION':
            obj_ = PIPE_SECTIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PIPE_SECTION.append(obj_)
            obj_.original_tagname_ = 'PIPE_SECTION'
# end class PipelineType


class ReferenceAssemblyType(GeneratedsSuper):
    """ReferenceAssemblyType -- Reference assembly details.
    STANDARD -- A standard genome assembly.

    * CUSTOM -- Other genome assembly.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, STANDARD=None, CUSTOM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.STANDARD = STANDARD
        self.STANDARD_nsprefix_ = None
        self.CUSTOM = CUSTOM
        self.CUSTOM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceAssemblyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceAssemblyType.subclass:
            return ReferenceAssemblyType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssemblyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STANDARD(self):
        return self.STANDARD
    def set_STANDARD(self, STANDARD):
        self.STANDARD = STANDARD
    def get_CUSTOM(self):
        return self.CUSTOM
    def set_CUSTOM(self, CUSTOM):
        self.CUSTOM = CUSTOM
    def _hasContent(self):
        if (
            self.STANDARD is not None or
            self.CUSTOM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceAssemblyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceAssemblyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceAssemblyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceAssemblyType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceAssemblyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferenceAssemblyType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceAssemblyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STANDARD is not None:
            namespaceprefix_ = self.STANDARD_nsprefix_ + ':' if (UseCapturedNS_ and self.STANDARD_nsprefix_) else ''
            self.STANDARD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STANDARD', pretty_print=pretty_print)
        if self.CUSTOM is not None:
            namespaceprefix_ = self.CUSTOM_nsprefix_ + ':' if (UseCapturedNS_ and self.CUSTOM_nsprefix_) else ''
            self.CUSTOM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CUSTOM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STANDARD':
            obj_ = STANDARDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STANDARD = obj_
            obj_.original_tagname_ = 'STANDARD'
        elif nodeName_ == 'CUSTOM':
            obj_ = CUSTOMType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CUSTOM = obj_
            obj_.original_tagname_ = 'CUSTOM'
# end class ReferenceAssemblyType


class ReferenceSequenceType(GeneratedsSuper):
    """ReferenceSequenceType -- Reference assembly and sequence details.
    ASSEMBLY -- Reference assembly details.
    SEQUENCE -- Reference sequence details.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY=None, SEQUENCE=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ASSEMBLY = ASSEMBLY
        self.ASSEMBLY_nsprefix_ = None
        if SEQUENCE is None:
            self.SEQUENCE = []
        else:
            self.SEQUENCE = SEQUENCE
        self.SEQUENCE_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceSequenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceSequenceType.subclass:
            return ReferenceSequenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ASSEMBLY(self):
        return self.ASSEMBLY
    def set_ASSEMBLY(self, ASSEMBLY):
        self.ASSEMBLY = ASSEMBLY
    def get_SEQUENCE(self):
        return self.SEQUENCE
    def set_SEQUENCE(self, SEQUENCE):
        self.SEQUENCE = SEQUENCE
    def add_SEQUENCE(self, value):
        self.SEQUENCE.append(value)
    def insert_SEQUENCE_at(self, index, value):
        self.SEQUENCE.insert(index, value)
    def replace_SEQUENCE_at(self, index, value):
        self.SEQUENCE[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.ASSEMBLY is not None or
            self.SEQUENCE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceSequenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceSequenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReferenceSequenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceSequenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceSequenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReferenceSequenceType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReferenceSequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASSEMBLY is not None:
            namespaceprefix_ = self.ASSEMBLY_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_nsprefix_) else ''
            self.ASSEMBLY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY', pretty_print=pretty_print)
        for SEQUENCE_ in self.SEQUENCE:
            namespaceprefix_ = self.SEQUENCE_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCE_nsprefix_) else ''
            SEQUENCE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ASSEMBLY':
            obj_ = ReferenceAssemblyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY = obj_
            obj_.original_tagname_ = 'ASSEMBLY'
        elif nodeName_ == 'SEQUENCE':
            obj_ = SEQUENCEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCE.append(obj_)
            obj_.original_tagname_ = 'SEQUENCE'
# end class ReferenceSequenceType


class ProcessingType(GeneratedsSuper):
    """PIPELINE --  Generic processing pipeline specification.
    DIRECTIVES --  Processing directives tell the Sequence Read Archive how to
    treat the input data, if any treatment is requested.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PIPELINE=None, DIRECTIVES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PIPELINE = PIPELINE
        self.PIPELINE_nsprefix_ = None
        self.DIRECTIVES = DIRECTIVES
        self.DIRECTIVES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProcessingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PIPELINE(self):
        return self.PIPELINE
    def set_PIPELINE(self, PIPELINE):
        self.PIPELINE = PIPELINE
    def get_DIRECTIVES(self):
        return self.DIRECTIVES
    def set_DIRECTIVES(self, DIRECTIVES):
        self.DIRECTIVES = DIRECTIVES
    def _hasContent(self):
        if (
            self.PIPELINE is not None or
            self.DIRECTIVES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProcessingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProcessingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProcessingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProcessingType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProcessingType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PIPELINE is not None:
            namespaceprefix_ = self.PIPELINE_nsprefix_ + ':' if (UseCapturedNS_ and self.PIPELINE_nsprefix_) else ''
            self.PIPELINE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PIPELINE', pretty_print=pretty_print)
        if self.DIRECTIVES is not None:
            namespaceprefix_ = self.DIRECTIVES_nsprefix_ + ':' if (UseCapturedNS_ and self.DIRECTIVES_nsprefix_) else ''
            self.DIRECTIVES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DIRECTIVES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PIPELINE':
            obj_ = PipelineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PIPELINE = obj_
            obj_.original_tagname_ = 'PIPELINE'
        elif nodeName_ == 'DIRECTIVES':
            obj_ = SequencingDirectivesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DIRECTIVES = obj_
            obj_.original_tagname_ = 'DIRECTIVES'
# end class ProcessingType


class PoolMemberType(RefObjectType):
    """member_name --  Label a sample within a scope of the pool
    proportion --  Proportion of this sample (in percent) that was included in sample pool.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, member_name=None, proportion=None, READ_LABEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PoolMemberType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.member_name = _cast(None, member_name)
        self.member_name_nsprefix_ = None
        self.proportion = _cast(float, proportion)
        self.proportion_nsprefix_ = None
        if READ_LABEL is None:
            self.READ_LABEL = []
        else:
            self.READ_LABEL = READ_LABEL
        self.READ_LABEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PoolMemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PoolMemberType.subclass:
            return PoolMemberType.subclass(*args_, **kwargs_)
        else:
            return PoolMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_READ_LABEL(self):
        return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL):
        self.READ_LABEL = READ_LABEL
    def add_READ_LABEL(self, value):
        self.READ_LABEL.append(value)
    def insert_READ_LABEL_at(self, index, value):
        self.READ_LABEL.insert(index, value)
    def replace_READ_LABEL_at(self, index, value):
        self.READ_LABEL[index] = value
    def get_member_name(self):
        return self.member_name
    def set_member_name(self, member_name):
        self.member_name = member_name
    def get_proportion(self):
        return self.proportion
    def set_proportion(self, proportion):
        self.proportion = proportion
    def _hasContent(self):
        if (
            self.READ_LABEL or
            super(PoolMemberType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PoolMemberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PoolMemberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PoolMemberType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PoolMemberType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PoolMemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PoolMemberType'):
        super(PoolMemberType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PoolMemberType')
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            outfile.write(' member_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.member_name), input_name='member_name')), ))
        if self.proportion is not None and 'proportion' not in already_processed:
            already_processed.add('proportion')
            outfile.write(' proportion="%s"' % self.gds_format_float(self.proportion, input_name='proportion'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PoolMemberType', fromsubclass_=False, pretty_print=True):
        super(PoolMemberType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for READ_LABEL_ in self.READ_LABEL:
            namespaceprefix_ = self.READ_LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_LABEL_nsprefix_) else ''
            READ_LABEL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='READ_LABEL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('member_name', node)
        if value is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            self.member_name = value
        value = find_attr_value_('proportion', node)
        if value is not None and 'proportion' not in already_processed:
            already_processed.add('proportion')
            value = self.gds_parse_float(value, node, 'proportion')
            self.proportion = value
        super(PoolMemberType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'READ_LABEL':
            obj_ = READ_LABELType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.READ_LABEL.append(obj_)
            obj_.original_tagname_ = 'READ_LABEL'
        super(PoolMemberType, self)._buildChildren(child_, node, nodeName_, True)
# end class PoolMemberType


class SampleDescriptorType(RefObjectType):
    """POOL --
    Identifies a list of group/pool/multiplex sample members.  This implies that
    this sample record is a group, pool, or multiplex, but it continues to receive
    its own accession and can be referenced by an experiment.  By default if
    no match to any of the listed members can be determined, then the default
    sample reference is used.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, POOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SampleDescriptorType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.POOL = POOL
        self.POOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleDescriptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleDescriptorType.subclass:
            return SampleDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SampleDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_POOL(self):
        return self.POOL
    def set_POOL(self, POOL):
        self.POOL = POOL
    def _hasContent(self):
        if (
            self.POOL is not None or
            super(SampleDescriptorType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleDescriptorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleDescriptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SampleDescriptorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleDescriptorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleDescriptorType'):
        super(SampleDescriptorType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleDescriptorType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleDescriptorType', fromsubclass_=False, pretty_print=True):
        super(SampleDescriptorType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.POOL is not None:
            namespaceprefix_ = self.POOL_nsprefix_ + ':' if (UseCapturedNS_ and self.POOL_nsprefix_) else ''
            self.POOL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POOL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SampleDescriptorType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'POOL':
            obj_ = POOLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POOL = obj_
            obj_.original_tagname_ = 'POOL'
        super(SampleDescriptorType, self)._buildChildren(child_, node, nodeName_, True)
# end class SampleDescriptorType


class LibraryDescriptorType(GeneratedsSuper):
    """LibraryDescriptorType --  The LIBRARY_DESCRIPTOR specifies the origin of the material being
    sequenced and any treatments that the material might have undergone that affect the
    sequencing result. This specification is needed even if the platform does not
    require a library construction step per se.
    LIBRARY_NAME --
    The submitter's name for this library.

    * LIBRARY_LAYOUT --
      LIBRARY_LAYOUT specifies whether to expect single, paired, or other configuration of reads.
      In the case of paired reads, information about the relative distance and orientation is specified.

    * POOLING_STRATEGY --
      The optional pooling strategy indicates how the library or libraries are organized if multiple samples are involved.

    * LIBRARY_CONSTRUCTION_PROTOCOL --
      Free form text describing the protocol by which the sequencing library was constructed.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LIBRARY_NAME=None, LIBRARY_STRATEGY=None, LIBRARY_SOURCE=None, LIBRARY_SELECTION=None, LIBRARY_LAYOUT=None, TARGETED_LOCI=None, POOLING_STRATEGY=None, LIBRARY_CONSTRUCTION_PROTOCOL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LIBRARY_NAME = LIBRARY_NAME
        self.LIBRARY_NAME_nsprefix_ = None
        self.LIBRARY_STRATEGY = LIBRARY_STRATEGY
        self.validate_typeLibraryStrategy(self.LIBRARY_STRATEGY)
        self.LIBRARY_STRATEGY_nsprefix_ = None
        self.LIBRARY_SOURCE = LIBRARY_SOURCE
        self.validate_typeLibrarySource(self.LIBRARY_SOURCE)
        self.LIBRARY_SOURCE_nsprefix_ = None
        self.LIBRARY_SELECTION = LIBRARY_SELECTION
        self.validate_typeLibrarySelection(self.LIBRARY_SELECTION)
        self.LIBRARY_SELECTION_nsprefix_ = None
        self.LIBRARY_LAYOUT = LIBRARY_LAYOUT
        self.LIBRARY_LAYOUT_nsprefix_ = None
        self.TARGETED_LOCI = TARGETED_LOCI
        self.TARGETED_LOCI_nsprefix_ = None
        self.POOLING_STRATEGY = POOLING_STRATEGY
        self.validate_POOLING_STRATEGYType(self.POOLING_STRATEGY)
        self.POOLING_STRATEGY_nsprefix_ = None
        self.LIBRARY_CONSTRUCTION_PROTOCOL = LIBRARY_CONSTRUCTION_PROTOCOL
        self.LIBRARY_CONSTRUCTION_PROTOCOL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LibraryDescriptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LibraryDescriptorType.subclass:
            return LibraryDescriptorType.subclass(*args_, **kwargs_)
        else:
            return LibraryDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LIBRARY_NAME(self):
        return self.LIBRARY_NAME
    def set_LIBRARY_NAME(self, LIBRARY_NAME):
        self.LIBRARY_NAME = LIBRARY_NAME
    def get_LIBRARY_STRATEGY(self):
        return self.LIBRARY_STRATEGY
    def set_LIBRARY_STRATEGY(self, LIBRARY_STRATEGY):
        self.LIBRARY_STRATEGY = LIBRARY_STRATEGY
    def get_LIBRARY_SOURCE(self):
        return self.LIBRARY_SOURCE
    def set_LIBRARY_SOURCE(self, LIBRARY_SOURCE):
        self.LIBRARY_SOURCE = LIBRARY_SOURCE
    def get_LIBRARY_SELECTION(self):
        return self.LIBRARY_SELECTION
    def set_LIBRARY_SELECTION(self, LIBRARY_SELECTION):
        self.LIBRARY_SELECTION = LIBRARY_SELECTION
    def get_LIBRARY_LAYOUT(self):
        return self.LIBRARY_LAYOUT
    def set_LIBRARY_LAYOUT(self, LIBRARY_LAYOUT):
        self.LIBRARY_LAYOUT = LIBRARY_LAYOUT
    def get_TARGETED_LOCI(self):
        return self.TARGETED_LOCI
    def set_TARGETED_LOCI(self, TARGETED_LOCI):
        self.TARGETED_LOCI = TARGETED_LOCI
    def get_POOLING_STRATEGY(self):
        return self.POOLING_STRATEGY
    def set_POOLING_STRATEGY(self, POOLING_STRATEGY):
        self.POOLING_STRATEGY = POOLING_STRATEGY
    def get_LIBRARY_CONSTRUCTION_PROTOCOL(self):
        return self.LIBRARY_CONSTRUCTION_PROTOCOL
    def set_LIBRARY_CONSTRUCTION_PROTOCOL(self, LIBRARY_CONSTRUCTION_PROTOCOL):
        self.LIBRARY_CONSTRUCTION_PROTOCOL = LIBRARY_CONSTRUCTION_PROTOCOL
    def validate_typeLibraryStrategy(self, value):
        result = True
        # Validate type typeLibraryStrategy, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['WGS', 'WGA', 'WXS', 'RNA-Seq', 'ssRNA-seq', 'miRNA-Seq', 'ncRNA-Seq', 'FL-cDNA', 'EST', 'Hi-C', 'ATAC-seq', 'WCS', 'RAD-Seq', 'CLONE', 'POOLCLONE', 'AMPLICON', 'CLONEEND', 'FINISHING', 'ChIP-Seq', 'MNase-Seq', 'DNase-Hypersensitivity', 'Bisulfite-Seq', 'CTS', 'MRE-Seq', 'MeDIP-Seq', 'MBD-Seq', 'Tn-Seq', 'VALIDATION', 'FAIRE-seq', 'SELEX', 'RIP-Seq', 'ChIA-PET', 'Synthetic-Long-Read', 'Targeted-Capture', 'Tethered Chromatin Conformation Capture', 'NOMe-Seq', 'ChM-Seq', 'GBS', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeLibraryStrategy' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_typeLibrarySource(self, value):
        result = True
        # Validate type typeLibrarySource, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['GENOMIC', 'GENOMIC SINGLE CELL', 'TRANSCRIPTOMIC', 'TRANSCRIPTOMIC SINGLE CELL', 'METAGENOMIC', 'METATRANSCRIPTOMIC', 'SYNTHETIC', 'VIRAL RNA', 'OTHER']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeLibrarySource' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_typeLibrarySelection(self, value):
        result = True
        # Validate type typeLibrarySelection, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['RANDOM', 'PCR', 'RANDOM PCR', 'RT-PCR', 'HMPR', 'MF', 'repeat fractionation', 'size fractionation', 'MSLL', 'cDNA', 'cDNA_randomPriming', 'cDNA_oligo_dT', 'PolyA', 'Oligo-dT', 'Inverse rRNA', 'Inverse rRNA selection', 'ChIP', 'ChIP-Seq', 'MNase', 'DNase', 'Hybrid Selection', 'Reduced Representation', 'Restriction Digest', '5-methylcytidine antibody', 'MBD2 protein methyl-CpG binding domain', 'CAGE', 'RACE', 'MDA', 'padlock probes capture method', 'other', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeLibrarySelection' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_POOLING_STRATEGYType(self, value):
        result = True
        # Validate type POOLING_STRATEGYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.LIBRARY_NAME is not None or
            self.LIBRARY_STRATEGY is not None or
            self.LIBRARY_SOURCE is not None or
            self.LIBRARY_SELECTION is not None or
            self.LIBRARY_LAYOUT is not None or
            self.TARGETED_LOCI is not None or
            self.POOLING_STRATEGY is not None or
            self.LIBRARY_CONSTRUCTION_PROTOCOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LibraryDescriptorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LibraryDescriptorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LibraryDescriptorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LibraryDescriptorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LibraryDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LibraryDescriptorType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LibraryDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LIBRARY_NAME is not None:
            namespaceprefix_ = self.LIBRARY_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_NAME>%s</%sLIBRARY_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIBRARY_NAME), input_name='LIBRARY_NAME')), namespaceprefix_ , eol_))
        if self.LIBRARY_STRATEGY is not None:
            namespaceprefix_ = self.LIBRARY_STRATEGY_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_STRATEGY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_STRATEGY>%s</%sLIBRARY_STRATEGY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIBRARY_STRATEGY), input_name='LIBRARY_STRATEGY')), namespaceprefix_ , eol_))
        if self.LIBRARY_SOURCE is not None:
            namespaceprefix_ = self.LIBRARY_SOURCE_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_SOURCE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_SOURCE>%s</%sLIBRARY_SOURCE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIBRARY_SOURCE), input_name='LIBRARY_SOURCE')), namespaceprefix_ , eol_))
        if self.LIBRARY_SELECTION is not None:
            namespaceprefix_ = self.LIBRARY_SELECTION_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_SELECTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_SELECTION>%s</%sLIBRARY_SELECTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIBRARY_SELECTION), input_name='LIBRARY_SELECTION')), namespaceprefix_ , eol_))
        if self.LIBRARY_LAYOUT is not None:
            namespaceprefix_ = self.LIBRARY_LAYOUT_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_LAYOUT_nsprefix_) else ''
            self.LIBRARY_LAYOUT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LIBRARY_LAYOUT', pretty_print=pretty_print)
        if self.TARGETED_LOCI is not None:
            namespaceprefix_ = self.TARGETED_LOCI_nsprefix_ + ':' if (UseCapturedNS_ and self.TARGETED_LOCI_nsprefix_) else ''
            self.TARGETED_LOCI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TARGETED_LOCI', pretty_print=pretty_print)
        if self.POOLING_STRATEGY is not None:
            namespaceprefix_ = self.POOLING_STRATEGY_nsprefix_ + ':' if (UseCapturedNS_ and self.POOLING_STRATEGY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOOLING_STRATEGY>%s</%sPOOLING_STRATEGY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.POOLING_STRATEGY), input_name='POOLING_STRATEGY')), namespaceprefix_ , eol_))
        if self.LIBRARY_CONSTRUCTION_PROTOCOL is not None:
            namespaceprefix_ = self.LIBRARY_CONSTRUCTION_PROTOCOL_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_CONSTRUCTION_PROTOCOL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_CONSTRUCTION_PROTOCOL>%s</%sLIBRARY_CONSTRUCTION_PROTOCOL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LIBRARY_CONSTRUCTION_PROTOCOL), input_name='LIBRARY_CONSTRUCTION_PROTOCOL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LIBRARY_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIBRARY_NAME')
            value_ = self.gds_validate_string(value_, node, 'LIBRARY_NAME')
            self.LIBRARY_NAME = value_
            self.LIBRARY_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'LIBRARY_STRATEGY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIBRARY_STRATEGY')
            value_ = self.gds_validate_string(value_, node, 'LIBRARY_STRATEGY')
            self.LIBRARY_STRATEGY = value_
            self.LIBRARY_STRATEGY_nsprefix_ = child_.prefix
            # validate type typeLibraryStrategy
            self.validate_typeLibraryStrategy(self.LIBRARY_STRATEGY)
        elif nodeName_ == 'LIBRARY_SOURCE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIBRARY_SOURCE')
            value_ = self.gds_validate_string(value_, node, 'LIBRARY_SOURCE')
            self.LIBRARY_SOURCE = value_
            self.LIBRARY_SOURCE_nsprefix_ = child_.prefix
            # validate type typeLibrarySource
            self.validate_typeLibrarySource(self.LIBRARY_SOURCE)
        elif nodeName_ == 'LIBRARY_SELECTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIBRARY_SELECTION')
            value_ = self.gds_validate_string(value_, node, 'LIBRARY_SELECTION')
            self.LIBRARY_SELECTION = value_
            self.LIBRARY_SELECTION_nsprefix_ = child_.prefix
            # validate type typeLibrarySelection
            self.validate_typeLibrarySelection(self.LIBRARY_SELECTION)
        elif nodeName_ == 'LIBRARY_LAYOUT':
            obj_ = LIBRARY_LAYOUTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LIBRARY_LAYOUT = obj_
            obj_.original_tagname_ = 'LIBRARY_LAYOUT'
        elif nodeName_ == 'TARGETED_LOCI':
            obj_ = TARGETED_LOCIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TARGETED_LOCI = obj_
            obj_.original_tagname_ = 'TARGETED_LOCI'
        elif nodeName_ == 'POOLING_STRATEGY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'POOLING_STRATEGY')
            value_ = self.gds_validate_string(value_, node, 'POOLING_STRATEGY')
            self.POOLING_STRATEGY = value_
            self.POOLING_STRATEGY_nsprefix_ = child_.prefix
            # validate type POOLING_STRATEGYType
            self.validate_POOLING_STRATEGYType(self.POOLING_STRATEGY)
        elif nodeName_ == 'LIBRARY_CONSTRUCTION_PROTOCOL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LIBRARY_CONSTRUCTION_PROTOCOL')
            value_ = self.gds_validate_string(value_, node, 'LIBRARY_CONSTRUCTION_PROTOCOL')
            self.LIBRARY_CONSTRUCTION_PROTOCOL = value_
            self.LIBRARY_CONSTRUCTION_PROTOCOL_nsprefix_ = child_.prefix
# end class LibraryDescriptorType


class LibraryType(GeneratedsSuper):
    """DESIGN_DESCRIPTION -- Goal and setup of the individual library including library was constructed.
    SAMPLE_DESCRIPTOR --  Pick a sample to associate this experiment with. The sample may be an individual or a pool,
    depending on how it is specified.
    LIBRARY_DESCRIPTOR --  The LIBRARY_DESCRIPTOR specifies the origin of the material being sequenced and any
    treatments that the material might have undergone that affect the sequencing result. This specification is
    needed even if the platform does not require a library construction step per se.
    SPOT_DESCRIPTOR --  The SPOT_DESCRIPTOR specifies how to decode the individual reads of interest from the
    monolithic spot sequence. The spot descriptor contains aspects of the experimental design, platform, and
    processing information. There will be two methods of specification: one will be an index into a table of
    typical decodings, the other being an exact specification. This construct is needed for loading data and for
    interpreting the loaded runs. It can be omitted if the loader can infer read layout (from multiple input
    files or from one input files).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DESIGN_DESCRIPTION=None, SAMPLE_DESCRIPTOR=None, LIBRARY_DESCRIPTOR=None, SPOT_DESCRIPTOR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DESIGN_DESCRIPTION = DESIGN_DESCRIPTION
        self.DESIGN_DESCRIPTION_nsprefix_ = None
        self.SAMPLE_DESCRIPTOR = SAMPLE_DESCRIPTOR
        self.SAMPLE_DESCRIPTOR_nsprefix_ = None
        self.LIBRARY_DESCRIPTOR = LIBRARY_DESCRIPTOR
        self.LIBRARY_DESCRIPTOR_nsprefix_ = None
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
        self.SPOT_DESCRIPTOR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LibraryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LibraryType.subclass:
            return LibraryType.subclass(*args_, **kwargs_)
        else:
            return LibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DESIGN_DESCRIPTION(self):
        return self.DESIGN_DESCRIPTION
    def set_DESIGN_DESCRIPTION(self, DESIGN_DESCRIPTION):
        self.DESIGN_DESCRIPTION = DESIGN_DESCRIPTION
    def get_SAMPLE_DESCRIPTOR(self):
        return self.SAMPLE_DESCRIPTOR
    def set_SAMPLE_DESCRIPTOR(self, SAMPLE_DESCRIPTOR):
        self.SAMPLE_DESCRIPTOR = SAMPLE_DESCRIPTOR
    def get_LIBRARY_DESCRIPTOR(self):
        return self.LIBRARY_DESCRIPTOR
    def set_LIBRARY_DESCRIPTOR(self, LIBRARY_DESCRIPTOR):
        self.LIBRARY_DESCRIPTOR = LIBRARY_DESCRIPTOR
    def get_SPOT_DESCRIPTOR(self):
        return self.SPOT_DESCRIPTOR
    def set_SPOT_DESCRIPTOR(self, SPOT_DESCRIPTOR):
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
    def _hasContent(self):
        if (
            self.DESIGN_DESCRIPTION is not None or
            self.SAMPLE_DESCRIPTOR is not None or
            self.LIBRARY_DESCRIPTOR is not None or
            self.SPOT_DESCRIPTOR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LibraryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LibraryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LibraryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LibraryType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LibraryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESIGN_DESCRIPTION is not None:
            namespaceprefix_ = self.DESIGN_DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESIGN_DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESIGN_DESCRIPTION>%s</%sDESIGN_DESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESIGN_DESCRIPTION), input_name='DESIGN_DESCRIPTION')), namespaceprefix_ , eol_))
        if self.SAMPLE_DESCRIPTOR is not None:
            namespaceprefix_ = self.SAMPLE_DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_DESCRIPTOR_nsprefix_) else ''
            self.SAMPLE_DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_DESCRIPTOR', pretty_print=pretty_print)
        if self.LIBRARY_DESCRIPTOR is not None:
            namespaceprefix_ = self.LIBRARY_DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.LIBRARY_DESCRIPTOR_nsprefix_) else ''
            self.LIBRARY_DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LIBRARY_DESCRIPTOR', pretty_print=pretty_print)
        if self.SPOT_DESCRIPTOR is not None:
            namespaceprefix_ = self.SPOT_DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.SPOT_DESCRIPTOR_nsprefix_) else ''
            self.SPOT_DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SPOT_DESCRIPTOR', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DESIGN_DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESIGN_DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESIGN_DESCRIPTION')
            self.DESIGN_DESCRIPTION = value_
            self.DESIGN_DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'SAMPLE_DESCRIPTOR':
            obj_ = SampleDescriptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SAMPLE_DESCRIPTOR'
        elif nodeName_ == 'LIBRARY_DESCRIPTOR':
            obj_ = LibraryDescriptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LIBRARY_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'LIBRARY_DESCRIPTOR'
        elif nodeName_ == 'SPOT_DESCRIPTOR':
            obj_ = SpotDescriptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SPOT_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SPOT_DESCRIPTOR'
# end class LibraryType


class ExperimentType(ObjectType):
    """ExperimentType --
    An Experiment specifies of what will be sequenced and how the sequencing will be performed.
    It does not contain results.
    An Experiment is composed of a design, a platform selection, and processing parameters.

    * TITLE --
      Short text that can be used to call out experiment records in searches or in displays.
      This element is technically optional but should be used for all new records.

    * STUDY_REF --
      Identifies the parent study.

    * DESIGN --  The library design including library properties, layout, protocol, targeting information, and spot and gap
      descriptors.
    * PLATFORM --
      The PLATFORM record selects which sequencing platform and platform-specific runtime parameters.
      This will be determined by the Center.

    * EXPERIMENT_LINKS --
      Links to resources related to this experiment or experiment set (publication, datasets, online databases).

    * EXPERIMENT_ATTRIBUTES --
      Properties and attributes of the experiment.  These can be entered as free-form
      tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, STUDY_REF=None, DESIGN=None, PLATFORM=None, PROCESSING=None, EXPERIMENT_LINKS=None, EXPERIMENT_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ExperimentType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.STUDY_REF = STUDY_REF
        self.STUDY_REF_nsprefix_ = None
        self.DESIGN = DESIGN
        self.DESIGN_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.PLATFORM_nsprefix_ = None
        self.PROCESSING = PROCESSING
        self.PROCESSING_nsprefix_ = None
        self.EXPERIMENT_LINKS = EXPERIMENT_LINKS
        self.EXPERIMENT_LINKS_nsprefix_ = None
        self.EXPERIMENT_ATTRIBUTES = EXPERIMENT_ATTRIBUTES
        self.EXPERIMENT_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExperimentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExperimentType.subclass:
            return ExperimentType.subclass(*args_, **kwargs_)
        else:
            return ExperimentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_STUDY_REF(self):
        return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF
    def get_DESIGN(self):
        return self.DESIGN
    def set_DESIGN(self, DESIGN):
        self.DESIGN = DESIGN
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_PROCESSING(self):
        return self.PROCESSING
    def set_PROCESSING(self, PROCESSING):
        self.PROCESSING = PROCESSING
    def get_EXPERIMENT_LINKS(self):
        return self.EXPERIMENT_LINKS
    def set_EXPERIMENT_LINKS(self, EXPERIMENT_LINKS):
        self.EXPERIMENT_LINKS = EXPERIMENT_LINKS
    def get_EXPERIMENT_ATTRIBUTES(self):
        return self.EXPERIMENT_ATTRIBUTES
    def set_EXPERIMENT_ATTRIBUTES(self, EXPERIMENT_ATTRIBUTES):
        self.EXPERIMENT_ATTRIBUTES = EXPERIMENT_ATTRIBUTES
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.STUDY_REF is not None or
            self.DESIGN is not None or
            self.PLATFORM is not None or
            self.PROCESSING is not None or
            self.EXPERIMENT_LINKS is not None or
            self.EXPERIMENT_ATTRIBUTES is not None or
            super(ExperimentType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExperimentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExperimentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExperimentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExperimentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExperimentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExperimentType'):
        super(ExperimentType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExperimentType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExperimentType', fromsubclass_=False, pretty_print=True):
        super(ExperimentType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.STUDY_REF is not None:
            namespaceprefix_ = self.STUDY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_REF_nsprefix_) else ''
            self.STUDY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_REF', pretty_print=pretty_print)
        if self.DESIGN is not None:
            namespaceprefix_ = self.DESIGN_nsprefix_ + ':' if (UseCapturedNS_ and self.DESIGN_nsprefix_) else ''
            self.DESIGN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DESIGN', pretty_print=pretty_print)
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            self.PLATFORM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PLATFORM', pretty_print=pretty_print)
        if self.PROCESSING is not None:
            namespaceprefix_ = self.PROCESSING_nsprefix_ + ':' if (UseCapturedNS_ and self.PROCESSING_nsprefix_) else ''
            self.PROCESSING.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROCESSING', pretty_print=pretty_print)
        if self.EXPERIMENT_LINKS is not None:
            namespaceprefix_ = self.EXPERIMENT_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_LINKS_nsprefix_) else ''
            self.EXPERIMENT_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_LINKS', pretty_print=pretty_print)
        if self.EXPERIMENT_ATTRIBUTES is not None:
            namespaceprefix_ = self.EXPERIMENT_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_ATTRIBUTES_nsprefix_) else ''
            self.EXPERIMENT_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ExperimentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType24.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'DESIGN':
            obj_ = LibraryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DESIGN = obj_
            obj_.original_tagname_ = 'DESIGN'
        elif nodeName_ == 'PLATFORM':
            obj_ = PlatformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PLATFORM = obj_
            obj_.original_tagname_ = 'PLATFORM'
        elif nodeName_ == 'PROCESSING':
            obj_ = ProcessingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROCESSING = obj_
            obj_.original_tagname_ = 'PROCESSING'
        elif nodeName_ == 'EXPERIMENT_LINKS':
            obj_ = EXPERIMENT_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_LINKS = obj_
            obj_.original_tagname_ = 'EXPERIMENT_LINKS'
        elif nodeName_ == 'EXPERIMENT_ATTRIBUTES':
            obj_ = EXPERIMENT_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'EXPERIMENT_ATTRIBUTES'
        super(ExperimentType, self)._buildChildren(child_, node, nodeName_, True)
# end class ExperimentType


class ExperimentSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if EXPERIMENT is None:
            self.EXPERIMENT = []
        else:
            self.EXPERIMENT = EXPERIMENT
        self.EXPERIMENT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExperimentSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExperimentSetType.subclass:
            return ExperimentSetType.subclass(*args_, **kwargs_)
        else:
            return ExperimentSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EXPERIMENT(self):
        return self.EXPERIMENT
    def set_EXPERIMENT(self, EXPERIMENT):
        self.EXPERIMENT = EXPERIMENT
    def add_EXPERIMENT(self, value):
        self.EXPERIMENT.append(value)
    def insert_EXPERIMENT_at(self, index, value):
        self.EXPERIMENT.insert(index, value)
    def replace_EXPERIMENT_at(self, index, value):
        self.EXPERIMENT[index] = value
    def _hasContent(self):
        if (
            self.EXPERIMENT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExperimentSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExperimentSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExperimentSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExperimentSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExperimentSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExperimentSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ExperimentSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_ in self.EXPERIMENT:
            namespaceprefix_ = self.EXPERIMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_nsprefix_) else ''
            EXPERIMENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EXPERIMENT':
            obj_ = ExperimentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT'
# end class ExperimentSetType


class ID(GeneratedsSuper):
    """EXT_ID -- The REF identifies the reference of that object .

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, alias=None, holdUntilDate=None, status=None, EXT_ID=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.alias = _cast(None, alias)
        self.alias_nsprefix_ = None
        if isinstance(holdUntilDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(holdUntilDate, '%Y-%m-%d').date()
        else:
            initvalue_ = holdUntilDate
        self.holdUntilDate = initvalue_
        self.status = _cast(None, status)
        self.status_nsprefix_ = None
        if EXT_ID is None:
            self.EXT_ID = []
        else:
            self.EXT_ID = EXT_ID
        self.EXT_ID_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ID.subclass:
            return ID.subclass(*args_, **kwargs_)
        else:
            return ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EXT_ID(self):
        return self.EXT_ID
    def set_EXT_ID(self, EXT_ID):
        self.EXT_ID = EXT_ID
    def add_EXT_ID(self, value):
        self.EXT_ID.append(value)
    def insert_EXT_ID_at(self, index, value):
        self.EXT_ID.insert(index, value)
    def replace_EXT_ID_at(self, index, value):
        self.EXT_ID[index] = value
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    def get_holdUntilDate(self):
        return self.holdUntilDate
    def set_holdUntilDate(self, holdUntilDate):
        self.holdUntilDate = holdUntilDate
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def validate_statusType(self, value):
        # Validate type statusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DRAFT', 'PRIVATE', 'CANCELLED', 'PUBLIC', 'SUPPRESSED', 'KILLED', 'TEMPORARY_SUPPRESSED', 'TEMPORARY_KILLED']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on statusType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.EXT_ID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ID', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ID':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ID')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ID', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ID'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alias), input_name='alias')), ))
        if self.holdUntilDate is not None and 'holdUntilDate' not in already_processed:
            already_processed.add('holdUntilDate')
            outfile.write(' holdUntilDate="%s"' % self.gds_format_date(self.holdUntilDate, input_name='holdUntilDate'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.status), input_name='status')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ID', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXT_ID_ in self.EXT_ID:
            namespaceprefix_ = self.EXT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.EXT_ID_nsprefix_) else ''
            EXT_ID_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXT_ID', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('holdUntilDate', node)
        if value is not None and 'holdUntilDate' not in already_processed:
            already_processed.add('holdUntilDate')
            try:
                self.holdUntilDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (holdUntilDate): %s' % exp)
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_statusType(self.status)    # validate type statusType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EXT_ID':
            obj_ = EXT_IDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXT_ID.append(obj_)
            obj_.original_tagname_ = 'EXT_ID'
# end class ID


class RECEIPT(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, success=None, receiptDate=None, submissionFile=None, ANALYSIS=None, EXPERIMENT=None, RUN=None, SAMPLE=None, SAMPLEGROUP=None, STUDY=None, DAC=None, POLICY=None, DATASET=None, PROJECT=None, CHECKLIST=None, SUBMISSION=None, MESSAGES=None, ACTIONS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.success = _cast(bool, success)
        self.success_nsprefix_ = None
        if isinstance(receiptDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(receiptDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = receiptDate
        self.receiptDate = initvalue_
        self.submissionFile = _cast(None, submissionFile)
        self.submissionFile_nsprefix_ = None
        if ANALYSIS is None:
            self.ANALYSIS = []
        else:
            self.ANALYSIS = ANALYSIS
        self.ANALYSIS_nsprefix_ = None
        if EXPERIMENT is None:
            self.EXPERIMENT = []
        else:
            self.EXPERIMENT = EXPERIMENT
        self.EXPERIMENT_nsprefix_ = None
        if RUN is None:
            self.RUN = []
        else:
            self.RUN = RUN
        self.RUN_nsprefix_ = None
        if SAMPLE is None:
            self.SAMPLE = []
        else:
            self.SAMPLE = SAMPLE
        self.SAMPLE_nsprefix_ = None
        if SAMPLEGROUP is None:
            self.SAMPLEGROUP = []
        else:
            self.SAMPLEGROUP = SAMPLEGROUP
        self.SAMPLEGROUP_nsprefix_ = None
        if STUDY is None:
            self.STUDY = []
        else:
            self.STUDY = STUDY
        self.STUDY_nsprefix_ = None
        if DAC is None:
            self.DAC = []
        else:
            self.DAC = DAC
        self.DAC_nsprefix_ = None
        if POLICY is None:
            self.POLICY = []
        else:
            self.POLICY = POLICY
        self.POLICY_nsprefix_ = None
        if DATASET is None:
            self.DATASET = []
        else:
            self.DATASET = DATASET
        self.DATASET_nsprefix_ = None
        if PROJECT is None:
            self.PROJECT = []
        else:
            self.PROJECT = PROJECT
        self.PROJECT_nsprefix_ = None
        if CHECKLIST is None:
            self.CHECKLIST = []
        else:
            self.CHECKLIST = CHECKLIST
        self.CHECKLIST_nsprefix_ = None
        self.SUBMISSION = SUBMISSION
        self.SUBMISSION_nsprefix_ = None
        self.MESSAGES = MESSAGES
        self.MESSAGES_nsprefix_ = None
        if ACTIONS is None:
            self.ACTIONS = []
        else:
            self.ACTIONS = ACTIONS
        self.ACTIONS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RECEIPT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RECEIPT.subclass:
            return RECEIPT.subclass(*args_, **kwargs_)
        else:
            return RECEIPT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANALYSIS(self):
        return self.ANALYSIS
    def set_ANALYSIS(self, ANALYSIS):
        self.ANALYSIS = ANALYSIS
    def add_ANALYSIS(self, value):
        self.ANALYSIS.append(value)
    def insert_ANALYSIS_at(self, index, value):
        self.ANALYSIS.insert(index, value)
    def replace_ANALYSIS_at(self, index, value):
        self.ANALYSIS[index] = value
    def get_EXPERIMENT(self):
        return self.EXPERIMENT
    def set_EXPERIMENT(self, EXPERIMENT):
        self.EXPERIMENT = EXPERIMENT
    def add_EXPERIMENT(self, value):
        self.EXPERIMENT.append(value)
    def insert_EXPERIMENT_at(self, index, value):
        self.EXPERIMENT.insert(index, value)
    def replace_EXPERIMENT_at(self, index, value):
        self.EXPERIMENT[index] = value
    def get_RUN(self):
        return self.RUN
    def set_RUN(self, RUN):
        self.RUN = RUN
    def add_RUN(self, value):
        self.RUN.append(value)
    def insert_RUN_at(self, index, value):
        self.RUN.insert(index, value)
    def replace_RUN_at(self, index, value):
        self.RUN[index] = value
    def get_SAMPLE(self):
        return self.SAMPLE
    def set_SAMPLE(self, SAMPLE):
        self.SAMPLE = SAMPLE
    def add_SAMPLE(self, value):
        self.SAMPLE.append(value)
    def insert_SAMPLE_at(self, index, value):
        self.SAMPLE.insert(index, value)
    def replace_SAMPLE_at(self, index, value):
        self.SAMPLE[index] = value
    def get_SAMPLEGROUP(self):
        return self.SAMPLEGROUP
    def set_SAMPLEGROUP(self, SAMPLEGROUP):
        self.SAMPLEGROUP = SAMPLEGROUP
    def add_SAMPLEGROUP(self, value):
        self.SAMPLEGROUP.append(value)
    def insert_SAMPLEGROUP_at(self, index, value):
        self.SAMPLEGROUP.insert(index, value)
    def replace_SAMPLEGROUP_at(self, index, value):
        self.SAMPLEGROUP[index] = value
    def get_STUDY(self):
        return self.STUDY
    def set_STUDY(self, STUDY):
        self.STUDY = STUDY
    def add_STUDY(self, value):
        self.STUDY.append(value)
    def insert_STUDY_at(self, index, value):
        self.STUDY.insert(index, value)
    def replace_STUDY_at(self, index, value):
        self.STUDY[index] = value
    def get_DAC(self):
        return self.DAC
    def set_DAC(self, DAC):
        self.DAC = DAC
    def add_DAC(self, value):
        self.DAC.append(value)
    def insert_DAC_at(self, index, value):
        self.DAC.insert(index, value)
    def replace_DAC_at(self, index, value):
        self.DAC[index] = value
    def get_POLICY(self):
        return self.POLICY
    def set_POLICY(self, POLICY):
        self.POLICY = POLICY
    def add_POLICY(self, value):
        self.POLICY.append(value)
    def insert_POLICY_at(self, index, value):
        self.POLICY.insert(index, value)
    def replace_POLICY_at(self, index, value):
        self.POLICY[index] = value
    def get_DATASET(self):
        return self.DATASET
    def set_DATASET(self, DATASET):
        self.DATASET = DATASET
    def add_DATASET(self, value):
        self.DATASET.append(value)
    def insert_DATASET_at(self, index, value):
        self.DATASET.insert(index, value)
    def replace_DATASET_at(self, index, value):
        self.DATASET[index] = value
    def get_PROJECT(self):
        return self.PROJECT
    def set_PROJECT(self, PROJECT):
        self.PROJECT = PROJECT
    def add_PROJECT(self, value):
        self.PROJECT.append(value)
    def insert_PROJECT_at(self, index, value):
        self.PROJECT.insert(index, value)
    def replace_PROJECT_at(self, index, value):
        self.PROJECT[index] = value
    def get_CHECKLIST(self):
        return self.CHECKLIST
    def set_CHECKLIST(self, CHECKLIST):
        self.CHECKLIST = CHECKLIST
    def add_CHECKLIST(self, value):
        self.CHECKLIST.append(value)
    def insert_CHECKLIST_at(self, index, value):
        self.CHECKLIST.insert(index, value)
    def replace_CHECKLIST_at(self, index, value):
        self.CHECKLIST[index] = value
    def get_SUBMISSION(self):
        return self.SUBMISSION
    def set_SUBMISSION(self, SUBMISSION):
        self.SUBMISSION = SUBMISSION
    def get_MESSAGES(self):
        return self.MESSAGES
    def set_MESSAGES(self, MESSAGES):
        self.MESSAGES = MESSAGES
    def get_ACTIONS(self):
        return self.ACTIONS
    def set_ACTIONS(self, ACTIONS):
        self.ACTIONS = ACTIONS
    def add_ACTIONS(self, value):
        self.ACTIONS.append(value)
    def insert_ACTIONS_at(self, index, value):
        self.ACTIONS.insert(index, value)
    def replace_ACTIONS_at(self, index, value):
        self.ACTIONS[index] = value
    def get_success(self):
        return self.success
    def set_success(self, success):
        self.success = success
    def get_receiptDate(self):
        return self.receiptDate
    def set_receiptDate(self, receiptDate):
        self.receiptDate = receiptDate
    def get_submissionFile(self):
        return self.submissionFile
    def set_submissionFile(self, submissionFile):
        self.submissionFile = submissionFile
    def validate_ACTIONSType(self, value):
        result = True
        # Validate type ACTIONSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ADD', 'MODIFY', 'RELEASE', 'HOLD', 'VALIDATE', 'PROTECT', 'RECEIPT', 'ROLLBACK']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ACTIONSType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_submissionFileType(self, value):
        # Validate type submissionFileType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_submissionFileType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_submissionFileType_patterns_, ))
    validate_submissionFileType_patterns_ = [['^(.+\\.xml)$']]
    def _hasContent(self):
        if (
            self.ANALYSIS or
            self.EXPERIMENT or
            self.RUN or
            self.SAMPLE or
            self.SAMPLEGROUP or
            self.STUDY or
            self.DAC or
            self.POLICY or
            self.DATASET or
            self.PROJECT or
            self.CHECKLIST or
            self.SUBMISSION is not None or
            self.MESSAGES is not None or
            self.ACTIONS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RECEIPT', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RECEIPT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RECEIPT':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RECEIPT')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RECEIPT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RECEIPT'):
        if self.success is not None and 'success' not in already_processed:
            already_processed.add('success')
            outfile.write(' success="%s"' % self.gds_format_boolean(self.success, input_name='success'))
        if self.receiptDate is not None and 'receiptDate' not in already_processed:
            already_processed.add('receiptDate')
            outfile.write(' receiptDate="%s"' % self.gds_format_datetime(self.receiptDate, input_name='receiptDate'))
        if self.submissionFile is not None and 'submissionFile' not in already_processed:
            already_processed.add('submissionFile')
            outfile.write(' submissionFile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.submissionFile), input_name='submissionFile')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RECEIPT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_ in self.ANALYSIS:
            namespaceprefix_ = self.ANALYSIS_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_nsprefix_) else ''
            ANALYSIS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS', pretty_print=pretty_print)
        for EXPERIMENT_ in self.EXPERIMENT:
            namespaceprefix_ = self.EXPERIMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_nsprefix_) else ''
            EXPERIMENT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT', pretty_print=pretty_print)
        for RUN_ in self.RUN:
            namespaceprefix_ = self.RUN_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_nsprefix_) else ''
            RUN_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN', pretty_print=pretty_print)
        for SAMPLE_ in self.SAMPLE:
            namespaceprefix_ = self.SAMPLE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_nsprefix_) else ''
            SAMPLE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE', pretty_print=pretty_print)
        for SAMPLEGROUP_ in self.SAMPLEGROUP:
            namespaceprefix_ = self.SAMPLEGROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLEGROUP_nsprefix_) else ''
            SAMPLEGROUP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLEGROUP', pretty_print=pretty_print)
        for STUDY_ in self.STUDY:
            namespaceprefix_ = self.STUDY_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_nsprefix_) else ''
            STUDY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY', pretty_print=pretty_print)
        for DAC_ in self.DAC:
            namespaceprefix_ = self.DAC_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_nsprefix_) else ''
            DAC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC', pretty_print=pretty_print)
        for POLICY_ in self.POLICY:
            namespaceprefix_ = self.POLICY_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_nsprefix_) else ''
            POLICY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY', pretty_print=pretty_print)
        for DATASET_ in self.DATASET:
            namespaceprefix_ = self.DATASET_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_nsprefix_) else ''
            DATASET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET', pretty_print=pretty_print)
        for PROJECT_ in self.PROJECT:
            namespaceprefix_ = self.PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_nsprefix_) else ''
            PROJECT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT', pretty_print=pretty_print)
        for CHECKLIST_ in self.CHECKLIST:
            namespaceprefix_ = self.CHECKLIST_nsprefix_ + ':' if (UseCapturedNS_ and self.CHECKLIST_nsprefix_) else ''
            CHECKLIST_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CHECKLIST', pretty_print=pretty_print)
        if self.SUBMISSION is not None:
            namespaceprefix_ = self.SUBMISSION_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_nsprefix_) else ''
            self.SUBMISSION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION', pretty_print=pretty_print)
        if self.MESSAGES is not None:
            namespaceprefix_ = self.MESSAGES_nsprefix_ + ':' if (UseCapturedNS_ and self.MESSAGES_nsprefix_) else ''
            self.MESSAGES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MESSAGES', pretty_print=pretty_print)
        for ACTIONS_ in self.ACTIONS:
            namespaceprefix_ = self.ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIONS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sACTIONS>%s</%sACTIONS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ACTIONS_), input_name='ACTIONS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('success', node)
        if value is not None and 'success' not in already_processed:
            already_processed.add('success')
            if value in ('true', '1'):
                self.success = True
            elif value in ('false', '0'):
                self.success = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('receiptDate', node)
        if value is not None and 'receiptDate' not in already_processed:
            already_processed.add('receiptDate')
            try:
                self.receiptDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (receiptDate): %s' % exp)
        value = find_attr_value_('submissionFile', node)
        if value is not None and 'submissionFile' not in already_processed:
            already_processed.add('submissionFile')
            self.submissionFile = value
            self.validate_submissionFileType(self.submissionFile)    # validate type submissionFileType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANALYSIS':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS'
        elif nodeName_ == 'EXPERIMENT':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT'
        elif nodeName_ == 'RUN':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN.append(obj_)
            obj_.original_tagname_ = 'RUN'
        elif nodeName_ == 'SAMPLE':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE.append(obj_)
            obj_.original_tagname_ = 'SAMPLE'
        elif nodeName_ == 'SAMPLEGROUP':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLEGROUP.append(obj_)
            obj_.original_tagname_ = 'SAMPLEGROUP'
        elif nodeName_ == 'STUDY':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY.append(obj_)
            obj_.original_tagname_ = 'STUDY'
        elif nodeName_ == 'DAC':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC.append(obj_)
            obj_.original_tagname_ = 'DAC'
        elif nodeName_ == 'POLICY':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY.append(obj_)
            obj_.original_tagname_ = 'POLICY'
        elif nodeName_ == 'DATASET':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET.append(obj_)
            obj_.original_tagname_ = 'DATASET'
        elif nodeName_ == 'PROJECT':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT.append(obj_)
            obj_.original_tagname_ = 'PROJECT'
        elif nodeName_ == 'CHECKLIST':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CHECKLIST.append(obj_)
            obj_.original_tagname_ = 'CHECKLIST'
        elif nodeName_ == 'SUBMISSION':
            obj_ = ID.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION = obj_
            obj_.original_tagname_ = 'SUBMISSION'
        elif nodeName_ == 'MESSAGES':
            obj_ = MESSAGESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MESSAGES = obj_
            obj_.original_tagname_ = 'MESSAGES'
        elif nodeName_ == 'ACTIONS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ACTIONS')
            value_ = self.gds_validate_string(value_, node, 'ACTIONS')
            self.ACTIONS.append(value_)
            self.ACTIONS_nsprefix_ = child_.prefix
            # validate type ACTIONSType
            self.validate_ACTIONSType(self.ACTIONS[-1])
# end class RECEIPT


class RunType(ObjectType):
    """RunType --
    A run contains a group of reads generated for a particular experiment.

    * run_date --
      ISO date when the run took place.

    * run_center --
      If applicable, the name of the contract sequencing center that executed the run.
      Example: 454MSC.

    * TITLE --
      Short text that can be used to define submissions in searches or in displays.

    * EXPERIMENT_REF -- Identifies the parent experiment.

    * RUN_TYPE -- The type of the run.
    * RUN_LINKS --
      Links to resources related to this RUN or RUN set (publication, datasets, online databases).

    * RUN_ATTRIBUTES --
      Properties and attributes of a RUN.  These can be entered as free-form
      tag-value pairs. For certain studies, submitters may be asked to follow a
      community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, run_date=None, run_center=None, TITLE=None, EXPERIMENT_REF=None, SPOT_DESCRIPTOR=None, PLATFORM=None, PROCESSING=None, RUN_TYPE=None, DATA_BLOCK=None, RUN_LINKS=None, RUN_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RunType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        if isinstance(run_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(run_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = run_date
        self.run_date = initvalue_
        self.run_center = _cast(None, run_center)
        self.run_center_nsprefix_ = None
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.EXPERIMENT_REF = EXPERIMENT_REF
        self.EXPERIMENT_REF_nsprefix_ = None
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
        self.SPOT_DESCRIPTOR_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.PLATFORM_nsprefix_ = None
        self.PROCESSING = PROCESSING
        self.PROCESSING_nsprefix_ = None
        self.RUN_TYPE = RUN_TYPE
        self.RUN_TYPE_nsprefix_ = None
        self.DATA_BLOCK = DATA_BLOCK
        self.DATA_BLOCK_nsprefix_ = None
        self.RUN_LINKS = RUN_LINKS
        self.RUN_LINKS_nsprefix_ = None
        self.RUN_ATTRIBUTES = RUN_ATTRIBUTES
        self.RUN_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunType.subclass:
            return RunType.subclass(*args_, **kwargs_)
        else:
            return RunType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_EXPERIMENT_REF(self):
        return self.EXPERIMENT_REF
    def set_EXPERIMENT_REF(self, EXPERIMENT_REF):
        self.EXPERIMENT_REF = EXPERIMENT_REF
    def get_SPOT_DESCRIPTOR(self):
        return self.SPOT_DESCRIPTOR
    def set_SPOT_DESCRIPTOR(self, SPOT_DESCRIPTOR):
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_PROCESSING(self):
        return self.PROCESSING
    def set_PROCESSING(self, PROCESSING):
        self.PROCESSING = PROCESSING
    def get_RUN_TYPE(self):
        return self.RUN_TYPE
    def set_RUN_TYPE(self, RUN_TYPE):
        self.RUN_TYPE = RUN_TYPE
    def get_DATA_BLOCK(self):
        return self.DATA_BLOCK
    def set_DATA_BLOCK(self, DATA_BLOCK):
        self.DATA_BLOCK = DATA_BLOCK
    def get_RUN_LINKS(self):
        return self.RUN_LINKS
    def set_RUN_LINKS(self, RUN_LINKS):
        self.RUN_LINKS = RUN_LINKS
    def get_RUN_ATTRIBUTES(self):
        return self.RUN_ATTRIBUTES
    def set_RUN_ATTRIBUTES(self, RUN_ATTRIBUTES):
        self.RUN_ATTRIBUTES = RUN_ATTRIBUTES
    def get_run_date(self):
        return self.run_date
    def set_run_date(self, run_date):
        self.run_date = run_date
    def get_run_center(self):
        return self.run_center
    def set_run_center(self, run_center):
        self.run_center = run_center
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.EXPERIMENT_REF is not None or
            self.SPOT_DESCRIPTOR is not None or
            self.PLATFORM is not None or
            self.PROCESSING is not None or
            self.RUN_TYPE is not None or
            self.DATA_BLOCK is not None or
            self.RUN_LINKS is not None or
            self.RUN_ATTRIBUTES is not None or
            super(RunType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RunType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RunType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RunType'):
        super(RunType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunType')
        if self.run_date is not None and 'run_date' not in already_processed:
            already_processed.add('run_date')
            outfile.write(' run_date="%s"' % self.gds_format_datetime(self.run_date, input_name='run_date'))
        if self.run_center is not None and 'run_center' not in already_processed:
            already_processed.add('run_center')
            outfile.write(' run_center=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.run_center), input_name='run_center')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RunType', fromsubclass_=False, pretty_print=True):
        super(RunType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.EXPERIMENT_REF is not None:
            namespaceprefix_ = self.EXPERIMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_REF_nsprefix_) else ''
            self.EXPERIMENT_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_REF', pretty_print=pretty_print)
        if self.SPOT_DESCRIPTOR is not None:
            namespaceprefix_ = self.SPOT_DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.SPOT_DESCRIPTOR_nsprefix_) else ''
            self.SPOT_DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SPOT_DESCRIPTOR', pretty_print=pretty_print)
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            self.PLATFORM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PLATFORM', pretty_print=pretty_print)
        if self.PROCESSING is not None:
            namespaceprefix_ = self.PROCESSING_nsprefix_ + ':' if (UseCapturedNS_ and self.PROCESSING_nsprefix_) else ''
            self.PROCESSING.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROCESSING', pretty_print=pretty_print)
        if self.RUN_TYPE is not None:
            namespaceprefix_ = self.RUN_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_TYPE_nsprefix_) else ''
            self.RUN_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_TYPE', pretty_print=pretty_print)
        if self.DATA_BLOCK is not None:
            namespaceprefix_ = self.DATA_BLOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_BLOCK_nsprefix_) else ''
            self.DATA_BLOCK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA_BLOCK', pretty_print=pretty_print)
        if self.RUN_LINKS is not None:
            namespaceprefix_ = self.RUN_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_LINKS_nsprefix_) else ''
            self.RUN_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_LINKS', pretty_print=pretty_print)
        if self.RUN_ATTRIBUTES is not None:
            namespaceprefix_ = self.RUN_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_ATTRIBUTES_nsprefix_) else ''
            self.RUN_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('run_date', node)
        if value is not None and 'run_date' not in already_processed:
            already_processed.add('run_date')
            try:
                self.run_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (run_date): %s' % exp)
        value = find_attr_value_('run_center', node)
        if value is not None and 'run_center' not in already_processed:
            already_processed.add('run_center')
            self.run_center = value
        super(RunType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXPERIMENT_REF':
            obj_ = EXPERIMENT_REFType25.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_REF = obj_
            obj_.original_tagname_ = 'EXPERIMENT_REF'
        elif nodeName_ == 'SPOT_DESCRIPTOR':
            obj_ = SpotDescriptorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SPOT_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SPOT_DESCRIPTOR'
        elif nodeName_ == 'PLATFORM':
            obj_ = PlatformType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PLATFORM = obj_
            obj_.original_tagname_ = 'PLATFORM'
        elif nodeName_ == 'PROCESSING':
            obj_ = ProcessingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROCESSING = obj_
            obj_.original_tagname_ = 'PROCESSING'
        elif nodeName_ == 'RUN_TYPE':
            obj_ = RUN_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_TYPE = obj_
            obj_.original_tagname_ = 'RUN_TYPE'
        elif nodeName_ == 'DATA_BLOCK':
            obj_ = DATA_BLOCKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATA_BLOCK = obj_
            obj_.original_tagname_ = 'DATA_BLOCK'
        elif nodeName_ == 'RUN_LINKS':
            obj_ = RUN_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_LINKS = obj_
            obj_.original_tagname_ = 'RUN_LINKS'
        elif nodeName_ == 'RUN_ATTRIBUTES':
            obj_ = RUN_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'RUN_ATTRIBUTES'
        super(RunType, self)._buildChildren(child_, node, nodeName_, True)
# end class RunType


class RunSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RUN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RUN is None:
            self.RUN = []
        else:
            self.RUN = RUN
        self.RUN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RunSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RunSetType.subclass:
            return RunSetType.subclass(*args_, **kwargs_)
        else:
            return RunSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RUN(self):
        return self.RUN
    def set_RUN(self, RUN):
        self.RUN = RUN
    def add_RUN(self, value):
        self.RUN.append(value)
    def insert_RUN_at(self, index, value):
        self.RUN.insert(index, value)
    def replace_RUN_at(self, index, value):
        self.RUN[index] = value
    def _hasContent(self):
        if (
            self.RUN
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RunSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RunSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RunSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RunSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RunSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RunSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RunSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_ in self.RUN:
            namespaceprefix_ = self.RUN_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_nsprefix_) else ''
            RUN_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RUN':
            obj_ = RunType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN.append(obj_)
            obj_.original_tagname_ = 'RUN'
# end class RunSetType


class SampleType(ObjectType):
    """SampleType --
    A Sample defines an isolate of sequenceable material upon which
    sequencing experiments can be based.  The Sample object may be a surrogate for taxonomy
    accession or an anonymized individual identifier.  Or, it may fully specify
    provenance and isolation method of the starting material.

    * TITLE --
      Short text that can be used to call out sample records in search results or in displays.

    * DESCRIPTION --
      Free-form text describing the sample, its origin, and its method of isolation.

    * SAMPLE_LINKS --
      Links to resources related to this sample or sample set (publication, datasets, online databases).

    * SAMPLE_ATTRIBUTES --
      Properties and attributes of a sample.  These can be entered as free-form
      tag-value pairs. For certain studies, submitters may be asked to follow a
      community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, SAMPLE_NAME=None, DESCRIPTION=None, SAMPLE_LINKS=None, SAMPLE_ATTRIBUTES=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SampleType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS, extensiontype_,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.SAMPLE_NAME = SAMPLE_NAME
        self.SAMPLE_NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.SAMPLE_LINKS = SAMPLE_LINKS
        self.SAMPLE_LINKS_nsprefix_ = None
        self.SAMPLE_ATTRIBUTES = SAMPLE_ATTRIBUTES
        self.SAMPLE_ATTRIBUTES_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_SAMPLE_NAME(self):
        return self.SAMPLE_NAME
    def set_SAMPLE_NAME(self, SAMPLE_NAME):
        self.SAMPLE_NAME = SAMPLE_NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_SAMPLE_LINKS(self):
        return self.SAMPLE_LINKS
    def set_SAMPLE_LINKS(self, SAMPLE_LINKS):
        self.SAMPLE_LINKS = SAMPLE_LINKS
    def get_SAMPLE_ATTRIBUTES(self):
        return self.SAMPLE_ATTRIBUTES
    def set_SAMPLE_ATTRIBUTES(self, SAMPLE_ATTRIBUTES):
        self.SAMPLE_ATTRIBUTES = SAMPLE_ATTRIBUTES
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.SAMPLE_NAME is not None or
            self.DESCRIPTION is not None or
            self.SAMPLE_LINKS is not None or
            self.SAMPLE_ATTRIBUTES is not None or
            super(SampleType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SampleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleType'):
        super(SampleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleType', fromsubclass_=False, pretty_print=True):
        super(SampleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.SAMPLE_NAME is not None:
            namespaceprefix_ = self.SAMPLE_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_NAME_nsprefix_) else ''
            self.SAMPLE_NAME.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_NAME', pretty_print=pretty_print)
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.SAMPLE_LINKS is not None:
            namespaceprefix_ = self.SAMPLE_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_LINKS_nsprefix_) else ''
            self.SAMPLE_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_LINKS', pretty_print=pretty_print)
        if self.SAMPLE_ATTRIBUTES is not None:
            namespaceprefix_ = self.SAMPLE_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_ATTRIBUTES_nsprefix_) else ''
            self.SAMPLE_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SampleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SAMPLE_NAME':
            obj_ = SAMPLE_NAMEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_NAME = obj_
            obj_.original_tagname_ = 'SAMPLE_NAME'
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'SAMPLE_LINKS':
            obj_ = SAMPLE_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_LINKS = obj_
            obj_.original_tagname_ = 'SAMPLE_LINKS'
        elif nodeName_ == 'SAMPLE_ATTRIBUTES':
            obj_ = SAMPLE_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'SAMPLE_ATTRIBUTES'
        super(SampleType, self)._buildChildren(child_, node, nodeName_, True)
# end class SampleType


class SampleSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SAMPLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SAMPLE is None:
            self.SAMPLE = []
        else:
            self.SAMPLE = SAMPLE
        self.SAMPLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SampleSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SampleSetType.subclass:
            return SampleSetType.subclass(*args_, **kwargs_)
        else:
            return SampleSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE(self):
        return self.SAMPLE
    def set_SAMPLE(self, SAMPLE):
        self.SAMPLE = SAMPLE
    def add_SAMPLE(self, value):
        self.SAMPLE.append(value)
    def insert_SAMPLE_at(self, index, value):
        self.SAMPLE.insert(index, value)
    def replace_SAMPLE_at(self, index, value):
        self.SAMPLE[index] = value
    def _hasContent(self):
        if (
            self.SAMPLE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SampleSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SampleSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SampleSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SampleSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SampleSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SampleSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SAMPLE_ in self.SAMPLE:
            namespaceprefix_ = self.SAMPLE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_nsprefix_) else ''
            SAMPLE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE':
            class_obj_ = self.get_class_obj_(child_, SampleType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE.append(obj_)
            obj_.original_tagname_ = 'SAMPLE'
# end class SampleSetType


class StudyType(ObjectType):
    """StudyType --
    A Study is a container for a sequencing investigation that may comprise multiple experiments.
    The Study has an overall goal, but is otherwise minimally defined in the SRA.
    A Study is composed of a descriptor, zero or more experiments, and zero or more analyses.
    The submitter may decorate the Study with web links and properties.

    * STUDY_LINKS --
      Links to resources related to this study (publication, datasets, online databases).

    * STUDY_ATTRIBUTES --
      Properties and attributes of the study.  These can be entered as free-form
      tag-value pairs. For certain studies, submitters may be asked to follow a
      community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, DESCRIPTOR=None, STUDY_LINKS=None, STUDY_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("StudyType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.DESCRIPTOR = DESCRIPTOR
        self.DESCRIPTOR_nsprefix_ = None
        self.STUDY_LINKS = STUDY_LINKS
        self.STUDY_LINKS_nsprefix_ = None
        self.STUDY_ATTRIBUTES = STUDY_ATTRIBUTES
        self.STUDY_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StudyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StudyType.subclass:
            return StudyType.subclass(*args_, **kwargs_)
        else:
            return StudyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DESCRIPTOR(self):
        return self.DESCRIPTOR
    def set_DESCRIPTOR(self, DESCRIPTOR):
        self.DESCRIPTOR = DESCRIPTOR
    def get_STUDY_LINKS(self):
        return self.STUDY_LINKS
    def set_STUDY_LINKS(self, STUDY_LINKS):
        self.STUDY_LINKS = STUDY_LINKS
    def get_STUDY_ATTRIBUTES(self):
        return self.STUDY_ATTRIBUTES
    def set_STUDY_ATTRIBUTES(self, STUDY_ATTRIBUTES):
        self.STUDY_ATTRIBUTES = STUDY_ATTRIBUTES
    def _hasContent(self):
        if (
            self.DESCRIPTOR is not None or
            self.STUDY_LINKS is not None or
            self.STUDY_ATTRIBUTES is not None or
            super(StudyType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StudyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StudyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StudyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StudyType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StudyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StudyType'):
        super(StudyType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StudyType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StudyType', fromsubclass_=False, pretty_print=True):
        super(StudyType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTOR is not None:
            namespaceprefix_ = self.DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTOR_nsprefix_) else ''
            self.DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DESCRIPTOR', pretty_print=pretty_print)
        if self.STUDY_LINKS is not None:
            namespaceprefix_ = self.STUDY_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_LINKS_nsprefix_) else ''
            self.STUDY_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_LINKS', pretty_print=pretty_print)
        if self.STUDY_ATTRIBUTES is not None:
            namespaceprefix_ = self.STUDY_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_ATTRIBUTES_nsprefix_) else ''
            self.STUDY_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(StudyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DESCRIPTOR':
            obj_ = DESCRIPTORType30.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DESCRIPTOR = obj_
            obj_.original_tagname_ = 'DESCRIPTOR'
        elif nodeName_ == 'STUDY_LINKS':
            obj_ = STUDY_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_LINKS = obj_
            obj_.original_tagname_ = 'STUDY_LINKS'
        elif nodeName_ == 'STUDY_ATTRIBUTES':
            obj_ = STUDY_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'STUDY_ATTRIBUTES'
        super(StudyType, self)._buildChildren(child_, node, nodeName_, True)
# end class StudyType


class StudySetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, STUDY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if STUDY is None:
            self.STUDY = []
        else:
            self.STUDY = STUDY
        self.STUDY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StudySetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StudySetType.subclass:
            return StudySetType.subclass(*args_, **kwargs_)
        else:
            return StudySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STUDY(self):
        return self.STUDY
    def set_STUDY(self, STUDY):
        self.STUDY = STUDY
    def add_STUDY(self, value):
        self.STUDY.append(value)
    def insert_STUDY_at(self, index, value):
        self.STUDY.insert(index, value)
    def replace_STUDY_at(self, index, value):
        self.STUDY[index] = value
    def _hasContent(self):
        if (
            self.STUDY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StudySetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StudySetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StudySetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StudySetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StudySetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StudySetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='StudySetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for STUDY_ in self.STUDY:
            namespaceprefix_ = self.STUDY_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_nsprefix_) else ''
            STUDY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STUDY':
            obj_ = StudyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY.append(obj_)
            obj_.original_tagname_ = 'STUDY'
# end class StudySetType


class SubmissionType(ObjectType):
    """SubmissionType --
    A Submission type is used to describe an object that contains submission actions to be performed by the archive.

    * submission_date --
      Submitter assigned preparation date of this submission object.

    * submission_comment --
      Submitter assigned comment.

    * lab_name --
      Laboratory name within submitting institution.

    * TITLE --
      Short text that can be used to define submissions in searches or in displays.

    * SUBMISSION_LINKS --
      Archive created links to associated submissions.

    * SUBMISSION_ATTRIBUTES --
      Archive assigned properties and attributes of a SUBMISSION.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, submission_date=None, submission_comment=None, lab_name=None, TITLE=None, CONTACTS=None, ACTIONS=None, SUBMISSION_LINKS=None, SUBMISSION_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubmissionType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        if isinstance(submission_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(submission_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = submission_date
        self.submission_date = initvalue_
        self.submission_comment = _cast(None, submission_comment)
        self.submission_comment_nsprefix_ = None
        self.lab_name = _cast(None, lab_name)
        self.lab_name_nsprefix_ = None
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.CONTACTS = CONTACTS
        self.CONTACTS_nsprefix_ = None
        self.ACTIONS = ACTIONS
        self.ACTIONS_nsprefix_ = None
        self.SUBMISSION_LINKS = SUBMISSION_LINKS
        self.SUBMISSION_LINKS_nsprefix_ = None
        self.SUBMISSION_ATTRIBUTES = SUBMISSION_ATTRIBUTES
        self.SUBMISSION_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubmissionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubmissionType.subclass:
            return SubmissionType.subclass(*args_, **kwargs_)
        else:
            return SubmissionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_CONTACTS(self):
        return self.CONTACTS
    def set_CONTACTS(self, CONTACTS):
        self.CONTACTS = CONTACTS
    def get_ACTIONS(self):
        return self.ACTIONS
    def set_ACTIONS(self, ACTIONS):
        self.ACTIONS = ACTIONS
    def get_SUBMISSION_LINKS(self):
        return self.SUBMISSION_LINKS
    def set_SUBMISSION_LINKS(self, SUBMISSION_LINKS):
        self.SUBMISSION_LINKS = SUBMISSION_LINKS
    def get_SUBMISSION_ATTRIBUTES(self):
        return self.SUBMISSION_ATTRIBUTES
    def set_SUBMISSION_ATTRIBUTES(self, SUBMISSION_ATTRIBUTES):
        self.SUBMISSION_ATTRIBUTES = SUBMISSION_ATTRIBUTES
    def get_submission_date(self):
        return self.submission_date
    def set_submission_date(self, submission_date):
        self.submission_date = submission_date
    def get_submission_comment(self):
        return self.submission_comment
    def set_submission_comment(self, submission_comment):
        self.submission_comment = submission_comment
    def get_lab_name(self):
        return self.lab_name
    def set_lab_name(self, lab_name):
        self.lab_name = lab_name
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.CONTACTS is not None or
            self.ACTIONS is not None or
            self.SUBMISSION_LINKS is not None or
            self.SUBMISSION_ATTRIBUTES is not None or
            super(SubmissionType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubmissionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubmissionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmissionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubmissionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubmissionType'):
        super(SubmissionType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmissionType')
        if self.submission_date is not None and 'submission_date' not in already_processed:
            already_processed.add('submission_date')
            outfile.write(' submission_date="%s"' % self.gds_format_datetime(self.submission_date, input_name='submission_date'))
        if self.submission_comment is not None and 'submission_comment' not in already_processed:
            already_processed.add('submission_comment')
            outfile.write(' submission_comment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.submission_comment), input_name='submission_comment')), ))
        if self.lab_name is not None and 'lab_name' not in already_processed:
            already_processed.add('lab_name')
            outfile.write(' lab_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lab_name), input_name='lab_name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionType', fromsubclass_=False, pretty_print=True):
        super(SubmissionType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.CONTACTS is not None:
            namespaceprefix_ = self.CONTACTS_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTACTS_nsprefix_) else ''
            self.CONTACTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONTACTS', pretty_print=pretty_print)
        if self.ACTIONS is not None:
            namespaceprefix_ = self.ACTIONS_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTIONS_nsprefix_) else ''
            self.ACTIONS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ACTIONS', pretty_print=pretty_print)
        if self.SUBMISSION_LINKS is not None:
            namespaceprefix_ = self.SUBMISSION_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_LINKS_nsprefix_) else ''
            self.SUBMISSION_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION_LINKS', pretty_print=pretty_print)
        if self.SUBMISSION_ATTRIBUTES is not None:
            namespaceprefix_ = self.SUBMISSION_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_ATTRIBUTES_nsprefix_) else ''
            self.SUBMISSION_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('submission_date', node)
        if value is not None and 'submission_date' not in already_processed:
            already_processed.add('submission_date')
            try:
                self.submission_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (submission_date): %s' % exp)
        value = find_attr_value_('submission_comment', node)
        if value is not None and 'submission_comment' not in already_processed:
            already_processed.add('submission_comment')
            self.submission_comment = value
        value = find_attr_value_('lab_name', node)
        if value is not None and 'lab_name' not in already_processed:
            already_processed.add('lab_name')
            self.lab_name = value
        super(SubmissionType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTACTS':
            obj_ = CONTACTSType31.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CONTACTS = obj_
            obj_.original_tagname_ = 'CONTACTS'
        elif nodeName_ == 'ACTIONS':
            obj_ = ACTIONSType33.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ACTIONS = obj_
            obj_.original_tagname_ = 'ACTIONS'
        elif nodeName_ == 'SUBMISSION_LINKS':
            obj_ = SUBMISSION_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION_LINKS = obj_
            obj_.original_tagname_ = 'SUBMISSION_LINKS'
        elif nodeName_ == 'SUBMISSION_ATTRIBUTES':
            obj_ = SUBMISSION_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'SUBMISSION_ATTRIBUTES'
        super(SubmissionType, self)._buildChildren(child_, node, nodeName_, True)
# end class SubmissionType


class SubmissionSetType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SUBMISSION is None:
            self.SUBMISSION = []
        else:
            self.SUBMISSION = SUBMISSION
        self.SUBMISSION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubmissionSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubmissionSetType.subclass:
            return SubmissionSetType.subclass(*args_, **kwargs_)
        else:
            return SubmissionSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SUBMISSION(self):
        return self.SUBMISSION
    def set_SUBMISSION(self, SUBMISSION):
        self.SUBMISSION = SUBMISSION
    def add_SUBMISSION(self, value):
        self.SUBMISSION.append(value)
    def insert_SUBMISSION_at(self, index, value):
        self.SUBMISSION.insert(index, value)
    def replace_SUBMISSION_at(self, index, value):
        self.SUBMISSION[index] = value
    def _hasContent(self):
        if (
            self.SUBMISSION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubmissionSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubmissionSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubmissionSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubmissionSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubmissionSetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubmissionSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_ in self.SUBMISSION:
            namespaceprefix_ = self.SUBMISSION_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_nsprefix_) else ''
            SUBMISSION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SUBMISSION':
            obj_ = SubmissionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION'
# end class SubmissionSetType


class STUDY_REFType(RefObjectType):
    """STUDY_REFType -- Identifies the parent study.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("STUDY_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_REFType.subclass:
            return STUDY_REFType.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(STUDY_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_REFType'):
        super(STUDY_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType', fromsubclass_=False, pretty_print=True):
        super(STUDY_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(STUDY_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(STUDY_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class STUDY_REFType


class IMAGE_REFType(RefObjectType):
    """IMAGE_REFType -- One or more images associated with the annotation.
    label -- A label associating the image with image references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IMAGE_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_REFType.subclass:
            return IMAGE_REFType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(IMAGE_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_REFType'):
        super(IMAGE_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType', fromsubclass_=False, pretty_print=True):
        super(IMAGE_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(IMAGE_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IMAGE_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IMAGE_REFType


class ANNOTATION_REFType(RefObjectType):
    """ANNOTATION_REFType -- One or more annotations associated with the annotation.
    label -- A label associating the analysis with analysis references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANNOTATION_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_REFType.subclass:
            return ANNOTATION_REFType.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(ANNOTATION_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_REFType'):
        super(ANNOTATION_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_REFType')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_REFType', fromsubclass_=False, pretty_print=True):
        super(ANNOTATION_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(ANNOTATION_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ANNOTATION_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ANNOTATION_REFType


class ANNOTATION_TYPEType(GeneratedsSuper):
    """ANNOTATION_TYPEType -- The type of the annotation.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, GRAPHICAL_ANNOTATION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.GRAPHICAL_ANNOTATION = GRAPHICAL_ANNOTATION
        self.GRAPHICAL_ANNOTATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_TYPEType.subclass:
            return ANNOTATION_TYPEType.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_GRAPHICAL_ANNOTATION(self):
        return self.GRAPHICAL_ANNOTATION
    def set_GRAPHICAL_ANNOTATION(self, GRAPHICAL_ANNOTATION):
        self.GRAPHICAL_ANNOTATION = GRAPHICAL_ANNOTATION
    def _hasContent(self):
        if (
            self.GRAPHICAL_ANNOTATION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GRAPHICAL_ANNOTATION is not None:
            namespaceprefix_ = self.GRAPHICAL_ANNOTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.GRAPHICAL_ANNOTATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGRAPHICAL_ANNOTATION>%s</%sGRAPHICAL_ANNOTATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GRAPHICAL_ANNOTATION), input_name='GRAPHICAL_ANNOTATION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'GRAPHICAL_ANNOTATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GRAPHICAL_ANNOTATION')
            value_ = self.gds_validate_string(value_, node, 'GRAPHICAL_ANNOTATION')
            self.GRAPHICAL_ANNOTATION = value_
            self.GRAPHICAL_ANNOTATION_nsprefix_ = child_.prefix
# end class ANNOTATION_TYPEType


class GRAPHICAL_ANNOTATION(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GRAPHICAL_ANNOTATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GRAPHICAL_ANNOTATION.subclass:
            return GRAPHICAL_ANNOTATION.subclass(*args_, **kwargs_)
        else:
            return GRAPHICAL_ANNOTATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GRAPHICAL_ANNOTATION', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GRAPHICAL_ANNOTATION')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GRAPHICAL_ANNOTATION':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GRAPHICAL_ANNOTATION')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GRAPHICAL_ANNOTATION', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GRAPHICAL_ANNOTATION'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GRAPHICAL_ANNOTATION', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GRAPHICAL_ANNOTATION


class FILESType(GeneratedsSuper):
    """FILESType -- Files associated with the image.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FILE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE
        self.FILE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILESType.subclass:
            return FILESType.subclass(*args_, **kwargs_)
        else:
            return FILESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FILE(self):
        return self.FILE
    def set_FILE(self, FILE):
        self.FILE = FILE
    def add_FILE(self, value):
        self.FILE.append(value)
    def insert_FILE_at(self, index, value):
        self.FILE.insert(index, value)
    def replace_FILE_at(self, index, value):
        self.FILE[index] = value
    def _hasContent(self):
        if (
            self.FILE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FILESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            namespaceprefix_ = self.FILE_nsprefix_ + ':' if (UseCapturedNS_ and self.FILE_nsprefix_) else ''
            FILE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FILE':
            obj_ = AnnotationFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'
# end class FILESType


class ANNOTATION_LINKSType(GeneratedsSuper):
    """ANNOTATION_LINKSType --  Links to resources related to this annotation.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANNOTATION_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANNOTATION_LINK is None:
            self.ANNOTATION_LINK = []
        else:
            self.ANNOTATION_LINK = ANNOTATION_LINK
        self.ANNOTATION_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_LINKSType.subclass:
            return ANNOTATION_LINKSType.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANNOTATION_LINK(self):
        return self.ANNOTATION_LINK
    def set_ANNOTATION_LINK(self, ANNOTATION_LINK):
        self.ANNOTATION_LINK = ANNOTATION_LINK
    def add_ANNOTATION_LINK(self, value):
        self.ANNOTATION_LINK.append(value)
    def insert_ANNOTATION_LINK_at(self, index, value):
        self.ANNOTATION_LINK.insert(index, value)
    def replace_ANNOTATION_LINK_at(self, index, value):
        self.ANNOTATION_LINK[index] = value
    def _hasContent(self):
        if (
            self.ANNOTATION_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANNOTATION_LINK_ in self.ANNOTATION_LINK:
            namespaceprefix_ = self.ANNOTATION_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_LINK_nsprefix_) else ''
            ANNOTATION_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANNOTATION_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_LINK.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION_LINK'
# end class ANNOTATION_LINKSType


class ANNOTATION_ATTRIBUTESType(GeneratedsSuper):
    """ANNOTATION_ATTRIBUTESType -- Properties and attributes of an annotation. These can be entered as free-form tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANNOTATION_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANNOTATION_ATTRIBUTE is None:
            self.ANNOTATION_ATTRIBUTE = []
        else:
            self.ANNOTATION_ATTRIBUTE = ANNOTATION_ATTRIBUTE
        self.ANNOTATION_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_ATTRIBUTESType.subclass:
            return ANNOTATION_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANNOTATION_ATTRIBUTE(self):
        return self.ANNOTATION_ATTRIBUTE
    def set_ANNOTATION_ATTRIBUTE(self, ANNOTATION_ATTRIBUTE):
        self.ANNOTATION_ATTRIBUTE = ANNOTATION_ATTRIBUTE
    def add_ANNOTATION_ATTRIBUTE(self, value):
        self.ANNOTATION_ATTRIBUTE.append(value)
    def insert_ANNOTATION_ATTRIBUTE_at(self, index, value):
        self.ANNOTATION_ATTRIBUTE.insert(index, value)
    def replace_ANNOTATION_ATTRIBUTE_at(self, index, value):
        self.ANNOTATION_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.ANNOTATION_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANNOTATION_ATTRIBUTE_ in self.ANNOTATION_ATTRIBUTE:
            namespaceprefix_ = self.ANNOTATION_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_ATTRIBUTE_nsprefix_) else ''
            ANNOTATION_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANNOTATION_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION_ATTRIBUTE'
# end class ANNOTATION_ATTRIBUTESType


class ANNOTATION_CODED_ATTRIBUTESType(GeneratedsSuper):
    """ANNOTATION_CODED_ATTRIBUTESType -- Coded properties and attributes of an analysis. These can be entered as tag-coded value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANNOTATION_CODED_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANNOTATION_CODED_ATTRIBUTE is None:
            self.ANNOTATION_CODED_ATTRIBUTE = []
        else:
            self.ANNOTATION_CODED_ATTRIBUTE = ANNOTATION_CODED_ATTRIBUTE
        self.ANNOTATION_CODED_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_CODED_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_CODED_ATTRIBUTESType.subclass:
            return ANNOTATION_CODED_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_CODED_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANNOTATION_CODED_ATTRIBUTE(self):
        return self.ANNOTATION_CODED_ATTRIBUTE
    def set_ANNOTATION_CODED_ATTRIBUTE(self, ANNOTATION_CODED_ATTRIBUTE):
        self.ANNOTATION_CODED_ATTRIBUTE = ANNOTATION_CODED_ATTRIBUTE
    def add_ANNOTATION_CODED_ATTRIBUTE(self, value):
        self.ANNOTATION_CODED_ATTRIBUTE.append(value)
    def insert_ANNOTATION_CODED_ATTRIBUTE_at(self, index, value):
        self.ANNOTATION_CODED_ATTRIBUTE.insert(index, value)
    def replace_ANNOTATION_CODED_ATTRIBUTE_at(self, index, value):
        self.ANNOTATION_CODED_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.ANNOTATION_CODED_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_CODED_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_CODED_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_CODED_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_CODED_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_CODED_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_CODED_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_CODED_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANNOTATION_CODED_ATTRIBUTE_ in self.ANNOTATION_CODED_ATTRIBUTE:
            namespaceprefix_ = self.ANNOTATION_CODED_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_CODED_ATTRIBUTE_nsprefix_) else ''
            ANNOTATION_CODED_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_CODED_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANNOTATION_CODED_ATTRIBUTE':
            obj_ = CodedAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_CODED_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION_CODED_ATTRIBUTE'
# end class ANNOTATION_CODED_ATTRIBUTESType


class IMAGE_REFType1(RefObjectType):
    """IMAGE_REFType1 --
    Identifies the images which are part of this dataset.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IMAGE_REFType1"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_REFType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_REFType1.subclass:
            return IMAGE_REFType1.subclass(*args_, **kwargs_)
        else:
            return IMAGE_REFType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(IMAGE_REFType1, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_REFType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_REFType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType1')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_REFType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_REFType1'):
        super(IMAGE_REFType1, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType1')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType1', fromsubclass_=False, pretty_print=True):
        super(IMAGE_REFType1, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IMAGE_REFType1, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IMAGE_REFType1, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IMAGE_REFType1


class ANNOTATION_REFType2(RefObjectType):
    """ANNOTATION_REFType2 --
    Identifies the annotations which are part of this dataset.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANNOTATION_REFType2"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANNOTATION_REFType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANNOTATION_REFType2.subclass:
            return ANNOTATION_REFType2.subclass(*args_, **kwargs_)
        else:
            return ANNOTATION_REFType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ANNOTATION_REFType2, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_REFType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANNOTATION_REFType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANNOTATION_REFType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_REFType2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANNOTATION_REFType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANNOTATION_REFType2'):
        super(ANNOTATION_REFType2, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANNOTATION_REFType2')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANNOTATION_REFType2', fromsubclass_=False, pretty_print=True):
        super(ANNOTATION_REFType2, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ANNOTATION_REFType2, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ANNOTATION_REFType2, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ANNOTATION_REFType2


class DATASET_CODED_ATTRIBUTESType(GeneratedsSuper):
    """DATASET_CODED_ATTRIBUTESType -- Coded properties and attributes of the data set. These can be entered as tag-code value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASET_CODED_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASET_CODED_ATTRIBUTE is None:
            self.DATASET_CODED_ATTRIBUTE = []
        else:
            self.DATASET_CODED_ATTRIBUTE = DATASET_CODED_ATTRIBUTE
        self.DATASET_CODED_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASET_CODED_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASET_CODED_ATTRIBUTESType.subclass:
            return DATASET_CODED_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return DATASET_CODED_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASET_CODED_ATTRIBUTE(self):
        return self.DATASET_CODED_ATTRIBUTE
    def set_DATASET_CODED_ATTRIBUTE(self, DATASET_CODED_ATTRIBUTE):
        self.DATASET_CODED_ATTRIBUTE = DATASET_CODED_ATTRIBUTE
    def add_DATASET_CODED_ATTRIBUTE(self, value):
        self.DATASET_CODED_ATTRIBUTE.append(value)
    def insert_DATASET_CODED_ATTRIBUTE_at(self, index, value):
        self.DATASET_CODED_ATTRIBUTE.insert(index, value)
    def replace_DATASET_CODED_ATTRIBUTE_at(self, index, value):
        self.DATASET_CODED_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.DATASET_CODED_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_CODED_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASET_CODED_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASET_CODED_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASET_CODED_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASET_CODED_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASET_CODED_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_CODED_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASET_CODED_ATTRIBUTE_ in self.DATASET_CODED_ATTRIBUTE:
            namespaceprefix_ = self.DATASET_CODED_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_CODED_ATTRIBUTE_nsprefix_) else ''
            DATASET_CODED_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_CODED_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASET_CODED_ATTRIBUTE':
            obj_ = CodedAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_CODED_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'DATASET_CODED_ATTRIBUTE'
# end class DATASET_CODED_ATTRIBUTESType


class STUDY_REFType5(RefObjectType):
    """STUDY_REFType5 -- Identifies the parent study.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("STUDY_REFType5"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_REFType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_REFType5.subclass:
            return STUDY_REFType5.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(STUDY_REFType5, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_REFType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_REFType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType5')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_REFType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_REFType5'):
        super(STUDY_REFType5, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType5')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType5', fromsubclass_=False, pretty_print=True):
        super(STUDY_REFType5, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(STUDY_REFType5, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(STUDY_REFType5, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class STUDY_REFType5


class SAMPLE_REFType(RefObjectType):
    """SAMPLE_REFType -- One of more samples associated with the
    image.
    label -- A label associating the sample with sample references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SAMPLE_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_REFType.subclass:
            return SAMPLE_REFType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(SAMPLE_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_REFType'):
        super(SAMPLE_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType', fromsubclass_=False, pretty_print=True):
        super(SAMPLE_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(SAMPLE_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SAMPLE_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SAMPLE_REFType


class IMAGE_REFType6(RefObjectType):
    """IMAGE_REFType6 -- One or more images associated with the
    image.
    label -- A label associating the image with image references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IMAGE_REFType6"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_REFType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_REFType6.subclass:
            return IMAGE_REFType6.subclass(*args_, **kwargs_)
        else:
            return IMAGE_REFType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(IMAGE_REFType6, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_REFType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_REFType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType6')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_REFType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_REFType6'):
        super(IMAGE_REFType6, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_REFType6')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_REFType6', fromsubclass_=False, pretty_print=True):
        super(IMAGE_REFType6, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(IMAGE_REFType6, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IMAGE_REFType6, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IMAGE_REFType6


class IMAGE_TYPEType(GeneratedsSuper):
    """IMAGE_TYPEType -- The type of the image.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, WSI_IMAGE=None, GROSS_IMAGE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.WSI_IMAGE = WSI_IMAGE
        self.WSI_IMAGE_nsprefix_ = None
        self.GROSS_IMAGE = GROSS_IMAGE
        self.GROSS_IMAGE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_TYPEType.subclass:
            return IMAGE_TYPEType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_WSI_IMAGE(self):
        return self.WSI_IMAGE
    def set_WSI_IMAGE(self, WSI_IMAGE):
        self.WSI_IMAGE = WSI_IMAGE
    def get_GROSS_IMAGE(self):
        return self.GROSS_IMAGE
    def set_GROSS_IMAGE(self, GROSS_IMAGE):
        self.GROSS_IMAGE = GROSS_IMAGE
    def _hasContent(self):
        if (
            self.WSI_IMAGE is not None or
            self.GROSS_IMAGE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WSI_IMAGE is not None:
            namespaceprefix_ = self.WSI_IMAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.WSI_IMAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWSI_IMAGE>%s</%sWSI_IMAGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.WSI_IMAGE), input_name='WSI_IMAGE')), namespaceprefix_ , eol_))
        if self.GROSS_IMAGE is not None:
            namespaceprefix_ = self.GROSS_IMAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.GROSS_IMAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGROSS_IMAGE>%s</%sGROSS_IMAGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GROSS_IMAGE), input_name='GROSS_IMAGE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'WSI_IMAGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'WSI_IMAGE')
            value_ = self.gds_validate_string(value_, node, 'WSI_IMAGE')
            self.WSI_IMAGE = value_
            self.WSI_IMAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'GROSS_IMAGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GROSS_IMAGE')
            value_ = self.gds_validate_string(value_, node, 'GROSS_IMAGE')
            self.GROSS_IMAGE = value_
            self.GROSS_IMAGE_nsprefix_ = child_.prefix
# end class IMAGE_TYPEType


class WSI_IMAGE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WSI_IMAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WSI_IMAGE.subclass:
            return WSI_IMAGE.subclass(*args_, **kwargs_)
        else:
            return WSI_IMAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WSI_IMAGE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WSI_IMAGE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'WSI_IMAGE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WSI_IMAGE')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WSI_IMAGE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WSI_IMAGE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WSI_IMAGE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class WSI_IMAGE


class GROSS_IMAGE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GROSS_IMAGE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GROSS_IMAGE.subclass:
            return GROSS_IMAGE.subclass(*args_, **kwargs_)
        else:
            return GROSS_IMAGE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GROSS_IMAGE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GROSS_IMAGE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GROSS_IMAGE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GROSS_IMAGE')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GROSS_IMAGE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GROSS_IMAGE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GROSS_IMAGE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class GROSS_IMAGE


class FILESType7(GeneratedsSuper):
    """FILESType7 -- Files associated with the
    image.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FILE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE
        self.FILE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILESType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILESType7.subclass:
            return FILESType7.subclass(*args_, **kwargs_)
        else:
            return FILESType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FILE(self):
        return self.FILE
    def set_FILE(self, FILE):
        self.FILE = FILE
    def add_FILE(self, value):
        self.FILE.append(value)
    def insert_FILE_at(self, index, value):
        self.FILE.insert(index, value)
    def replace_FILE_at(self, index, value):
        self.FILE[index] = value
    def _hasContent(self):
        if (
            self.FILE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILESType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FILESType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILESType7')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILESType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILESType7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            namespaceprefix_ = self.FILE_nsprefix_ + ':' if (UseCapturedNS_ and self.FILE_nsprefix_) else ''
            FILE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FILE':
            obj_ = ImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'
# end class FILESType7


class IMAGE_LINKSType(GeneratedsSuper):
    """IMAGE_LINKSType --  Links to resources related to this image.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE_LINK is None:
            self.IMAGE_LINK = []
        else:
            self.IMAGE_LINK = IMAGE_LINK
        self.IMAGE_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_LINKSType.subclass:
            return IMAGE_LINKSType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE_LINK(self):
        return self.IMAGE_LINK
    def set_IMAGE_LINK(self, IMAGE_LINK):
        self.IMAGE_LINK = IMAGE_LINK
    def add_IMAGE_LINK(self, value):
        self.IMAGE_LINK.append(value)
    def insert_IMAGE_LINK_at(self, index, value):
        self.IMAGE_LINK.insert(index, value)
    def replace_IMAGE_LINK_at(self, index, value):
        self.IMAGE_LINK[index] = value
    def _hasContent(self):
        if (
            self.IMAGE_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_LINK_ in self.IMAGE_LINK:
            namespaceprefix_ = self.IMAGE_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_LINK_nsprefix_) else ''
            IMAGE_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_LINK.append(obj_)
            obj_.original_tagname_ = 'IMAGE_LINK'
# end class IMAGE_LINKSType


class IMAGE_ATTRIBUTESType(GeneratedsSuper):
    """IMAGE_ATTRIBUTESType -- Properties and attributes of an image. These can be
    entered as free-form tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE_ATTRIBUTE is None:
            self.IMAGE_ATTRIBUTE = []
        else:
            self.IMAGE_ATTRIBUTE = IMAGE_ATTRIBUTE
        self.IMAGE_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_ATTRIBUTESType.subclass:
            return IMAGE_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE_ATTRIBUTE(self):
        return self.IMAGE_ATTRIBUTE
    def set_IMAGE_ATTRIBUTE(self, IMAGE_ATTRIBUTE):
        self.IMAGE_ATTRIBUTE = IMAGE_ATTRIBUTE
    def add_IMAGE_ATTRIBUTE(self, value):
        self.IMAGE_ATTRIBUTE.append(value)
    def insert_IMAGE_ATTRIBUTE_at(self, index, value):
        self.IMAGE_ATTRIBUTE.insert(index, value)
    def replace_IMAGE_ATTRIBUTE_at(self, index, value):
        self.IMAGE_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.IMAGE_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_ATTRIBUTE_ in self.IMAGE_ATTRIBUTE:
            namespaceprefix_ = self.IMAGE_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_ATTRIBUTE_nsprefix_) else ''
            IMAGE_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'IMAGE_ATTRIBUTE'
# end class IMAGE_ATTRIBUTESType


class IMAGE_CODED_ATTRIBUTESType(GeneratedsSuper):
    """IMAGE_CODED_ATTRIBUTESType -- Coded properties and attributes of an image. These can be
    entered as tag-coded value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, IMAGE_CODED_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if IMAGE_CODED_ATTRIBUTE is None:
            self.IMAGE_CODED_ATTRIBUTE = []
        else:
            self.IMAGE_CODED_ATTRIBUTE = IMAGE_CODED_ATTRIBUTE
        self.IMAGE_CODED_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IMAGE_CODED_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IMAGE_CODED_ATTRIBUTESType.subclass:
            return IMAGE_CODED_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return IMAGE_CODED_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IMAGE_CODED_ATTRIBUTE(self):
        return self.IMAGE_CODED_ATTRIBUTE
    def set_IMAGE_CODED_ATTRIBUTE(self, IMAGE_CODED_ATTRIBUTE):
        self.IMAGE_CODED_ATTRIBUTE = IMAGE_CODED_ATTRIBUTE
    def add_IMAGE_CODED_ATTRIBUTE(self, value):
        self.IMAGE_CODED_ATTRIBUTE.append(value)
    def insert_IMAGE_CODED_ATTRIBUTE_at(self, index, value):
        self.IMAGE_CODED_ATTRIBUTE.insert(index, value)
    def replace_IMAGE_CODED_ATTRIBUTE_at(self, index, value):
        self.IMAGE_CODED_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.IMAGE_CODED_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_CODED_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IMAGE_CODED_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IMAGE_CODED_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IMAGE_CODED_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IMAGE_CODED_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IMAGE_CODED_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IMAGE_CODED_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IMAGE_CODED_ATTRIBUTE_ in self.IMAGE_CODED_ATTRIBUTE:
            namespaceprefix_ = self.IMAGE_CODED_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_CODED_ATTRIBUTE_nsprefix_) else ''
            IMAGE_CODED_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_CODED_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IMAGE_CODED_ATTRIBUTE':
            obj_ = CodedAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_CODED_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'IMAGE_CODED_ATTRIBUTE'
# end class IMAGE_CODED_ATTRIBUTESType


class SAMPLE_TYPEType(GeneratedsSuper):
    """SAMPLE_TYPEType -- The type of the sample.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, BIOLOGICAL_BEING=None, SPECIMEN=None, SAMPLE=None, BLOCK=None, SLIDE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.BIOLOGICAL_BEING = BIOLOGICAL_BEING
        self.BIOLOGICAL_BEING_nsprefix_ = None
        self.SPECIMEN = SPECIMEN
        self.SPECIMEN_nsprefix_ = None
        self.SAMPLE = SAMPLE
        self.SAMPLE_nsprefix_ = None
        self.BLOCK = BLOCK
        self.BLOCK_nsprefix_ = None
        self.SLIDE = SLIDE
        self.SLIDE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_TYPEType.subclass:
            return SAMPLE_TYPEType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BIOLOGICAL_BEING(self):
        return self.BIOLOGICAL_BEING
    def set_BIOLOGICAL_BEING(self, BIOLOGICAL_BEING):
        self.BIOLOGICAL_BEING = BIOLOGICAL_BEING
    def get_SPECIMEN(self):
        return self.SPECIMEN
    def set_SPECIMEN(self, SPECIMEN):
        self.SPECIMEN = SPECIMEN
    def get_SAMPLE(self):
        return self.SAMPLE
    def set_SAMPLE(self, SAMPLE):
        self.SAMPLE = SAMPLE
    def get_BLOCK(self):
        return self.BLOCK
    def set_BLOCK(self, BLOCK):
        self.BLOCK = BLOCK
    def get_SLIDE(self):
        return self.SLIDE
    def set_SLIDE(self, SLIDE):
        self.SLIDE = SLIDE
    def _hasContent(self):
        if (
            self.BIOLOGICAL_BEING is not None or
            self.SPECIMEN is not None or
            self.SAMPLE is not None or
            self.BLOCK is not None or
            self.SLIDE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BIOLOGICAL_BEING is not None:
            namespaceprefix_ = self.BIOLOGICAL_BEING_nsprefix_ + ':' if (UseCapturedNS_ and self.BIOLOGICAL_BEING_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBIOLOGICAL_BEING>%s</%sBIOLOGICAL_BEING>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BIOLOGICAL_BEING), input_name='BIOLOGICAL_BEING')), namespaceprefix_ , eol_))
        if self.SPECIMEN is not None:
            namespaceprefix_ = self.SPECIMEN_nsprefix_ + ':' if (UseCapturedNS_ and self.SPECIMEN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPECIMEN>%s</%sSPECIMEN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SPECIMEN), input_name='SPECIMEN')), namespaceprefix_ , eol_))
        if self.SAMPLE is not None:
            namespaceprefix_ = self.SAMPLE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_nsprefix_) else ''
            self.SAMPLE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE', pretty_print=pretty_print)
        if self.BLOCK is not None:
            namespaceprefix_ = self.BLOCK_nsprefix_ + ':' if (UseCapturedNS_ and self.BLOCK_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBLOCK>%s</%sBLOCK>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.BLOCK), input_name='BLOCK')), namespaceprefix_ , eol_))
        if self.SLIDE is not None:
            namespaceprefix_ = self.SLIDE_nsprefix_ + ':' if (UseCapturedNS_ and self.SLIDE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSLIDE>%s</%sSLIDE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SLIDE), input_name='SLIDE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BIOLOGICAL_BEING':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BIOLOGICAL_BEING')
            value_ = self.gds_validate_string(value_, node, 'BIOLOGICAL_BEING')
            self.BIOLOGICAL_BEING = value_
            self.BIOLOGICAL_BEING_nsprefix_ = child_.prefix
        elif nodeName_ == 'SPECIMEN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SPECIMEN')
            value_ = self.gds_validate_string(value_, node, 'SPECIMEN')
            self.SPECIMEN = value_
            self.SPECIMEN_nsprefix_ = child_.prefix
        elif nodeName_ == 'SAMPLE':
            class_obj_ = self.get_class_obj_(child_, SampleType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE = obj_
            obj_.original_tagname_ = 'SAMPLE'
        elif nodeName_ == 'BLOCK':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'BLOCK')
            value_ = self.gds_validate_string(value_, node, 'BLOCK')
            self.BLOCK = value_
            self.BLOCK_nsprefix_ = child_.prefix
        elif nodeName_ == 'SLIDE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SLIDE')
            value_ = self.gds_validate_string(value_, node, 'SLIDE')
            self.SLIDE = value_
            self.SLIDE_nsprefix_ = child_.prefix
# end class SAMPLE_TYPEType


class BIOLOGICAL_BEING(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BIOLOGICAL_BEING)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BIOLOGICAL_BEING.subclass:
            return BIOLOGICAL_BEING.subclass(*args_, **kwargs_)
        else:
            return BIOLOGICAL_BEING(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIOLOGICAL_BEING', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BIOLOGICAL_BEING')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BIOLOGICAL_BEING':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BIOLOGICAL_BEING')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BIOLOGICAL_BEING', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BIOLOGICAL_BEING'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BIOLOGICAL_BEING', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BIOLOGICAL_BEING


class SPECIMEN(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPECIMEN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPECIMEN.subclass:
            return SPECIMEN.subclass(*args_, **kwargs_)
        else:
            return SPECIMEN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPECIMEN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPECIMEN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SPECIMEN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPECIMEN')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPECIMEN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SPECIMEN'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPECIMEN', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SPECIMEN


class SAMPLE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE.subclass:
            return SAMPLE.subclass(*args_, **kwargs_)
        else:
            return SAMPLE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SAMPLE


class BLOCK(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BLOCK)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BLOCK.subclass:
            return BLOCK.subclass(*args_, **kwargs_)
        else:
            return BLOCK(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BLOCK', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BLOCK')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BLOCK':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BLOCK')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BLOCK', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BLOCK'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BLOCK', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BLOCK


class SLIDE(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SLIDE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SLIDE.subclass:
            return SLIDE.subclass(*args_, **kwargs_)
        else:
            return SLIDE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIDE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SLIDE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SLIDE':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SLIDE')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SLIDE', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SLIDE'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SLIDE', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SLIDE


class SAMPLE_REFType8(RefObjectType):
    """SAMPLE_REFType8 -- One of more samples associated with the
    sample.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SAMPLE_REFType8"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_REFType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_REFType8.subclass:
            return SAMPLE_REFType8.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_REFType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(SAMPLE_REFType8, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_REFType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_REFType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType8')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_REFType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_REFType8'):
        super(SAMPLE_REFType8, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType8')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType8', fromsubclass_=False, pretty_print=True):
        super(SAMPLE_REFType8, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SAMPLE_REFType8, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SAMPLE_REFType8, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SAMPLE_REFType8


class SAMPLE_CODED_ATTRIBUTESType(GeneratedsSuper):
    """SAMPLE_CODED_ATTRIBUTESType --
    Properties and attributes of a sample.  These can be entered as
    tag-coded value pairs. For certain studies, submitters may be asked to follow a
    community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_CODED_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SAMPLE_CODED_ATTRIBUTE is None:
            self.SAMPLE_CODED_ATTRIBUTE = []
        else:
            self.SAMPLE_CODED_ATTRIBUTE = SAMPLE_CODED_ATTRIBUTE
        self.SAMPLE_CODED_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_CODED_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_CODED_ATTRIBUTESType.subclass:
            return SAMPLE_CODED_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_CODED_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE_CODED_ATTRIBUTE(self):
        return self.SAMPLE_CODED_ATTRIBUTE
    def set_SAMPLE_CODED_ATTRIBUTE(self, SAMPLE_CODED_ATTRIBUTE):
        self.SAMPLE_CODED_ATTRIBUTE = SAMPLE_CODED_ATTRIBUTE
    def add_SAMPLE_CODED_ATTRIBUTE(self, value):
        self.SAMPLE_CODED_ATTRIBUTE.append(value)
    def insert_SAMPLE_CODED_ATTRIBUTE_at(self, index, value):
        self.SAMPLE_CODED_ATTRIBUTE.insert(index, value)
    def replace_SAMPLE_CODED_ATTRIBUTE_at(self, index, value):
        self.SAMPLE_CODED_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.SAMPLE_CODED_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_CODED_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_CODED_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_CODED_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_CODED_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_CODED_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_CODED_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_CODED_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SAMPLE_CODED_ATTRIBUTE_ in self.SAMPLE_CODED_ATTRIBUTE:
            namespaceprefix_ = self.SAMPLE_CODED_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_CODED_ATTRIBUTE_nsprefix_) else ''
            SAMPLE_CODED_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_CODED_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE_CODED_ATTRIBUTE':
            obj_ = CodedAttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_CODED_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_CODED_ATTRIBUTE'
# end class SAMPLE_CODED_ATTRIBUTESType


class CONTACTSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CONTACT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CONTACT is None:
            self.CONTACT = []
        else:
            self.CONTACT = CONTACT
        self.CONTACT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTACTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTACTSType.subclass:
            return CONTACTSType.subclass(*args_, **kwargs_)
        else:
            return CONTACTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CONTACT(self):
        return self.CONTACT
    def set_CONTACT(self, CONTACT):
        self.CONTACT = CONTACT
    def add_CONTACT(self, value):
        self.CONTACT.append(value)
    def insert_CONTACT_at(self, index, value):
        self.CONTACT.insert(index, value)
    def replace_CONTACT_at(self, index, value):
        self.CONTACT[index] = value
    def _hasContent(self):
        if (
            self.CONTACT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTACTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONTACTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTACTSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTACTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTACTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CONTACT_ in self.CONTACT:
            namespaceprefix_ = self.CONTACT_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTACT_nsprefix_) else ''
            CONTACT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONTACT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CONTACT':
            obj_ = CONTACTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CONTACT.append(obj_)
            obj_.original_tagname_ = 'CONTACT'
# end class CONTACTSType


class CONTACTType(GeneratedsSuper):
    """name --
    Name of contact person for this DAC.

    * email --
      email of the person to contact.

    * telephone_number --
      telephone_number of the person to contact.

    * organisation -- Center or institution name .
    * main_contact -- If true then this is the main contact.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, email=None, telephone_number=None, organisation=None, main_contact=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.email = _cast(None, email)
        self.email_nsprefix_ = None
        self.telephone_number = _cast(None, telephone_number)
        self.telephone_number_nsprefix_ = None
        self.organisation = _cast(None, organisation)
        self.organisation_nsprefix_ = None
        self.main_contact = _cast(bool, main_contact)
        self.main_contact_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTACTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTACTType.subclass:
            return CONTACTType.subclass(*args_, **kwargs_)
        else:
            return CONTACTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def get_telephone_number(self):
        return self.telephone_number
    def set_telephone_number(self, telephone_number):
        self.telephone_number = telephone_number
    def get_organisation(self):
        return self.organisation
    def set_organisation(self, organisation):
        self.organisation = organisation
    def get_main_contact(self):
        return self.main_contact
    def set_main_contact(self, main_contact):
        self.main_contact = main_contact
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTACTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONTACTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTACTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTACTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTACTType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(' email=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.email), input_name='email')), ))
        if self.telephone_number is not None and 'telephone_number' not in already_processed:
            already_processed.add('telephone_number')
            outfile.write(' telephone_number=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.telephone_number), input_name='telephone_number')), ))
        if self.organisation is not None and 'organisation' not in already_processed:
            already_processed.add('organisation')
            outfile.write(' organisation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.organisation), input_name='organisation')), ))
        if self.main_contact is not None and 'main_contact' not in already_processed:
            already_processed.add('main_contact')
            outfile.write(' main_contact="%s"' % self.gds_format_boolean(self.main_contact, input_name='main_contact'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
        value = find_attr_value_('telephone_number', node)
        if value is not None and 'telephone_number' not in already_processed:
            already_processed.add('telephone_number')
            self.telephone_number = value
        value = find_attr_value_('organisation', node)
        if value is not None and 'organisation' not in already_processed:
            already_processed.add('organisation')
            self.organisation = value
        value = find_attr_value_('main_contact', node)
        if value is not None and 'main_contact' not in already_processed:
            already_processed.add('main_contact')
            if value in ('true', '1'):
                self.main_contact = True
            elif value in ('false', '0'):
                self.main_contact = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CONTACTType


class DAC_LINKSType(GeneratedsSuper):
    """DAC_LINKSType -- Links to related resources.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DAC_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DAC_LINK is None:
            self.DAC_LINK = []
        else:
            self.DAC_LINK = DAC_LINK
        self.DAC_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DAC_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DAC_LINKSType.subclass:
            return DAC_LINKSType.subclass(*args_, **kwargs_)
        else:
            return DAC_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DAC_LINK(self):
        return self.DAC_LINK
    def set_DAC_LINK(self, DAC_LINK):
        self.DAC_LINK = DAC_LINK
    def add_DAC_LINK(self, value):
        self.DAC_LINK.append(value)
    def insert_DAC_LINK_at(self, index, value):
        self.DAC_LINK.insert(index, value)
    def replace_DAC_LINK_at(self, index, value):
        self.DAC_LINK[index] = value
    def _hasContent(self):
        if (
            self.DAC_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DAC_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DAC_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DAC_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DAC_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DAC_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DAC_LINK_ in self.DAC_LINK:
            namespaceprefix_ = self.DAC_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_LINK_nsprefix_) else ''
            DAC_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DAC_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC_LINK.append(obj_)
            obj_.original_tagname_ = 'DAC_LINK'
# end class DAC_LINKSType


class DAC_ATTRIBUTESType(GeneratedsSuper):
    """DAC_ATTRIBUTESType -- Properties and attributes of the DAC. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DAC_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DAC_ATTRIBUTE is None:
            self.DAC_ATTRIBUTE = []
        else:
            self.DAC_ATTRIBUTE = DAC_ATTRIBUTE
        self.DAC_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DAC_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DAC_ATTRIBUTESType.subclass:
            return DAC_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return DAC_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DAC_ATTRIBUTE(self):
        return self.DAC_ATTRIBUTE
    def set_DAC_ATTRIBUTE(self, DAC_ATTRIBUTE):
        self.DAC_ATTRIBUTE = DAC_ATTRIBUTE
    def add_DAC_ATTRIBUTE(self, value):
        self.DAC_ATTRIBUTE.append(value)
    def insert_DAC_ATTRIBUTE_at(self, index, value):
        self.DAC_ATTRIBUTE.insert(index, value)
    def replace_DAC_ATTRIBUTE_at(self, index, value):
        self.DAC_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.DAC_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DAC_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DAC_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DAC_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DAC_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DAC_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DAC_ATTRIBUTE_ in self.DAC_ATTRIBUTE:
            namespaceprefix_ = self.DAC_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_ATTRIBUTE_nsprefix_) else ''
            DAC_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DAC_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'DAC_ATTRIBUTE'
# end class DAC_ATTRIBUTESType


class RUN_REFType(RefObjectType):
    """RUN_REFType --
    Identifies the runs which are part of this dataset.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RUN_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUN_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUN_REFType.subclass:
            return RUN_REFType.subclass(*args_, **kwargs_)
        else:
            return RUN_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RUN_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUN_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RUN_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUN_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUN_REFType'):
        super(RUN_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_REFType', fromsubclass_=False, pretty_print=True):
        super(RUN_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RUN_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RUN_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RUN_REFType


class ANALYSIS_REFType(RefObjectType):
    """ANALYSIS_REFType --
    Identifies the analyses which are part of this dataset.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANALYSIS_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANALYSIS_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANALYSIS_REFType.subclass:
            return ANALYSIS_REFType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ANALYSIS_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANALYSIS_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANALYSIS_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANALYSIS_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANALYSIS_REFType'):
        super(ANALYSIS_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_REFType', fromsubclass_=False, pretty_print=True):
        super(ANALYSIS_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ANALYSIS_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ANALYSIS_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ANALYSIS_REFType


class POLICY_REFType(RefObjectType):
    """POLICY_REFType -- Identifies the data access policy controlling this data set.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("POLICY_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POLICY_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLICY_REFType.subclass:
            return POLICY_REFType.subclass(*args_, **kwargs_)
        else:
            return POLICY_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(POLICY_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POLICY_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POLICY_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POLICY_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POLICY_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POLICY_REFType'):
        super(POLICY_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POLICY_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_REFType', fromsubclass_=False, pretty_print=True):
        super(POLICY_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(POLICY_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(POLICY_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class POLICY_REFType


class DATASET_LINKSType(GeneratedsSuper):
    """DATASET_LINKSType -- Links to related resources.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASET_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASET_LINK is None:
            self.DATASET_LINK = []
        else:
            self.DATASET_LINK = DATASET_LINK
        self.DATASET_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASET_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASET_LINKSType.subclass:
            return DATASET_LINKSType.subclass(*args_, **kwargs_)
        else:
            return DATASET_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASET_LINK(self):
        return self.DATASET_LINK
    def set_DATASET_LINK(self, DATASET_LINK):
        self.DATASET_LINK = DATASET_LINK
    def add_DATASET_LINK(self, value):
        self.DATASET_LINK.append(value)
    def insert_DATASET_LINK_at(self, index, value):
        self.DATASET_LINK.insert(index, value)
    def replace_DATASET_LINK_at(self, index, value):
        self.DATASET_LINK[index] = value
    def _hasContent(self):
        if (
            self.DATASET_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASET_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASET_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASET_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASET_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASET_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASET_LINK_ in self.DATASET_LINK:
            namespaceprefix_ = self.DATASET_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_LINK_nsprefix_) else ''
            DATASET_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASET_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_LINK.append(obj_)
            obj_.original_tagname_ = 'DATASET_LINK'
# end class DATASET_LINKSType


class DATASET_ATTRIBUTESType(GeneratedsSuper):
    """DATASET_ATTRIBUTESType -- Properties and attributes of the data set. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATASET_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATASET_ATTRIBUTE is None:
            self.DATASET_ATTRIBUTE = []
        else:
            self.DATASET_ATTRIBUTE = DATASET_ATTRIBUTE
        self.DATASET_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATASET_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATASET_ATTRIBUTESType.subclass:
            return DATASET_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return DATASET_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASET_ATTRIBUTE(self):
        return self.DATASET_ATTRIBUTE
    def set_DATASET_ATTRIBUTE(self, DATASET_ATTRIBUTE):
        self.DATASET_ATTRIBUTE = DATASET_ATTRIBUTE
    def add_DATASET_ATTRIBUTE(self, value):
        self.DATASET_ATTRIBUTE.append(value)
    def insert_DATASET_ATTRIBUTE_at(self, index, value):
        self.DATASET_ATTRIBUTE.insert(index, value)
    def replace_DATASET_ATTRIBUTE_at(self, index, value):
        self.DATASET_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.DATASET_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATASET_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATASET_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATASET_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATASET_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATASET_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATASET_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASET_ATTRIBUTE_ in self.DATASET_ATTRIBUTE:
            namespaceprefix_ = self.DATASET_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_ATTRIBUTE_nsprefix_) else ''
            DATASET_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASET_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'DATASET_ATTRIBUTE'
# end class DATASET_ATTRIBUTESType


class DAC_REFType(RefObjectType):
    """DAC_REFType -- Identifies the data access committee to which this policy pertains.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DAC_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DAC_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DAC_REFType.subclass:
            return DAC_REFType.subclass(*args_, **kwargs_)
        else:
            return DAC_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DAC_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DAC_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DAC_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DAC_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DAC_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DAC_REFType'):
        super(DAC_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DAC_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DAC_REFType', fromsubclass_=False, pretty_print=True):
        super(DAC_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DAC_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DAC_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DAC_REFType


class DATA_USESType(GeneratedsSuper):
    """DATA_USESType -- Data use ontologies (DUO) related to the policy

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DATA_USE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if DATA_USE is None:
            self.DATA_USE = []
        else:
            self.DATA_USE = DATA_USE
        self.DATA_USE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_USESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_USESType.subclass:
            return DATA_USESType.subclass(*args_, **kwargs_)
        else:
            return DATA_USESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATA_USE(self):
        return self.DATA_USE
    def set_DATA_USE(self, DATA_USE):
        self.DATA_USE = DATA_USE
    def add_DATA_USE(self, value):
        self.DATA_USE.append(value)
    def insert_DATA_USE_at(self, index, value):
        self.DATA_USE.insert(index, value)
    def replace_DATA_USE_at(self, index, value):
        self.DATA_USE[index] = value
    def _hasContent(self):
        if (
            self.DATA_USE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATA_USESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA_USESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATA_USESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA_USESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA_USESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA_USESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATA_USESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATA_USE_ in self.DATA_USE:
            namespaceprefix_ = self.DATA_USE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_USE_nsprefix_) else ''
            DATA_USE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA_USE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATA_USE':
            obj_ = DataUseType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATA_USE.append(obj_)
            obj_.original_tagname_ = 'DATA_USE'
# end class DATA_USESType


class POLICY_LINKSType(GeneratedsSuper):
    """POLICY_LINKSType -- Links to related resources.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, POLICY_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if POLICY_LINK is None:
            self.POLICY_LINK = []
        else:
            self.POLICY_LINK = POLICY_LINK
        self.POLICY_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POLICY_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLICY_LINKSType.subclass:
            return POLICY_LINKSType.subclass(*args_, **kwargs_)
        else:
            return POLICY_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_POLICY_LINK(self):
        return self.POLICY_LINK
    def set_POLICY_LINK(self, POLICY_LINK):
        self.POLICY_LINK = POLICY_LINK
    def add_POLICY_LINK(self, value):
        self.POLICY_LINK.append(value)
    def insert_POLICY_LINK_at(self, index, value):
        self.POLICY_LINK.insert(index, value)
    def replace_POLICY_LINK_at(self, index, value):
        self.POLICY_LINK[index] = value
    def _hasContent(self):
        if (
            self.POLICY_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POLICY_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POLICY_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POLICY_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POLICY_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POLICY_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for POLICY_LINK_ in self.POLICY_LINK:
            namespaceprefix_ = self.POLICY_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_LINK_nsprefix_) else ''
            POLICY_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'POLICY_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY_LINK.append(obj_)
            obj_.original_tagname_ = 'POLICY_LINK'
# end class POLICY_LINKSType


class POLICY_ATTRIBUTESType(GeneratedsSuper):
    """POLICY_ATTRIBUTESType -- Properties and attributes of the policy. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, POLICY_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if POLICY_ATTRIBUTE is None:
            self.POLICY_ATTRIBUTE = []
        else:
            self.POLICY_ATTRIBUTE = POLICY_ATTRIBUTE
        self.POLICY_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POLICY_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POLICY_ATTRIBUTESType.subclass:
            return POLICY_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return POLICY_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_POLICY_ATTRIBUTE(self):
        return self.POLICY_ATTRIBUTE
    def set_POLICY_ATTRIBUTE(self, POLICY_ATTRIBUTE):
        self.POLICY_ATTRIBUTE = POLICY_ATTRIBUTE
    def add_POLICY_ATTRIBUTE(self, value):
        self.POLICY_ATTRIBUTE.append(value)
    def insert_POLICY_ATTRIBUTE_at(self, index, value):
        self.POLICY_ATTRIBUTE.insert(index, value)
    def replace_POLICY_ATTRIBUTE_at(self, index, value):
        self.POLICY_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.POLICY_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POLICY_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POLICY_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POLICY_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POLICY_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POLICY_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POLICY_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for POLICY_ATTRIBUTE_ in self.POLICY_ATTRIBUTE:
            namespaceprefix_ = self.POLICY_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_ATTRIBUTE_nsprefix_) else ''
            POLICY_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'POLICY_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'POLICY_ATTRIBUTE'
# end class POLICY_ATTRIBUTESType


class TAXONType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TAXON_ID=None, SCIENTIFIC_NAME=None, COMMON_NAME=None, STRAIN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TAXON_ID = TAXON_ID
        self.TAXON_ID_nsprefix_ = None
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
        self.SCIENTIFIC_NAME_nsprefix_ = None
        self.COMMON_NAME = COMMON_NAME
        self.COMMON_NAME_nsprefix_ = None
        self.STRAIN = STRAIN
        self.STRAIN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TAXONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TAXONType.subclass:
            return TAXONType.subclass(*args_, **kwargs_)
        else:
            return TAXONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAXON_ID(self):
        return self.TAXON_ID
    def set_TAXON_ID(self, TAXON_ID):
        self.TAXON_ID = TAXON_ID
    def get_SCIENTIFIC_NAME(self):
        return self.SCIENTIFIC_NAME
    def set_SCIENTIFIC_NAME(self, SCIENTIFIC_NAME):
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
    def get_COMMON_NAME(self):
        return self.COMMON_NAME
    def set_COMMON_NAME(self, COMMON_NAME):
        self.COMMON_NAME = COMMON_NAME
    def get_STRAIN(self):
        return self.STRAIN
    def set_STRAIN(self, STRAIN):
        self.STRAIN = STRAIN
    def _hasContent(self):
        if (
            self.TAXON_ID is not None or
            self.SCIENTIFIC_NAME is not None or
            self.COMMON_NAME is not None or
            self.STRAIN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TAXONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TAXONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TAXONType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TAXONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TAXONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAXON_ID is not None:
            namespaceprefix_ = self.TAXON_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXON_ID>%s</%sTAXON_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.TAXON_ID, input_name='TAXON_ID'), namespaceprefix_ , eol_))
        if self.SCIENTIFIC_NAME is not None:
            namespaceprefix_ = self.SCIENTIFIC_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCIENTIFIC_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCIENTIFIC_NAME>%s</%sSCIENTIFIC_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCIENTIFIC_NAME), input_name='SCIENTIFIC_NAME')), namespaceprefix_ , eol_))
        if self.COMMON_NAME is not None:
            namespaceprefix_ = self.COMMON_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMON_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMON_NAME>%s</%sCOMMON_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMMON_NAME), input_name='COMMON_NAME')), namespaceprefix_ , eol_))
        if self.STRAIN is not None:
            namespaceprefix_ = self.STRAIN_nsprefix_ + ':' if (UseCapturedNS_ and self.STRAIN_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTRAIN>%s</%sSTRAIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STRAIN), input_name='STRAIN')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAXON_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TAXON_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'TAXON_ID')
            self.TAXON_ID = ival_
            self.TAXON_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCIENTIFIC_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCIENTIFIC_NAME')
            value_ = self.gds_validate_string(value_, node, 'SCIENTIFIC_NAME')
            self.SCIENTIFIC_NAME = value_
            self.SCIENTIFIC_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMON_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMMON_NAME')
            value_ = self.gds_validate_string(value_, node, 'COMMON_NAME')
            self.COMMON_NAME = value_
            self.COMMON_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'STRAIN':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STRAIN')
            value_ = self.gds_validate_string(value_, node, 'STRAIN')
            self.STRAIN = value_
            self.STRAIN_nsprefix_ = child_.prefix
# end class TAXONType


class SAMPLE_REFType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refname = _cast(None, refname)
        self.refname_nsprefix_ = None
        self.refcenter = _cast(None, refcenter)
        self.refcenter_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.IDENTIFIERS = IDENTIFIERS
        self.IDENTIFIERS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_REFType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_REFType10.subclass:
            return SAMPLE_REFType10.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_REFType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS
    def get_refname(self):
        return self.refname
    def set_refname(self, refname):
        self.refname = refname
    def get_refcenter(self):
        return self.refcenter
    def set_refcenter(self, refcenter):
        self.refcenter = refcenter
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_REFType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_REFType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType10')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_REFType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_REFType10'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refname), input_name='refname')), ))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refcenter), input_name='refcenter')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            namespaceprefix_ = self.IDENTIFIERS_nsprefix_ + ':' if (UseCapturedNS_ and self.IDENTIFIERS_nsprefix_) else ''
            self.IDENTIFIERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IDENTIFIERS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class SAMPLE_REFType10


class STUDY_REFType11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refname = _cast(None, refname)
        self.refname_nsprefix_ = None
        self.refcenter = _cast(None, refcenter)
        self.refcenter_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.IDENTIFIERS = IDENTIFIERS
        self.IDENTIFIERS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_REFType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_REFType11.subclass:
            return STUDY_REFType11.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS
    def get_refname(self):
        return self.refname
    def set_refname(self, refname):
        self.refname = refname
    def get_refcenter(self):
        return self.refcenter
    def set_refcenter(self, refcenter):
        self.refcenter = refcenter
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_REFType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_REFType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType11')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_REFType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_REFType11'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refname), input_name='refname')), ))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refcenter), input_name='refcenter')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            namespaceprefix_ = self.IDENTIFIERS_nsprefix_ + ':' if (UseCapturedNS_ and self.IDENTIFIERS_nsprefix_) else ''
            self.IDENTIFIERS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IDENTIFIERS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class STUDY_REFType11


class WGS_SETType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PREFIX=None, VERSION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PREFIX = PREFIX
        self.PREFIX_nsprefix_ = None
        self.VERSION = VERSION
        self.VERSION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WGS_SETType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WGS_SETType.subclass:
            return WGS_SETType.subclass(*args_, **kwargs_)
        else:
            return WGS_SETType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PREFIX(self):
        return self.PREFIX
    def set_PREFIX(self, PREFIX):
        self.PREFIX = PREFIX
    def get_VERSION(self):
        return self.VERSION
    def set_VERSION(self, VERSION):
        self.VERSION = VERSION
    def _hasContent(self):
        if (
            self.PREFIX is not None or
            self.VERSION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WGS_SETType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WGS_SETType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'WGS_SETType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WGS_SETType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WGS_SETType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WGS_SETType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WGS_SETType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PREFIX is not None:
            namespaceprefix_ = self.PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREFIX>%s</%sPREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PREFIX), input_name='PREFIX')), namespaceprefix_ , eol_))
        if self.VERSION is not None:
            namespaceprefix_ = self.VERSION_nsprefix_ + ':' if (UseCapturedNS_ and self.VERSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespaceprefix_ , self.gds_format_integer(self.VERSION, input_name='VERSION'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PREFIX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PREFIX')
            value_ = self.gds_validate_string(value_, node, 'PREFIX')
            self.PREFIX = value_
            self.PREFIX_nsprefix_ = child_.prefix
        elif nodeName_ == 'VERSION' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'VERSION')
            ival_ = self.gds_validate_integer(ival_, node, 'VERSION')
            self.VERSION = ival_
            self.VERSION_nsprefix_ = child_.prefix
# end class WGS_SETType


class CHROMOSOMESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CHROMOSOME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CHROMOSOME is None:
            self.CHROMOSOME = []
        else:
            self.CHROMOSOME = CHROMOSOME
        self.CHROMOSOME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHROMOSOMESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHROMOSOMESType.subclass:
            return CHROMOSOMESType.subclass(*args_, **kwargs_)
        else:
            return CHROMOSOMESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CHROMOSOME(self):
        return self.CHROMOSOME
    def set_CHROMOSOME(self, CHROMOSOME):
        self.CHROMOSOME = CHROMOSOME
    def add_CHROMOSOME(self, value):
        self.CHROMOSOME.append(value)
    def insert_CHROMOSOME_at(self, index, value):
        self.CHROMOSOME.insert(index, value)
    def replace_CHROMOSOME_at(self, index, value):
        self.CHROMOSOME[index] = value
    def _hasContent(self):
        if (
            self.CHROMOSOME
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHROMOSOMESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CHROMOSOMESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CHROMOSOMESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CHROMOSOMESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CHROMOSOMESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CHROMOSOMESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHROMOSOMESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CHROMOSOME_ in self.CHROMOSOME:
            namespaceprefix_ = self.CHROMOSOME_nsprefix_ + ':' if (UseCapturedNS_ and self.CHROMOSOME_nsprefix_) else ''
            CHROMOSOME_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CHROMOSOME', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CHROMOSOME':
            obj_ = CHROMOSOMEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CHROMOSOME.append(obj_)
            obj_.original_tagname_ = 'CHROMOSOME'
# end class CHROMOSOMESType


class CHROMOSOMEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, NAME=None, TYPE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TYPE = TYPE
        self.validate_TYPEType(self.TYPE)
        self.TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHROMOSOMEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHROMOSOMEType.subclass:
            return CHROMOSOMEType.subclass(*args_, **kwargs_)
        else:
            return CHROMOSOMEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def validate_TYPEType(self, value):
        result = True
        # Validate type TYPEType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Plastid', 'Kinetoplast', 'Segment', 'Apicoplast', 'Virus', 'Mitochondrial Miscellaneous', 'Plasmid', 'Nucleomorph', 'Macronucleus', 'Chloroplast', 'Mitochondrion', 'Virus Chromosome', 'Extrachromosomal Element', 'Miscellaneous', 'Provirus', 'Chromosome', 'Non-nuclear Miscellaneous', 'Chromatophore', 'Provirus Chromosome', 'Mitochondrial Plasmid', 'Linkage Group', 'Cyanelle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.TYPE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHROMOSOMEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CHROMOSOMEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CHROMOSOMEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CHROMOSOMEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CHROMOSOMEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CHROMOSOMEType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHROMOSOMEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
            # validate type TYPEType
            self.validate_TYPEType(self.TYPE)
# end class CHROMOSOMEType


class ASSEMBLY_LINKSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ASSEMBLY_LINK is None:
            self.ASSEMBLY_LINK = []
        else:
            self.ASSEMBLY_LINK = ASSEMBLY_LINK
        self.ASSEMBLY_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ASSEMBLY_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ASSEMBLY_LINKSType.subclass:
            return ASSEMBLY_LINKSType.subclass(*args_, **kwargs_)
        else:
            return ASSEMBLY_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ASSEMBLY_LINK(self):
        return self.ASSEMBLY_LINK
    def set_ASSEMBLY_LINK(self, ASSEMBLY_LINK):
        self.ASSEMBLY_LINK = ASSEMBLY_LINK
    def add_ASSEMBLY_LINK(self, value):
        self.ASSEMBLY_LINK.append(value)
    def insert_ASSEMBLY_LINK_at(self, index, value):
        self.ASSEMBLY_LINK.insert(index, value)
    def replace_ASSEMBLY_LINK_at(self, index, value):
        self.ASSEMBLY_LINK[index] = value
    def _hasContent(self):
        if (
            self.ASSEMBLY_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ASSEMBLY_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ASSEMBLY_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ASSEMBLY_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ASSEMBLY_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ASSEMBLY_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ASSEMBLY_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ASSEMBLY_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ASSEMBLY_LINK_ in self.ASSEMBLY_LINK:
            namespaceprefix_ = self.ASSEMBLY_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_LINK_nsprefix_) else ''
            ASSEMBLY_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ASSEMBLY_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY_LINK.append(obj_)
            obj_.original_tagname_ = 'ASSEMBLY_LINK'
# end class ASSEMBLY_LINKSType


class ASSEMBLY_ATTRIBUTESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ASSEMBLY_ATTRIBUTE is None:
            self.ASSEMBLY_ATTRIBUTE = []
        else:
            self.ASSEMBLY_ATTRIBUTE = ASSEMBLY_ATTRIBUTE
        self.ASSEMBLY_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ASSEMBLY_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ASSEMBLY_ATTRIBUTESType.subclass:
            return ASSEMBLY_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return ASSEMBLY_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ASSEMBLY_ATTRIBUTE(self):
        return self.ASSEMBLY_ATTRIBUTE
    def set_ASSEMBLY_ATTRIBUTE(self, ASSEMBLY_ATTRIBUTE):
        self.ASSEMBLY_ATTRIBUTE = ASSEMBLY_ATTRIBUTE
    def add_ASSEMBLY_ATTRIBUTE(self, value):
        self.ASSEMBLY_ATTRIBUTE.append(value)
    def insert_ASSEMBLY_ATTRIBUTE_at(self, index, value):
        self.ASSEMBLY_ATTRIBUTE.insert(index, value)
    def replace_ASSEMBLY_ATTRIBUTE_at(self, index, value):
        self.ASSEMBLY_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.ASSEMBLY_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ASSEMBLY_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ASSEMBLY_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ASSEMBLY_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ASSEMBLY_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ASSEMBLY_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ASSEMBLY_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ASSEMBLY_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ASSEMBLY_ATTRIBUTE_ in self.ASSEMBLY_ATTRIBUTE:
            namespaceprefix_ = self.ASSEMBLY_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_ATTRIBUTE_nsprefix_) else ''
            ASSEMBLY_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ASSEMBLY_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'ASSEMBLY_ATTRIBUTE'
# end class ASSEMBLY_ATTRIBUTESType


class DESCRIPTORType(GeneratedsSuper):
    """LABEL -- A unique immutable label for the checklist used for referencing purposes.
    NAME -- The name of the checklist used for display purposes.
    DESCRIPTION -- The description of the checklist used for display purposes.
    AUTHORITY -- The checklist authority.
    FIELD_GROUP -- Checklist field group.
    CONDITION -- Field condition.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, NAME=None, DESCRIPTION=None, AUTHORITY=None, FIELD_GROUP=None, CONDITION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.AUTHORITY = AUTHORITY
        self.AUTHORITY_nsprefix_ = None
        if FIELD_GROUP is None:
            self.FIELD_GROUP = []
        else:
            self.FIELD_GROUP = FIELD_GROUP
        self.FIELD_GROUP_nsprefix_ = None
        if CONDITION is None:
            self.CONDITION = []
        else:
            self.CONDITION = CONDITION
        self.CONDITION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESCRIPTORType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESCRIPTORType.subclass:
            return DESCRIPTORType.subclass(*args_, **kwargs_)
        else:
            return DESCRIPTORType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_AUTHORITY(self):
        return self.AUTHORITY
    def set_AUTHORITY(self, AUTHORITY):
        self.AUTHORITY = AUTHORITY
    def get_FIELD_GROUP(self):
        return self.FIELD_GROUP
    def set_FIELD_GROUP(self, FIELD_GROUP):
        self.FIELD_GROUP = FIELD_GROUP
    def add_FIELD_GROUP(self, value):
        self.FIELD_GROUP.append(value)
    def insert_FIELD_GROUP_at(self, index, value):
        self.FIELD_GROUP.insert(index, value)
    def replace_FIELD_GROUP_at(self, index, value):
        self.FIELD_GROUP[index] = value
    def get_CONDITION(self):
        return self.CONDITION
    def set_CONDITION(self, CONDITION):
        self.CONDITION = CONDITION
    def add_CONDITION(self, value):
        self.CONDITION.append(value)
    def insert_CONDITION_at(self, index, value):
        self.CONDITION.insert(index, value)
    def replace_CONDITION_at(self, index, value):
        self.CONDITION[index] = value
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.AUTHORITY is not None or
            self.FIELD_GROUP or
            self.CONDITION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTORType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DESCRIPTORType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DESCRIPTORType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DESCRIPTORType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DESCRIPTORType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DESCRIPTORType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTORType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.AUTHORITY is not None:
            namespaceprefix_ = self.AUTHORITY_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTHORITY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTHORITY>%s</%sAUTHORITY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTHORITY), input_name='AUTHORITY')), namespaceprefix_ , eol_))
        for FIELD_GROUP_ in self.FIELD_GROUP:
            namespaceprefix_ = self.FIELD_GROUP_nsprefix_ + ':' if (UseCapturedNS_ and self.FIELD_GROUP_nsprefix_) else ''
            FIELD_GROUP_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FIELD_GROUP', pretty_print=pretty_print)
        for CONDITION_ in self.CONDITION:
            namespaceprefix_ = self.CONDITION_nsprefix_ + ':' if (UseCapturedNS_ and self.CONDITION_nsprefix_) else ''
            CONDITION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONDITION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTHORITY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTHORITY')
            value_ = self.gds_validate_string(value_, node, 'AUTHORITY')
            self.AUTHORITY = value_
            self.AUTHORITY_nsprefix_ = child_.prefix
        elif nodeName_ == 'FIELD_GROUP':
            obj_ = FIELD_GROUPType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FIELD_GROUP.append(obj_)
            obj_.original_tagname_ = 'FIELD_GROUP'
        elif nodeName_ == 'CONDITION':
            obj_ = CONDITIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CONDITION.append(obj_)
            obj_.original_tagname_ = 'CONDITION'
# end class DESCRIPTORType


class FIELD_GROUPType(GeneratedsSuper):
    """FIELD_GROUPType -- Checklist field group.
    NAME -- The name of the checklist group for display purposes.
    DESCRIPTION -- The description of the field group for display purposes.
    FIELD -- A checklist field.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, restrictionType=None, NAME=None, DESCRIPTION=None, FIELD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.restrictionType = _cast(None, restrictionType)
        self.restrictionType_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        if FIELD is None:
            self.FIELD = []
        else:
            self.FIELD = FIELD
        self.FIELD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FIELD_GROUPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FIELD_GROUPType.subclass:
            return FIELD_GROUPType.subclass(*args_, **kwargs_)
        else:
            return FIELD_GROUPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_FIELD(self):
        return self.FIELD
    def set_FIELD(self, FIELD):
        self.FIELD = FIELD
    def add_FIELD(self, value):
        self.FIELD.append(value)
    def insert_FIELD_at(self, index, value):
        self.FIELD.insert(index, value)
    def replace_FIELD_at(self, index, value):
        self.FIELD[index] = value
    def get_restrictionType(self):
        return self.restrictionType
    def set_restrictionType(self, restrictionType):
        self.restrictionType = restrictionType
    def validate_restrictionTypeType12(self, value):
        # Validate type restrictionTypeType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Any number or none of the fields', 'One of the fields', 'At least one of the fields', 'One or none of the fields']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on restrictionTypeType12' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.FIELD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELD_GROUPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FIELD_GROUPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FIELD_GROUPType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FIELD_GROUPType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FIELD_GROUPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FIELD_GROUPType'):
        if self.restrictionType is not None and 'restrictionType' not in already_processed:
            already_processed.add('restrictionType')
            outfile.write(' restrictionType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restrictionType), input_name='restrictionType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELD_GROUPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        for FIELD_ in self.FIELD:
            namespaceprefix_ = self.FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.FIELD_nsprefix_) else ''
            FIELD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FIELD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restrictionType', node)
        if value is not None and 'restrictionType' not in already_processed:
            already_processed.add('restrictionType')
            self.restrictionType = value
            self.validate_restrictionTypeType12(self.restrictionType)    # validate type restrictionTypeType12
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'FIELD':
            obj_ = FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FIELD.append(obj_)
            obj_.original_tagname_ = 'FIELD'
# end class FIELD_GROUPType


class FIELDType(GeneratedsSuper):
    """FIELDType -- A checklist field.
    LABEL -- A unique immutable label for the field for referencing purposes.
    SYNONYM -- Synonym that will be converted to LABEL.
    NAME -- The name of the field for display purposes.
    DESCRIPTION -- The description of the field for display purposes.

    * UNITS -- The allowed units.
    * FIELD_TYPE -- The field type.
    * MANDATORY -- Defines if the attribute is mandatory, recommended or optional.
    * MULTIPLICITY -- The attribute can appear more than once if the multiplicity value is set to multiple and at most once if the value is set to single. By default an attribute can occur no more than once.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, SYNONYM=None, NAME=None, DESCRIPTION=None, UNITS=None, FIELD_TYPE=None, MANDATORY=None, MULTIPLICITY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        if SYNONYM is None:
            self.SYNONYM = []
        else:
            self.SYNONYM = SYNONYM
        self.SYNONYM_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.UNITS = UNITS
        self.UNITS_nsprefix_ = None
        self.FIELD_TYPE = FIELD_TYPE
        self.FIELD_TYPE_nsprefix_ = None
        self.MANDATORY = MANDATORY
        self.validate_MANDATORYType(self.MANDATORY)
        self.MANDATORY_nsprefix_ = None
        self.MULTIPLICITY = MULTIPLICITY
        self.validate_MULTIPLICITYType(self.MULTIPLICITY)
        self.MULTIPLICITY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FIELDType.subclass:
            return FIELDType.subclass(*args_, **kwargs_)
        else:
            return FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_SYNONYM(self):
        return self.SYNONYM
    def set_SYNONYM(self, SYNONYM):
        self.SYNONYM = SYNONYM
    def add_SYNONYM(self, value):
        self.SYNONYM.append(value)
    def insert_SYNONYM_at(self, index, value):
        self.SYNONYM.insert(index, value)
    def replace_SYNONYM_at(self, index, value):
        self.SYNONYM[index] = value
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_UNITS(self):
        return self.UNITS
    def set_UNITS(self, UNITS):
        self.UNITS = UNITS
    def get_FIELD_TYPE(self):
        return self.FIELD_TYPE
    def set_FIELD_TYPE(self, FIELD_TYPE):
        self.FIELD_TYPE = FIELD_TYPE
    def get_MANDATORY(self):
        return self.MANDATORY
    def set_MANDATORY(self, MANDATORY):
        self.MANDATORY = MANDATORY
    def get_MULTIPLICITY(self):
        return self.MULTIPLICITY
    def set_MULTIPLICITY(self, MULTIPLICITY):
        self.MULTIPLICITY = MULTIPLICITY
    def validate_MANDATORYType(self, value):
        result = True
        # Validate type MANDATORYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['mandatory', 'recommended', 'optional']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MANDATORYType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_MULTIPLICITYType(self, value):
        result = True
        # Validate type MULTIPLICITYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['single', 'multiple']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MULTIPLICITYType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.SYNONYM or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.UNITS is not None or
            self.FIELD_TYPE is not None or
            self.MANDATORY is not None or
            self.MULTIPLICITY is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FIELDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        for SYNONYM_ in self.SYNONYM:
            namespaceprefix_ = self.SYNONYM_nsprefix_ + ':' if (UseCapturedNS_ and self.SYNONYM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYNONYM>%s</%sSYNONYM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SYNONYM_), input_name='SYNONYM')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.UNITS is not None:
            namespaceprefix_ = self.UNITS_nsprefix_ + ':' if (UseCapturedNS_ and self.UNITS_nsprefix_) else ''
            self.UNITS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UNITS', pretty_print=pretty_print)
        if self.FIELD_TYPE is not None:
            namespaceprefix_ = self.FIELD_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.FIELD_TYPE_nsprefix_) else ''
            self.FIELD_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FIELD_TYPE', pretty_print=pretty_print)
        if self.MANDATORY is not None:
            namespaceprefix_ = self.MANDATORY_nsprefix_ + ':' if (UseCapturedNS_ and self.MANDATORY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMANDATORY>%s</%sMANDATORY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MANDATORY), input_name='MANDATORY')), namespaceprefix_ , eol_))
        if self.MULTIPLICITY is not None:
            namespaceprefix_ = self.MULTIPLICITY_nsprefix_ + ':' if (UseCapturedNS_ and self.MULTIPLICITY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMULTIPLICITY>%s</%sMULTIPLICITY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MULTIPLICITY), input_name='MULTIPLICITY')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYNONYM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYNONYM')
            value_ = self.gds_validate_string(value_, node, 'SYNONYM')
            self.SYNONYM.append(value_)
            self.SYNONYM_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'UNITS':
            obj_ = UNITSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UNITS = obj_
            obj_.original_tagname_ = 'UNITS'
        elif nodeName_ == 'FIELD_TYPE':
            obj_ = FIELD_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FIELD_TYPE = obj_
            obj_.original_tagname_ = 'FIELD_TYPE'
        elif nodeName_ == 'MANDATORY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MANDATORY')
            value_ = self.gds_validate_string(value_, node, 'MANDATORY')
            self.MANDATORY = value_
            self.MANDATORY_nsprefix_ = child_.prefix
            # validate type MANDATORYType
            self.validate_MANDATORYType(self.MANDATORY)
        elif nodeName_ == 'MULTIPLICITY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MULTIPLICITY')
            value_ = self.gds_validate_string(value_, node, 'MULTIPLICITY')
            self.MULTIPLICITY = value_
            self.MULTIPLICITY_nsprefix_ = child_.prefix
            # validate type MULTIPLICITYType
            self.validate_MULTIPLICITYType(self.MULTIPLICITY)
# end class FIELDType


class UNITSType(GeneratedsSuper):
    """UNITSType -- The allowed units.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, UNIT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if UNIT is None:
            self.UNIT = []
        else:
            self.UNIT = UNIT
        self.UNIT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UNITSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UNITSType.subclass:
            return UNITSType.subclass(*args_, **kwargs_)
        else:
            return UNITSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UNIT(self):
        return self.UNIT
    def set_UNIT(self, UNIT):
        self.UNIT = UNIT
    def add_UNIT(self, value):
        self.UNIT.append(value)
    def insert_UNIT_at(self, index, value):
        self.UNIT.insert(index, value)
    def replace_UNIT_at(self, index, value):
        self.UNIT[index] = value
    def _hasContent(self):
        if (
            self.UNIT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UNITSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UNITSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UNITSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UNITSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UNITSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UNITSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UNITSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UNIT_ in self.UNIT:
            namespaceprefix_ = self.UNIT_nsprefix_ + ':' if (UseCapturedNS_ and self.UNIT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNIT>%s</%sUNIT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(UNIT_), input_name='UNIT')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UNIT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'UNIT')
            value_ = self.gds_validate_string(value_, node, 'UNIT')
            self.UNIT.append(value_)
            self.UNIT_nsprefix_ = child_.prefix
# end class UNITSType


class FIELD_TYPEType(GeneratedsSuper):
    """FIELD_TYPEType -- The field type.
    TEXT_FIELD -- A single-line text field.
    TEXT_AREA_FIELD -- A multi-line text field.
    TEXT_CHOICE_FIELD -- A single-line text field controlled by a list of text values.
    DATE_FIELD -- A date field.
    TAXON_FIELD -- A taxon field.
    ONTOLOGY_FIELD -- An ontology field.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TEXT_FIELD=None, TEXT_AREA_FIELD=None, TEXT_CHOICE_FIELD=None, DATE_FIELD=None, TAXON_FIELD=None, ONTOLOGY_FIELD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.TEXT_FIELD = TEXT_FIELD
        self.TEXT_FIELD_nsprefix_ = None
        self.TEXT_AREA_FIELD = TEXT_AREA_FIELD
        self.TEXT_AREA_FIELD_nsprefix_ = None
        self.TEXT_CHOICE_FIELD = TEXT_CHOICE_FIELD
        self.TEXT_CHOICE_FIELD_nsprefix_ = None
        self.DATE_FIELD = DATE_FIELD
        self.DATE_FIELD_nsprefix_ = None
        self.TAXON_FIELD = TAXON_FIELD
        self.TAXON_FIELD_nsprefix_ = None
        self.ONTOLOGY_FIELD = ONTOLOGY_FIELD
        self.ONTOLOGY_FIELD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FIELD_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FIELD_TYPEType.subclass:
            return FIELD_TYPEType.subclass(*args_, **kwargs_)
        else:
            return FIELD_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TEXT_FIELD(self):
        return self.TEXT_FIELD
    def set_TEXT_FIELD(self, TEXT_FIELD):
        self.TEXT_FIELD = TEXT_FIELD
    def get_TEXT_AREA_FIELD(self):
        return self.TEXT_AREA_FIELD
    def set_TEXT_AREA_FIELD(self, TEXT_AREA_FIELD):
        self.TEXT_AREA_FIELD = TEXT_AREA_FIELD
    def get_TEXT_CHOICE_FIELD(self):
        return self.TEXT_CHOICE_FIELD
    def set_TEXT_CHOICE_FIELD(self, TEXT_CHOICE_FIELD):
        self.TEXT_CHOICE_FIELD = TEXT_CHOICE_FIELD
    def get_DATE_FIELD(self):
        return self.DATE_FIELD
    def set_DATE_FIELD(self, DATE_FIELD):
        self.DATE_FIELD = DATE_FIELD
    def get_TAXON_FIELD(self):
        return self.TAXON_FIELD
    def set_TAXON_FIELD(self, TAXON_FIELD):
        self.TAXON_FIELD = TAXON_FIELD
    def get_ONTOLOGY_FIELD(self):
        return self.ONTOLOGY_FIELD
    def set_ONTOLOGY_FIELD(self, ONTOLOGY_FIELD):
        self.ONTOLOGY_FIELD = ONTOLOGY_FIELD
    def _hasContent(self):
        if (
            self.TEXT_FIELD is not None or
            self.TEXT_AREA_FIELD is not None or
            self.TEXT_CHOICE_FIELD is not None or
            self.DATE_FIELD is not None or
            self.TAXON_FIELD is not None or
            self.ONTOLOGY_FIELD is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELD_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FIELD_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FIELD_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FIELD_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FIELD_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FIELD_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELD_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TEXT_FIELD is not None:
            namespaceprefix_ = self.TEXT_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.TEXT_FIELD_nsprefix_) else ''
            self.TEXT_FIELD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEXT_FIELD', pretty_print=pretty_print)
        if self.TEXT_AREA_FIELD is not None:
            namespaceprefix_ = self.TEXT_AREA_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.TEXT_AREA_FIELD_nsprefix_) else ''
            self.TEXT_AREA_FIELD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEXT_AREA_FIELD', pretty_print=pretty_print)
        if self.TEXT_CHOICE_FIELD is not None:
            namespaceprefix_ = self.TEXT_CHOICE_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.TEXT_CHOICE_FIELD_nsprefix_) else ''
            self.TEXT_CHOICE_FIELD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEXT_CHOICE_FIELD', pretty_print=pretty_print)
        if self.DATE_FIELD is not None:
            namespaceprefix_ = self.DATE_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.DATE_FIELD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATE_FIELD>%s</%sDATE_FIELD>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DATE_FIELD), input_name='DATE_FIELD')), namespaceprefix_ , eol_))
        if self.TAXON_FIELD is not None:
            namespaceprefix_ = self.TAXON_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_FIELD_nsprefix_) else ''
            self.TAXON_FIELD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TAXON_FIELD', pretty_print=pretty_print)
        if self.ONTOLOGY_FIELD is not None:
            namespaceprefix_ = self.ONTOLOGY_FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.ONTOLOGY_FIELD_nsprefix_) else ''
            self.ONTOLOGY_FIELD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ONTOLOGY_FIELD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TEXT_FIELD':
            obj_ = TEXT_FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEXT_FIELD = obj_
            obj_.original_tagname_ = 'TEXT_FIELD'
        elif nodeName_ == 'TEXT_AREA_FIELD':
            obj_ = TEXT_AREA_FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEXT_AREA_FIELD = obj_
            obj_.original_tagname_ = 'TEXT_AREA_FIELD'
        elif nodeName_ == 'TEXT_CHOICE_FIELD':
            obj_ = TEXT_CHOICE_FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEXT_CHOICE_FIELD = obj_
            obj_.original_tagname_ = 'TEXT_CHOICE_FIELD'
        elif nodeName_ == 'DATE_FIELD':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATE_FIELD')
            value_ = self.gds_validate_string(value_, node, 'DATE_FIELD')
            self.DATE_FIELD = value_
            self.DATE_FIELD_nsprefix_ = child_.prefix
        elif nodeName_ == 'TAXON_FIELD':
            obj_ = TAXON_FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TAXON_FIELD = obj_
            obj_.original_tagname_ = 'TAXON_FIELD'
        elif nodeName_ == 'ONTOLOGY_FIELD':
            obj_ = ONTOLOGY_FIELDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ONTOLOGY_FIELD = obj_
            obj_.original_tagname_ = 'ONTOLOGY_FIELD'
# end class FIELD_TYPEType


class DATE_FIELD(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATE_FIELD)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATE_FIELD.subclass:
            return DATE_FIELD.subclass(*args_, **kwargs_)
        else:
            return DATE_FIELD(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATE_FIELD', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATE_FIELD')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATE_FIELD':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATE_FIELD')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATE_FIELD', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATE_FIELD'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATE_FIELD', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DATE_FIELD


class TEXT_FIELDType(GeneratedsSuper):
    """TEXT_FIELDType -- A single-line text field.
    MIN_LENGTH -- Minimum string length.
    MAX_LENGTH -- Maximum string length.
    REGEX_VALUE -- The regular expression.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MIN_LENGTH=None, MAX_LENGTH=None, REGEX_VALUE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MIN_LENGTH = MIN_LENGTH
        self.MIN_LENGTH_nsprefix_ = None
        self.MAX_LENGTH = MAX_LENGTH
        self.MAX_LENGTH_nsprefix_ = None
        self.REGEX_VALUE = REGEX_VALUE
        self.REGEX_VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEXT_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEXT_FIELDType.subclass:
            return TEXT_FIELDType.subclass(*args_, **kwargs_)
        else:
            return TEXT_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MIN_LENGTH(self):
        return self.MIN_LENGTH
    def set_MIN_LENGTH(self, MIN_LENGTH):
        self.MIN_LENGTH = MIN_LENGTH
    def get_MAX_LENGTH(self):
        return self.MAX_LENGTH
    def set_MAX_LENGTH(self, MAX_LENGTH):
        self.MAX_LENGTH = MAX_LENGTH
    def get_REGEX_VALUE(self):
        return self.REGEX_VALUE
    def set_REGEX_VALUE(self, REGEX_VALUE):
        self.REGEX_VALUE = REGEX_VALUE
    def _hasContent(self):
        if (
            self.MIN_LENGTH is not None or
            self.MAX_LENGTH is not None or
            self.REGEX_VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEXT_FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEXT_FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEXT_FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEXT_FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEXT_FIELDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MIN_LENGTH is not None:
            namespaceprefix_ = self.MIN_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MIN_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMIN_LENGTH>%s</%sMIN_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MIN_LENGTH, input_name='MIN_LENGTH'), namespaceprefix_ , eol_))
        if self.MAX_LENGTH is not None:
            namespaceprefix_ = self.MAX_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_LENGTH>%s</%sMAX_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_LENGTH, input_name='MAX_LENGTH'), namespaceprefix_ , eol_))
        if self.REGEX_VALUE is not None:
            namespaceprefix_ = self.REGEX_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.REGEX_VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREGEX_VALUE>%s</%sREGEX_VALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.REGEX_VALUE), input_name='REGEX_VALUE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MIN_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MIN_LENGTH')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MIN_LENGTH')
            self.MIN_LENGTH = ival_
            self.MIN_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_LENGTH')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_LENGTH')
            self.MAX_LENGTH = ival_
            self.MAX_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'REGEX_VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'REGEX_VALUE')
            value_ = self.gds_validate_string(value_, node, 'REGEX_VALUE')
            self.REGEX_VALUE = value_
            self.REGEX_VALUE_nsprefix_ = child_.prefix
# end class TEXT_FIELDType


class TEXT_AREA_FIELDType(GeneratedsSuper):
    """TEXT_AREA_FIELDType -- A multi-line text field.
    MIN_LENGTH -- Minimum string length.
    MAX_LENGTH -- Maximum string length.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, MIN_LENGTH=None, MAX_LENGTH=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.MIN_LENGTH = MIN_LENGTH
        self.MIN_LENGTH_nsprefix_ = None
        self.MAX_LENGTH = MAX_LENGTH
        self.MAX_LENGTH_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEXT_AREA_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEXT_AREA_FIELDType.subclass:
            return TEXT_AREA_FIELDType.subclass(*args_, **kwargs_)
        else:
            return TEXT_AREA_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MIN_LENGTH(self):
        return self.MIN_LENGTH
    def set_MIN_LENGTH(self, MIN_LENGTH):
        self.MIN_LENGTH = MIN_LENGTH
    def get_MAX_LENGTH(self):
        return self.MAX_LENGTH
    def set_MAX_LENGTH(self, MAX_LENGTH):
        self.MAX_LENGTH = MAX_LENGTH
    def _hasContent(self):
        if (
            self.MIN_LENGTH is not None or
            self.MAX_LENGTH is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_AREA_FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEXT_AREA_FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEXT_AREA_FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEXT_AREA_FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEXT_AREA_FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEXT_AREA_FIELDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_AREA_FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MIN_LENGTH is not None:
            namespaceprefix_ = self.MIN_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MIN_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMIN_LENGTH>%s</%sMIN_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MIN_LENGTH, input_name='MIN_LENGTH'), namespaceprefix_ , eol_))
        if self.MAX_LENGTH is not None:
            namespaceprefix_ = self.MAX_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MAX_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMAX_LENGTH>%s</%sMAX_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MAX_LENGTH, input_name='MAX_LENGTH'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MIN_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MIN_LENGTH')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MIN_LENGTH')
            self.MIN_LENGTH = ival_
            self.MIN_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'MAX_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MAX_LENGTH')
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MAX_LENGTH')
            self.MAX_LENGTH = ival_
            self.MAX_LENGTH_nsprefix_ = child_.prefix
# end class TEXT_AREA_FIELDType


class TEXT_CHOICE_FIELDType(GeneratedsSuper):
    """TEXT_CHOICE_FIELDType -- A single-line text field controlled by a list of text values.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, TEXT_VALUE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if TEXT_VALUE is None:
            self.TEXT_VALUE = []
        else:
            self.TEXT_VALUE = TEXT_VALUE
        self.TEXT_VALUE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEXT_CHOICE_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEXT_CHOICE_FIELDType.subclass:
            return TEXT_CHOICE_FIELDType.subclass(*args_, **kwargs_)
        else:
            return TEXT_CHOICE_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TEXT_VALUE(self):
        return self.TEXT_VALUE
    def set_TEXT_VALUE(self, TEXT_VALUE):
        self.TEXT_VALUE = TEXT_VALUE
    def add_TEXT_VALUE(self, value):
        self.TEXT_VALUE.append(value)
    def insert_TEXT_VALUE_at(self, index, value):
        self.TEXT_VALUE.insert(index, value)
    def replace_TEXT_VALUE_at(self, index, value):
        self.TEXT_VALUE[index] = value
    def _hasContent(self):
        if (
            self.TEXT_VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_CHOICE_FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEXT_CHOICE_FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEXT_CHOICE_FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEXT_CHOICE_FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEXT_CHOICE_FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEXT_CHOICE_FIELDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_CHOICE_FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TEXT_VALUE_ in self.TEXT_VALUE:
            namespaceprefix_ = self.TEXT_VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.TEXT_VALUE_nsprefix_) else ''
            TEXT_VALUE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TEXT_VALUE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TEXT_VALUE':
            obj_ = TEXT_VALUEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TEXT_VALUE.append(obj_)
            obj_.original_tagname_ = 'TEXT_VALUE'
# end class TEXT_CHOICE_FIELDType


class TEXT_VALUEType(GeneratedsSuper):
    """VALUE -- Allowed text value.
    SYNONYM -- Synonym that will be converted to VALUE.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, VALUE=None, SYNONYM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.VALUE = VALUE
        self.VALUE_nsprefix_ = None
        if SYNONYM is None:
            self.SYNONYM = []
        else:
            self.SYNONYM = SYNONYM
        self.SYNONYM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEXT_VALUEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEXT_VALUEType.subclass:
            return TEXT_VALUEType.subclass(*args_, **kwargs_)
        else:
            return TEXT_VALUEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_VALUE(self):
        return self.VALUE
    def set_VALUE(self, VALUE):
        self.VALUE = VALUE
    def get_SYNONYM(self):
        return self.SYNONYM
    def set_SYNONYM(self, SYNONYM):
        self.SYNONYM = SYNONYM
    def add_SYNONYM(self, value):
        self.SYNONYM.append(value)
    def insert_SYNONYM_at(self, index, value):
        self.SYNONYM.insert(index, value)
    def replace_SYNONYM_at(self, index, value):
        self.SYNONYM[index] = value
    def _hasContent(self):
        if (
            self.VALUE is not None or
            self.SYNONYM
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_VALUEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEXT_VALUEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TEXT_VALUEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEXT_VALUEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEXT_VALUEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TEXT_VALUEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TEXT_VALUEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VALUE is not None:
            namespaceprefix_ = self.VALUE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALUE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), namespaceprefix_ , eol_))
        for SYNONYM_ in self.SYNONYM:
            namespaceprefix_ = self.SYNONYM_nsprefix_ + ':' if (UseCapturedNS_ and self.SYNONYM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSYNONYM>%s</%sSYNONYM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(SYNONYM_), input_name='SYNONYM')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'VALUE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VALUE')
            value_ = self.gds_validate_string(value_, node, 'VALUE')
            self.VALUE = value_
            self.VALUE_nsprefix_ = child_.prefix
        elif nodeName_ == 'SYNONYM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SYNONYM')
            value_ = self.gds_validate_string(value_, node, 'SYNONYM')
            self.SYNONYM.append(value_)
            self.SYNONYM_nsprefix_ = child_.prefix
# end class TEXT_VALUEType


class TAXON_FIELDType(GeneratedsSuper):
    """TAXON_FIELDType -- A taxon field.
    restrictionType -- Taxon restriction type.
    TAXON -- Taxid.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, restrictionType=None, TAXON=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.restrictionType = _cast(None, restrictionType)
        self.restrictionType_nsprefix_ = None
        if TAXON is None:
            self.TAXON = []
        else:
            self.TAXON = TAXON
        self.TAXON_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TAXON_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TAXON_FIELDType.subclass:
            return TAXON_FIELDType.subclass(*args_, **kwargs_)
        else:
            return TAXON_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAXON(self):
        return self.TAXON
    def set_TAXON(self, TAXON):
        self.TAXON = TAXON
    def add_TAXON(self, value):
        self.TAXON.append(value)
    def insert_TAXON_at(self, index, value):
        self.TAXON.insert(index, value)
    def replace_TAXON_at(self, index, value):
        self.TAXON[index] = value
    def get_restrictionType(self):
        return self.restrictionType
    def set_restrictionType(self, restrictionType):
        self.restrictionType = restrictionType
    def validate_restrictionTypeType(self, value):
        # Validate type restrictionTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Permitted taxa', 'Not permitted taxa']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on restrictionTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.TAXON
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXON_FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TAXON_FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TAXON_FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TAXON_FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TAXON_FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TAXON_FIELDType'):
        if self.restrictionType is not None and 'restrictionType' not in already_processed:
            already_processed.add('restrictionType')
            outfile.write(' restrictionType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.restrictionType), input_name='restrictionType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXON_FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TAXON_ in self.TAXON:
            namespaceprefix_ = self.TAXON_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXON>%s</%sTAXON>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(TAXON_), input_name='TAXON')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restrictionType', node)
        if value is not None and 'restrictionType' not in already_processed:
            already_processed.add('restrictionType')
            self.restrictionType = value
            self.validate_restrictionTypeType(self.restrictionType)    # validate type restrictionTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAXON':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TAXON')
            value_ = self.gds_validate_string(value_, node, 'TAXON')
            self.TAXON.append(value_)
            self.TAXON_nsprefix_ = child_.prefix
# end class TAXON_FIELDType


class ONTOLOGY_FIELDType(GeneratedsSuper):
    """ONTOLOGY_FIELDType -- An ontology field.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ONTOLOGY_ID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ONTOLOGY_ID = ONTOLOGY_ID
        self.ONTOLOGY_ID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ONTOLOGY_FIELDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ONTOLOGY_FIELDType.subclass:
            return ONTOLOGY_FIELDType.subclass(*args_, **kwargs_)
        else:
            return ONTOLOGY_FIELDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ONTOLOGY_ID(self):
        return self.ONTOLOGY_ID
    def set_ONTOLOGY_ID(self, ONTOLOGY_ID):
        self.ONTOLOGY_ID = ONTOLOGY_ID
    def _hasContent(self):
        if (
            self.ONTOLOGY_ID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ONTOLOGY_FIELDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ONTOLOGY_FIELDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ONTOLOGY_FIELDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ONTOLOGY_FIELDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ONTOLOGY_FIELDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ONTOLOGY_FIELDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ONTOLOGY_FIELDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ONTOLOGY_ID is not None:
            namespaceprefix_ = self.ONTOLOGY_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ONTOLOGY_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sONTOLOGY_ID>%s</%sONTOLOGY_ID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ONTOLOGY_ID), input_name='ONTOLOGY_ID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ONTOLOGY_ID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ONTOLOGY_ID')
            value_ = self.gds_validate_string(value_, node, 'ONTOLOGY_ID')
            self.ONTOLOGY_ID = value_
            self.ONTOLOGY_ID_nsprefix_ = child_.prefix
# end class ONTOLOGY_FIELDType


class CONDITIONType(GeneratedsSuper):
    """CONDITIONType -- Field condition.
    LABEL -- A unique immutable label for referencing purposes.
    NAME -- The name of the condition for display purposes.
    DESCRIPTION -- The description of the condition for display purposes.
    EXPRESSION -- The condition expression.
    ERROR -- The condition error.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, NAME=None, DESCRIPTION=None, EXPRESSION=None, ERROR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.EXPRESSION = EXPRESSION
        self.EXPRESSION_nsprefix_ = None
        self.ERROR = ERROR
        self.ERROR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONDITIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONDITIONType.subclass:
            return CONDITIONType.subclass(*args_, **kwargs_)
        else:
            return CONDITIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_EXPRESSION(self):
        return self.EXPRESSION
    def set_EXPRESSION(self, EXPRESSION):
        self.EXPRESSION = EXPRESSION
    def get_ERROR(self):
        return self.ERROR
    def set_ERROR(self, ERROR):
        self.ERROR = ERROR
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.NAME is not None or
            self.DESCRIPTION is not None or
            self.EXPRESSION is not None or
            self.ERROR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONDITIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONDITIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONDITIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONDITIONType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONDITIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONDITIONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONDITIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.EXPRESSION is not None:
            namespaceprefix_ = self.EXPRESSION_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPRESSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXPRESSION>%s</%sEXPRESSION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXPRESSION), input_name='EXPRESSION')), namespaceprefix_ , eol_))
        if self.ERROR is not None:
            namespaceprefix_ = self.ERROR_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sERROR>%s</%sERROR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ERROR), input_name='ERROR')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXPRESSION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXPRESSION')
            value_ = self.gds_validate_string(value_, node, 'EXPRESSION')
            self.EXPRESSION = value_
            self.EXPRESSION_nsprefix_ = child_.prefix
        elif nodeName_ == 'ERROR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ERROR')
            value_ = self.gds_validate_string(value_, node, 'ERROR')
            self.ERROR = value_
            self.ERROR_nsprefix_ = child_.prefix
# end class CONDITIONType


class COLLABORATORSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, COLLABORATOR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if COLLABORATOR is None:
            self.COLLABORATOR = []
        else:
            self.COLLABORATOR = COLLABORATOR
        self.COLLABORATOR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COLLABORATORSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COLLABORATORSType.subclass:
            return COLLABORATORSType.subclass(*args_, **kwargs_)
        else:
            return COLLABORATORSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_COLLABORATOR(self):
        return self.COLLABORATOR
    def set_COLLABORATOR(self, COLLABORATOR):
        self.COLLABORATOR = COLLABORATOR
    def add_COLLABORATOR(self, value):
        self.COLLABORATOR.append(value)
    def insert_COLLABORATOR_at(self, index, value):
        self.COLLABORATOR.insert(index, value)
    def replace_COLLABORATOR_at(self, index, value):
        self.COLLABORATOR[index] = value
    def _hasContent(self):
        if (
            self.COLLABORATOR
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COLLABORATORSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COLLABORATORSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COLLABORATORSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COLLABORATORSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COLLABORATORSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COLLABORATORSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COLLABORATORSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for COLLABORATOR_ in self.COLLABORATOR:
            namespaceprefix_ = self.COLLABORATOR_nsprefix_ + ':' if (UseCapturedNS_ and self.COLLABORATOR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOLLABORATOR>%s</%sCOLLABORATOR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(COLLABORATOR_), input_name='COLLABORATOR')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'COLLABORATOR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COLLABORATOR')
            value_ = self.gds_validate_string(value_, node, 'COLLABORATOR')
            self.COLLABORATOR.append(value_)
            self.COLLABORATOR_nsprefix_ = child_.prefix
# end class COLLABORATORSType


class SUBMISSION_PROJECTType(GeneratedsSuper):
    """SUBMISSION_PROJECTType --  A project for grouping submitted data together.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SEQUENCING_PROJECT=None, ORGANISM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SEQUENCING_PROJECT = SEQUENCING_PROJECT
        self.SEQUENCING_PROJECT_nsprefix_ = None
        self.ORGANISM = ORGANISM
        self.ORGANISM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBMISSION_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBMISSION_PROJECTType.subclass:
            return SUBMISSION_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return SUBMISSION_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SEQUENCING_PROJECT(self):
        return self.SEQUENCING_PROJECT
    def set_SEQUENCING_PROJECT(self, SEQUENCING_PROJECT):
        self.SEQUENCING_PROJECT = SEQUENCING_PROJECT
    def get_ORGANISM(self):
        return self.ORGANISM
    def set_ORGANISM(self, ORGANISM):
        self.ORGANISM = ORGANISM
    def _hasContent(self):
        if (
            self.SEQUENCING_PROJECT is not None or
            self.ORGANISM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SUBMISSION_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SUBMISSION_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SUBMISSION_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SUBMISSION_PROJECTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SUBMISSION_PROJECTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_PROJECTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SEQUENCING_PROJECT is not None:
            namespaceprefix_ = self.SEQUENCING_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCING_PROJECT_nsprefix_) else ''
            self.SEQUENCING_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCING_PROJECT', pretty_print=pretty_print)
        if self.ORGANISM is not None:
            namespaceprefix_ = self.ORGANISM_nsprefix_ + ':' if (UseCapturedNS_ and self.ORGANISM_nsprefix_) else ''
            self.ORGANISM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORGANISM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SEQUENCING_PROJECT':
            obj_ = SEQUENCING_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCING_PROJECT = obj_
            obj_.original_tagname_ = 'SEQUENCING_PROJECT'
        elif nodeName_ == 'ORGANISM':
            obj_ = OrganismType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORGANISM = obj_
            obj_.original_tagname_ = 'ORGANISM'
# end class SUBMISSION_PROJECTType


class SEQUENCING_PROJECTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCUS_TAG_PREFIX=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if LOCUS_TAG_PREFIX is None:
            self.LOCUS_TAG_PREFIX = []
        else:
            self.LOCUS_TAG_PREFIX = LOCUS_TAG_PREFIX
        self.LOCUS_TAG_PREFIX_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEQUENCING_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEQUENCING_PROJECTType.subclass:
            return SEQUENCING_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCING_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCUS_TAG_PREFIX(self):
        return self.LOCUS_TAG_PREFIX
    def set_LOCUS_TAG_PREFIX(self, LOCUS_TAG_PREFIX):
        self.LOCUS_TAG_PREFIX = LOCUS_TAG_PREFIX
    def add_LOCUS_TAG_PREFIX(self, value):
        self.LOCUS_TAG_PREFIX.append(value)
    def insert_LOCUS_TAG_PREFIX_at(self, index, value):
        self.LOCUS_TAG_PREFIX.insert(index, value)
    def replace_LOCUS_TAG_PREFIX_at(self, index, value):
        self.LOCUS_TAG_PREFIX[index] = value
    def _hasContent(self):
        if (
            self.LOCUS_TAG_PREFIX
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCING_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SEQUENCING_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SEQUENCING_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCING_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SEQUENCING_PROJECTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SEQUENCING_PROJECTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCING_PROJECTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LOCUS_TAG_PREFIX_ in self.LOCUS_TAG_PREFIX:
            namespaceprefix_ = self.LOCUS_TAG_PREFIX_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCUS_TAG_PREFIX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLOCUS_TAG_PREFIX>%s</%sLOCUS_TAG_PREFIX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(LOCUS_TAG_PREFIX_), input_name='LOCUS_TAG_PREFIX')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCUS_TAG_PREFIX':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'LOCUS_TAG_PREFIX')
            value_ = self.gds_validate_string(value_, node, 'LOCUS_TAG_PREFIX')
            self.LOCUS_TAG_PREFIX.append(value_)
            self.LOCUS_TAG_PREFIX_nsprefix_ = child_.prefix
# end class SEQUENCING_PROJECTType


class UMBRELLA_PROJECTType(GeneratedsSuper):
    """UMBRELLA_PROJECTType --  A project for grouping other projects together.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ORGANISM=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ORGANISM = ORGANISM
        self.ORGANISM_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UMBRELLA_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UMBRELLA_PROJECTType.subclass:
            return UMBRELLA_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return UMBRELLA_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ORGANISM(self):
        return self.ORGANISM
    def set_ORGANISM(self, ORGANISM):
        self.ORGANISM = ORGANISM
    def _hasContent(self):
        if (
            self.ORGANISM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UMBRELLA_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UMBRELLA_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UMBRELLA_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UMBRELLA_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UMBRELLA_PROJECTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UMBRELLA_PROJECTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UMBRELLA_PROJECTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ORGANISM is not None:
            namespaceprefix_ = self.ORGANISM_nsprefix_ + ':' if (UseCapturedNS_ and self.ORGANISM_nsprefix_) else ''
            self.ORGANISM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ORGANISM', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ORGANISM':
            obj_ = OrganismType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ORGANISM = obj_
            obj_.original_tagname_ = 'ORGANISM'
# end class UMBRELLA_PROJECTType


class RELATED_PROJECTSType(GeneratedsSuper):
    """RELATED_PROJECTSType --  Other projects related to this project.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RELATED_PROJECT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RELATED_PROJECT is None:
            self.RELATED_PROJECT = []
        else:
            self.RELATED_PROJECT = RELATED_PROJECT
        self.RELATED_PROJECT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELATED_PROJECTSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELATED_PROJECTSType.subclass:
            return RELATED_PROJECTSType.subclass(*args_, **kwargs_)
        else:
            return RELATED_PROJECTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RELATED_PROJECT(self):
        return self.RELATED_PROJECT
    def set_RELATED_PROJECT(self, RELATED_PROJECT):
        self.RELATED_PROJECT = RELATED_PROJECT
    def add_RELATED_PROJECT(self, value):
        self.RELATED_PROJECT.append(value)
    def insert_RELATED_PROJECT_at(self, index, value):
        self.RELATED_PROJECT.insert(index, value)
    def replace_RELATED_PROJECT_at(self, index, value):
        self.RELATED_PROJECT[index] = value
    def _hasContent(self):
        if (
            self.RELATED_PROJECT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_PROJECTSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELATED_PROJECTSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELATED_PROJECTSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELATED_PROJECTSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELATED_PROJECTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELATED_PROJECTSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_PROJECTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RELATED_PROJECT_ in self.RELATED_PROJECT:
            namespaceprefix_ = self.RELATED_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATED_PROJECT_nsprefix_) else ''
            RELATED_PROJECT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATED_PROJECT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RELATED_PROJECT':
            obj_ = RELATED_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATED_PROJECT.append(obj_)
            obj_.original_tagname_ = 'RELATED_PROJECT'
# end class RELATED_PROJECTSType


class RELATED_PROJECTType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PARENT_PROJECT=None, CHILD_PROJECT=None, PEER_PROJECT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PARENT_PROJECT = PARENT_PROJECT
        self.PARENT_PROJECT_nsprefix_ = None
        self.CHILD_PROJECT = CHILD_PROJECT
        self.CHILD_PROJECT_nsprefix_ = None
        self.PEER_PROJECT = PEER_PROJECT
        self.PEER_PROJECT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELATED_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELATED_PROJECTType.subclass:
            return RELATED_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return RELATED_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PARENT_PROJECT(self):
        return self.PARENT_PROJECT
    def set_PARENT_PROJECT(self, PARENT_PROJECT):
        self.PARENT_PROJECT = PARENT_PROJECT
    def get_CHILD_PROJECT(self):
        return self.CHILD_PROJECT
    def set_CHILD_PROJECT(self, CHILD_PROJECT):
        self.CHILD_PROJECT = CHILD_PROJECT
    def get_PEER_PROJECT(self):
        return self.PEER_PROJECT
    def set_PEER_PROJECT(self, PEER_PROJECT):
        self.PEER_PROJECT = PEER_PROJECT
    def _hasContent(self):
        if (
            self.PARENT_PROJECT is not None or
            self.CHILD_PROJECT is not None or
            self.PEER_PROJECT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELATED_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELATED_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELATED_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELATED_PROJECTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELATED_PROJECTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_PROJECTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PARENT_PROJECT is not None:
            namespaceprefix_ = self.PARENT_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.PARENT_PROJECT_nsprefix_) else ''
            self.PARENT_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PARENT_PROJECT', pretty_print=pretty_print)
        if self.CHILD_PROJECT is not None:
            namespaceprefix_ = self.CHILD_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.CHILD_PROJECT_nsprefix_) else ''
            self.CHILD_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CHILD_PROJECT', pretty_print=pretty_print)
        if self.PEER_PROJECT is not None:
            namespaceprefix_ = self.PEER_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.PEER_PROJECT_nsprefix_) else ''
            self.PEER_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PEER_PROJECT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PARENT_PROJECT':
            obj_ = PARENT_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PARENT_PROJECT = obj_
            obj_.original_tagname_ = 'PARENT_PROJECT'
        elif nodeName_ == 'CHILD_PROJECT':
            obj_ = CHILD_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CHILD_PROJECT = obj_
            obj_.original_tagname_ = 'CHILD_PROJECT'
        elif nodeName_ == 'PEER_PROJECT':
            obj_ = PEER_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PEER_PROJECT = obj_
            obj_.original_tagname_ = 'PEER_PROJECT'
# end class RELATED_PROJECTType


class PARENT_PROJECTType(GeneratedsSuper):
    """accession --  Identifies the project using
    an accession number.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PARENT_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PARENT_PROJECTType.subclass:
            return PARENT_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return PARENT_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PARENT_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PARENT_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PARENT_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PARENT_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PARENT_PROJECTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PARENT_PROJECTType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PARENT_PROJECTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PARENT_PROJECTType


class CHILD_PROJECTType(GeneratedsSuper):
    """accession --  Identifies the project using
    an accession number.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHILD_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHILD_PROJECTType.subclass:
            return CHILD_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return CHILD_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHILD_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CHILD_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CHILD_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CHILD_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CHILD_PROJECTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CHILD_PROJECTType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CHILD_PROJECTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CHILD_PROJECTType


class PEER_PROJECTType(GeneratedsSuper):
    """accession --  Identifies the project using
    an accession number.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PEER_PROJECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PEER_PROJECTType.subclass:
            return PEER_PROJECTType.subclass(*args_, **kwargs_)
        else:
            return PEER_PROJECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PEER_PROJECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PEER_PROJECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PEER_PROJECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PEER_PROJECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PEER_PROJECTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PEER_PROJECTType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PEER_PROJECTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PEER_PROJECTType


class PROJECT_LINKSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PROJECT_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PROJECT_LINK is None:
            self.PROJECT_LINK = []
        else:
            self.PROJECT_LINK = PROJECT_LINK
        self.PROJECT_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROJECT_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROJECT_LINKSType.subclass:
            return PROJECT_LINKSType.subclass(*args_, **kwargs_)
        else:
            return PROJECT_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROJECT_LINK(self):
        return self.PROJECT_LINK
    def set_PROJECT_LINK(self, PROJECT_LINK):
        self.PROJECT_LINK = PROJECT_LINK
    def add_PROJECT_LINK(self, value):
        self.PROJECT_LINK.append(value)
    def insert_PROJECT_LINK_at(self, index, value):
        self.PROJECT_LINK.insert(index, value)
    def replace_PROJECT_LINK_at(self, index, value):
        self.PROJECT_LINK[index] = value
    def _hasContent(self):
        if (
            self.PROJECT_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROJECT_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PROJECT_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROJECT_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROJECT_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROJECT_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PROJECT_LINK_ in self.PROJECT_LINK:
            namespaceprefix_ = self.PROJECT_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_LINK_nsprefix_) else ''
            PROJECT_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROJECT_LINK':
            obj_ = PROJECT_LINKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT_LINK.append(obj_)
            obj_.original_tagname_ = 'PROJECT_LINK'
# end class PROJECT_LINKSType


class PROJECT_LINKType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, XREF_LINK=None, URL_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.XREF_LINK = XREF_LINK
        self.XREF_LINK_nsprefix_ = None
        self.URL_LINK = URL_LINK
        self.URL_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROJECT_LINKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROJECT_LINKType.subclass:
            return PROJECT_LINKType.subclass(*args_, **kwargs_)
        else:
            return PROJECT_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_XREF_LINK(self):
        return self.XREF_LINK
    def set_XREF_LINK(self, XREF_LINK):
        self.XREF_LINK = XREF_LINK
    def get_URL_LINK(self):
        return self.URL_LINK
    def set_URL_LINK(self, URL_LINK):
        self.URL_LINK = URL_LINK
    def _hasContent(self):
        if (
            self.XREF_LINK is not None or
            self.URL_LINK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_LINKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROJECT_LINKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PROJECT_LINKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROJECT_LINKType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROJECT_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROJECT_LINKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.XREF_LINK is not None:
            namespaceprefix_ = self.XREF_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.XREF_LINK_nsprefix_) else ''
            self.XREF_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XREF_LINK', pretty_print=pretty_print)
        if self.URL_LINK is not None:
            namespaceprefix_ = self.URL_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_LINK_nsprefix_) else ''
            self.URL_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='URL_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'URL_LINK':
            obj_ = URLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
# end class PROJECT_LINKType


class PROJECT_ATTRIBUTESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PROJECT_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if PROJECT_ATTRIBUTE is None:
            self.PROJECT_ATTRIBUTE = []
        else:
            self.PROJECT_ATTRIBUTE = PROJECT_ATTRIBUTE
        self.PROJECT_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROJECT_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROJECT_ATTRIBUTESType.subclass:
            return PROJECT_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return PROJECT_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROJECT_ATTRIBUTE(self):
        return self.PROJECT_ATTRIBUTE
    def set_PROJECT_ATTRIBUTE(self, PROJECT_ATTRIBUTE):
        self.PROJECT_ATTRIBUTE = PROJECT_ATTRIBUTE
    def add_PROJECT_ATTRIBUTE(self, value):
        self.PROJECT_ATTRIBUTE.append(value)
    def insert_PROJECT_ATTRIBUTE_at(self, index, value):
        self.PROJECT_ATTRIBUTE.insert(index, value)
    def replace_PROJECT_ATTRIBUTE_at(self, index, value):
        self.PROJECT_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.PROJECT_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROJECT_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PROJECT_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROJECT_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROJECT_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROJECT_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROJECT_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PROJECT_ATTRIBUTE_ in self.PROJECT_ATTRIBUTE:
            namespaceprefix_ = self.PROJECT_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_ATTRIBUTE_nsprefix_) else ''
            PROJECT_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROJECT_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'PROJECT_ATTRIBUTE'
# end class PROJECT_ATTRIBUTESType


class STUDY_REFType15(RefObjectType):
    """STUDY_REFType15 -- Identifies the parent study.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("STUDY_REFType15"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_REFType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_REFType15.subclass:
            return STUDY_REFType15.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(STUDY_REFType15, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_REFType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_REFType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType15')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_REFType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_REFType15'):
        super(STUDY_REFType15, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType15')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType15', fromsubclass_=False, pretty_print=True):
        super(STUDY_REFType15, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(STUDY_REFType15, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(STUDY_REFType15, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class STUDY_REFType15


class SAMPLE_REFType16(RefObjectType):
    """SAMPLE_REFType16 -- One of more samples associated with the
    analysis.
    label -- A label associating the sample with sample references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SAMPLE_REFType16"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_REFType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_REFType16.subclass:
            return SAMPLE_REFType16.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_REFType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(SAMPLE_REFType16, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_REFType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_REFType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType16')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_REFType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_REFType16'):
        super(SAMPLE_REFType16, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_REFType16')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_REFType16', fromsubclass_=False, pretty_print=True):
        super(SAMPLE_REFType16, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(SAMPLE_REFType16, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SAMPLE_REFType16, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SAMPLE_REFType16


class EXPERIMENT_REFType(RefObjectType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EXPERIMENT_REFType"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXPERIMENT_REFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXPERIMENT_REFType.subclass:
            return EXPERIMENT_REFType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(EXPERIMENT_REFType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_REFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXPERIMENT_REFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXPERIMENT_REFType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_REFType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXPERIMENT_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXPERIMENT_REFType'):
        super(EXPERIMENT_REFType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_REFType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_REFType', fromsubclass_=False, pretty_print=True):
        super(EXPERIMENT_REFType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EXPERIMENT_REFType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EXPERIMENT_REFType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EXPERIMENT_REFType


class RUN_REFType17(RefObjectType):
    """RUN_REFType17 -- One or more runs associated with the
    analysis.
    label -- A label associating the run with run references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RUN_REFType17"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUN_REFType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUN_REFType17.subclass:
            return RUN_REFType17.subclass(*args_, **kwargs_)
        else:
            return RUN_REFType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(RUN_REFType17, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_REFType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUN_REFType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RUN_REFType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_REFType17')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUN_REFType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUN_REFType17'):
        super(RUN_REFType17, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_REFType17')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_REFType17', fromsubclass_=False, pretty_print=True):
        super(RUN_REFType17, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(RUN_REFType17, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RUN_REFType17, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RUN_REFType17


class ANALYSIS_REFType18(RefObjectType):
    """ANALYSIS_REFType18 -- One or more analyses associated with the
    analysis.
    label -- A label associating the analysis with analysis references in data files.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ANALYSIS_REFType18"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANALYSIS_REFType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANALYSIS_REFType18.subclass:
            return ANALYSIS_REFType18.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_REFType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (
            super(ANALYSIS_REFType18, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_REFType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANALYSIS_REFType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANALYSIS_REFType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_REFType18')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANALYSIS_REFType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANALYSIS_REFType18'):
        super(ANALYSIS_REFType18, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_REFType18')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_REFType18', fromsubclass_=False, pretty_print=True):
        super(ANALYSIS_REFType18, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(ANALYSIS_REFType18, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ANALYSIS_REFType18, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ANALYSIS_REFType18


class ANALYSIS_TYPEType(GeneratedsSuper):
    """ANALYSIS_TYPEType -- The type of the analysis.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, REFERENCE_ALIGNMENT=None, SEQUENCE_VARIATION=None, SEQUENCE_ASSEMBLY=None, SEQUENCE_FLATFILE=None, SEQUENCE_ANNOTATION=None, REFERENCE_SEQUENCE=None, SAMPLE_PHENOTYPE=None, PROCESSED_READS=None, GENOME_MAP=None, AMR_ANTIBIOGRAM=None, PATHOGEN_ANALYSIS=None, COVID19_CONSENSUS=None, COVID19_FILTERED_VCF=None, TRANSCRIPTOME_ASSEMBLY=None, TAXONOMIC_REFERENCE_SET=None, ASSEMBLY_ANNOTATION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
        self.REFERENCE_ALIGNMENT_nsprefix_ = None
        self.SEQUENCE_VARIATION = SEQUENCE_VARIATION
        self.SEQUENCE_VARIATION_nsprefix_ = None
        self.SEQUENCE_ASSEMBLY = SEQUENCE_ASSEMBLY
        self.SEQUENCE_ASSEMBLY_nsprefix_ = None
        self.SEQUENCE_FLATFILE = SEQUENCE_FLATFILE
        self.SEQUENCE_FLATFILE_nsprefix_ = None
        self.SEQUENCE_ANNOTATION = SEQUENCE_ANNOTATION
        self.SEQUENCE_ANNOTATION_nsprefix_ = None
        self.REFERENCE_SEQUENCE = REFERENCE_SEQUENCE
        self.REFERENCE_SEQUENCE_nsprefix_ = None
        self.SAMPLE_PHENOTYPE = SAMPLE_PHENOTYPE
        self.SAMPLE_PHENOTYPE_nsprefix_ = None
        self.PROCESSED_READS = PROCESSED_READS
        self.PROCESSED_READS_nsprefix_ = None
        self.GENOME_MAP = GENOME_MAP
        self.GENOME_MAP_nsprefix_ = None
        self.AMR_ANTIBIOGRAM = AMR_ANTIBIOGRAM
        self.AMR_ANTIBIOGRAM_nsprefix_ = None
        self.PATHOGEN_ANALYSIS = PATHOGEN_ANALYSIS
        self.PATHOGEN_ANALYSIS_nsprefix_ = None
        self.COVID19_CONSENSUS = COVID19_CONSENSUS
        self.COVID19_CONSENSUS_nsprefix_ = None
        self.COVID19_FILTERED_VCF = COVID19_FILTERED_VCF
        self.COVID19_FILTERED_VCF_nsprefix_ = None
        self.TRANSCRIPTOME_ASSEMBLY = TRANSCRIPTOME_ASSEMBLY
        self.TRANSCRIPTOME_ASSEMBLY_nsprefix_ = None
        self.TAXONOMIC_REFERENCE_SET = TAXONOMIC_REFERENCE_SET
        self.TAXONOMIC_REFERENCE_SET_nsprefix_ = None
        self.ASSEMBLY_ANNOTATION = ASSEMBLY_ANNOTATION
        self.ASSEMBLY_ANNOTATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANALYSIS_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANALYSIS_TYPEType.subclass:
            return ANALYSIS_TYPEType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_REFERENCE_ALIGNMENT(self):
        return self.REFERENCE_ALIGNMENT
    def set_REFERENCE_ALIGNMENT(self, REFERENCE_ALIGNMENT):
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
    def get_SEQUENCE_VARIATION(self):
        return self.SEQUENCE_VARIATION
    def set_SEQUENCE_VARIATION(self, SEQUENCE_VARIATION):
        self.SEQUENCE_VARIATION = SEQUENCE_VARIATION
    def get_SEQUENCE_ASSEMBLY(self):
        return self.SEQUENCE_ASSEMBLY
    def set_SEQUENCE_ASSEMBLY(self, SEQUENCE_ASSEMBLY):
        self.SEQUENCE_ASSEMBLY = SEQUENCE_ASSEMBLY
    def get_SEQUENCE_FLATFILE(self):
        return self.SEQUENCE_FLATFILE
    def set_SEQUENCE_FLATFILE(self, SEQUENCE_FLATFILE):
        self.SEQUENCE_FLATFILE = SEQUENCE_FLATFILE
    def get_SEQUENCE_ANNOTATION(self):
        return self.SEQUENCE_ANNOTATION
    def set_SEQUENCE_ANNOTATION(self, SEQUENCE_ANNOTATION):
        self.SEQUENCE_ANNOTATION = SEQUENCE_ANNOTATION
    def get_REFERENCE_SEQUENCE(self):
        return self.REFERENCE_SEQUENCE
    def set_REFERENCE_SEQUENCE(self, REFERENCE_SEQUENCE):
        self.REFERENCE_SEQUENCE = REFERENCE_SEQUENCE
    def get_SAMPLE_PHENOTYPE(self):
        return self.SAMPLE_PHENOTYPE
    def set_SAMPLE_PHENOTYPE(self, SAMPLE_PHENOTYPE):
        self.SAMPLE_PHENOTYPE = SAMPLE_PHENOTYPE
    def get_PROCESSED_READS(self):
        return self.PROCESSED_READS
    def set_PROCESSED_READS(self, PROCESSED_READS):
        self.PROCESSED_READS = PROCESSED_READS
    def get_GENOME_MAP(self):
        return self.GENOME_MAP
    def set_GENOME_MAP(self, GENOME_MAP):
        self.GENOME_MAP = GENOME_MAP
    def get_AMR_ANTIBIOGRAM(self):
        return self.AMR_ANTIBIOGRAM
    def set_AMR_ANTIBIOGRAM(self, AMR_ANTIBIOGRAM):
        self.AMR_ANTIBIOGRAM = AMR_ANTIBIOGRAM
    def get_PATHOGEN_ANALYSIS(self):
        return self.PATHOGEN_ANALYSIS
    def set_PATHOGEN_ANALYSIS(self, PATHOGEN_ANALYSIS):
        self.PATHOGEN_ANALYSIS = PATHOGEN_ANALYSIS
    def get_COVID19_CONSENSUS(self):
        return self.COVID19_CONSENSUS
    def set_COVID19_CONSENSUS(self, COVID19_CONSENSUS):
        self.COVID19_CONSENSUS = COVID19_CONSENSUS
    def get_COVID19_FILTERED_VCF(self):
        return self.COVID19_FILTERED_VCF
    def set_COVID19_FILTERED_VCF(self, COVID19_FILTERED_VCF):
        self.COVID19_FILTERED_VCF = COVID19_FILTERED_VCF
    def get_TRANSCRIPTOME_ASSEMBLY(self):
        return self.TRANSCRIPTOME_ASSEMBLY
    def set_TRANSCRIPTOME_ASSEMBLY(self, TRANSCRIPTOME_ASSEMBLY):
        self.TRANSCRIPTOME_ASSEMBLY = TRANSCRIPTOME_ASSEMBLY
    def get_TAXONOMIC_REFERENCE_SET(self):
        return self.TAXONOMIC_REFERENCE_SET
    def set_TAXONOMIC_REFERENCE_SET(self, TAXONOMIC_REFERENCE_SET):
        self.TAXONOMIC_REFERENCE_SET = TAXONOMIC_REFERENCE_SET
    def get_ASSEMBLY_ANNOTATION(self):
        return self.ASSEMBLY_ANNOTATION
    def set_ASSEMBLY_ANNOTATION(self, ASSEMBLY_ANNOTATION):
        self.ASSEMBLY_ANNOTATION = ASSEMBLY_ANNOTATION
    def _hasContent(self):
        if (
            self.REFERENCE_ALIGNMENT is not None or
            self.SEQUENCE_VARIATION is not None or
            self.SEQUENCE_ASSEMBLY is not None or
            self.SEQUENCE_FLATFILE is not None or
            self.SEQUENCE_ANNOTATION is not None or
            self.REFERENCE_SEQUENCE is not None or
            self.SAMPLE_PHENOTYPE is not None or
            self.PROCESSED_READS is not None or
            self.GENOME_MAP is not None or
            self.AMR_ANTIBIOGRAM is not None or
            self.PATHOGEN_ANALYSIS is not None or
            self.COVID19_CONSENSUS is not None or
            self.COVID19_FILTERED_VCF is not None or
            self.TRANSCRIPTOME_ASSEMBLY is not None or
            self.TAXONOMIC_REFERENCE_SET is not None or
            self.ASSEMBLY_ANNOTATION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANALYSIS_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANALYSIS_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANALYSIS_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANALYSIS_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.REFERENCE_ALIGNMENT is not None:
            namespaceprefix_ = self.REFERENCE_ALIGNMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.REFERENCE_ALIGNMENT_nsprefix_) else ''
            self.REFERENCE_ALIGNMENT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REFERENCE_ALIGNMENT', pretty_print=pretty_print)
        if self.SEQUENCE_VARIATION is not None:
            namespaceprefix_ = self.SEQUENCE_VARIATION_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCE_VARIATION_nsprefix_) else ''
            self.SEQUENCE_VARIATION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCE_VARIATION', pretty_print=pretty_print)
        if self.SEQUENCE_ASSEMBLY is not None:
            namespaceprefix_ = self.SEQUENCE_ASSEMBLY_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCE_ASSEMBLY_nsprefix_) else ''
            self.SEQUENCE_ASSEMBLY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCE_ASSEMBLY', pretty_print=pretty_print)
        if self.SEQUENCE_FLATFILE is not None:
            namespaceprefix_ = self.SEQUENCE_FLATFILE_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCE_FLATFILE_nsprefix_) else ''
            self.SEQUENCE_FLATFILE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCE_FLATFILE', pretty_print=pretty_print)
        if self.SEQUENCE_ANNOTATION is not None:
            namespaceprefix_ = self.SEQUENCE_ANNOTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.SEQUENCE_ANNOTATION_nsprefix_) else ''
            self.SEQUENCE_ANNOTATION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SEQUENCE_ANNOTATION', pretty_print=pretty_print)
        if self.REFERENCE_SEQUENCE is not None:
            namespaceprefix_ = self.REFERENCE_SEQUENCE_nsprefix_ + ':' if (UseCapturedNS_ and self.REFERENCE_SEQUENCE_nsprefix_) else ''
            self.REFERENCE_SEQUENCE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REFERENCE_SEQUENCE', pretty_print=pretty_print)
        if self.SAMPLE_PHENOTYPE is not None:
            namespaceprefix_ = self.SAMPLE_PHENOTYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_PHENOTYPE_nsprefix_) else ''
            self.SAMPLE_PHENOTYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_PHENOTYPE', pretty_print=pretty_print)
        if self.PROCESSED_READS is not None:
            namespaceprefix_ = self.PROCESSED_READS_nsprefix_ + ':' if (UseCapturedNS_ and self.PROCESSED_READS_nsprefix_) else ''
            self.PROCESSED_READS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROCESSED_READS', pretty_print=pretty_print)
        if self.GENOME_MAP is not None:
            namespaceprefix_ = self.GENOME_MAP_nsprefix_ + ':' if (UseCapturedNS_ and self.GENOME_MAP_nsprefix_) else ''
            self.GENOME_MAP.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GENOME_MAP', pretty_print=pretty_print)
        if self.AMR_ANTIBIOGRAM is not None:
            namespaceprefix_ = self.AMR_ANTIBIOGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.AMR_ANTIBIOGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAMR_ANTIBIOGRAM>%s</%sAMR_ANTIBIOGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AMR_ANTIBIOGRAM), input_name='AMR_ANTIBIOGRAM')), namespaceprefix_ , eol_))
        if self.PATHOGEN_ANALYSIS is not None:
            namespaceprefix_ = self.PATHOGEN_ANALYSIS_nsprefix_ + ':' if (UseCapturedNS_ and self.PATHOGEN_ANALYSIS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPATHOGEN_ANALYSIS>%s</%sPATHOGEN_ANALYSIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PATHOGEN_ANALYSIS), input_name='PATHOGEN_ANALYSIS')), namespaceprefix_ , eol_))
        if self.COVID19_CONSENSUS is not None:
            namespaceprefix_ = self.COVID19_CONSENSUS_nsprefix_ + ':' if (UseCapturedNS_ and self.COVID19_CONSENSUS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOVID19_CONSENSUS>%s</%sCOVID19_CONSENSUS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COVID19_CONSENSUS), input_name='COVID19_CONSENSUS')), namespaceprefix_ , eol_))
        if self.COVID19_FILTERED_VCF is not None:
            namespaceprefix_ = self.COVID19_FILTERED_VCF_nsprefix_ + ':' if (UseCapturedNS_ and self.COVID19_FILTERED_VCF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOVID19_FILTERED_VCF>%s</%sCOVID19_FILTERED_VCF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COVID19_FILTERED_VCF), input_name='COVID19_FILTERED_VCF')), namespaceprefix_ , eol_))
        if self.TRANSCRIPTOME_ASSEMBLY is not None:
            namespaceprefix_ = self.TRANSCRIPTOME_ASSEMBLY_nsprefix_ + ':' if (UseCapturedNS_ and self.TRANSCRIPTOME_ASSEMBLY_nsprefix_) else ''
            self.TRANSCRIPTOME_ASSEMBLY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TRANSCRIPTOME_ASSEMBLY', pretty_print=pretty_print)
        if self.TAXONOMIC_REFERENCE_SET is not None:
            namespaceprefix_ = self.TAXONOMIC_REFERENCE_SET_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXONOMIC_REFERENCE_SET_nsprefix_) else ''
            self.TAXONOMIC_REFERENCE_SET.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TAXONOMIC_REFERENCE_SET', pretty_print=pretty_print)
        if self.ASSEMBLY_ANNOTATION is not None:
            namespaceprefix_ = self.ASSEMBLY_ANNOTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_ANNOTATION_nsprefix_) else ''
            self.ASSEMBLY_ANNOTATION.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY_ANNOTATION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'REFERENCE_ALIGNMENT':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.REFERENCE_ALIGNMENT = obj_
            obj_.original_tagname_ = 'REFERENCE_ALIGNMENT'
        elif nodeName_ == 'SEQUENCE_VARIATION':
            obj_ = SEQUENCE_VARIATIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCE_VARIATION = obj_
            obj_.original_tagname_ = 'SEQUENCE_VARIATION'
        elif nodeName_ == 'SEQUENCE_ASSEMBLY':
            obj_ = SEQUENCE_ASSEMBLYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCE_ASSEMBLY = obj_
            obj_.original_tagname_ = 'SEQUENCE_ASSEMBLY'
        elif nodeName_ == 'SEQUENCE_FLATFILE':
            obj_ = SEQUENCE_FLATFILEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCE_FLATFILE = obj_
            obj_.original_tagname_ = 'SEQUENCE_FLATFILE'
        elif nodeName_ == 'SEQUENCE_ANNOTATION':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SEQUENCE_ANNOTATION = obj_
            obj_.original_tagname_ = 'SEQUENCE_ANNOTATION'
        elif nodeName_ == 'REFERENCE_SEQUENCE':
            obj_ = REFERENCE_SEQUENCEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.REFERENCE_SEQUENCE = obj_
            obj_.original_tagname_ = 'REFERENCE_SEQUENCE'
        elif nodeName_ == 'SAMPLE_PHENOTYPE':
            obj_ = SAMPLE_PHENOTYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_PHENOTYPE = obj_
            obj_.original_tagname_ = 'SAMPLE_PHENOTYPE'
        elif nodeName_ == 'PROCESSED_READS':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROCESSED_READS = obj_
            obj_.original_tagname_ = 'PROCESSED_READS'
        elif nodeName_ == 'GENOME_MAP':
            obj_ = GENOME_MAPType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GENOME_MAP = obj_
            obj_.original_tagname_ = 'GENOME_MAP'
        elif nodeName_ == 'AMR_ANTIBIOGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AMR_ANTIBIOGRAM')
            value_ = self.gds_validate_string(value_, node, 'AMR_ANTIBIOGRAM')
            self.AMR_ANTIBIOGRAM = value_
            self.AMR_ANTIBIOGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'PATHOGEN_ANALYSIS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PATHOGEN_ANALYSIS')
            value_ = self.gds_validate_string(value_, node, 'PATHOGEN_ANALYSIS')
            self.PATHOGEN_ANALYSIS = value_
            self.PATHOGEN_ANALYSIS_nsprefix_ = child_.prefix
        elif nodeName_ == 'COVID19_CONSENSUS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COVID19_CONSENSUS')
            value_ = self.gds_validate_string(value_, node, 'COVID19_CONSENSUS')
            self.COVID19_CONSENSUS = value_
            self.COVID19_CONSENSUS_nsprefix_ = child_.prefix
        elif nodeName_ == 'COVID19_FILTERED_VCF':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COVID19_FILTERED_VCF')
            value_ = self.gds_validate_string(value_, node, 'COVID19_FILTERED_VCF')
            self.COVID19_FILTERED_VCF = value_
            self.COVID19_FILTERED_VCF_nsprefix_ = child_.prefix
        elif nodeName_ == 'TRANSCRIPTOME_ASSEMBLY':
            obj_ = TRANSCRIPTOME_ASSEMBLYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TRANSCRIPTOME_ASSEMBLY = obj_
            obj_.original_tagname_ = 'TRANSCRIPTOME_ASSEMBLY'
        elif nodeName_ == 'TAXONOMIC_REFERENCE_SET':
            obj_ = TAXONOMIC_REFERENCE_SETType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TAXONOMIC_REFERENCE_SET = obj_
            obj_.original_tagname_ = 'TAXONOMIC_REFERENCE_SET'
        elif nodeName_ == 'ASSEMBLY_ANNOTATION':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY_ANNOTATION = obj_
            obj_.original_tagname_ = 'ASSEMBLY_ANNOTATION'
# end class ANALYSIS_TYPEType


class AMR_ANTIBIOGRAM(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AMR_ANTIBIOGRAM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AMR_ANTIBIOGRAM.subclass:
            return AMR_ANTIBIOGRAM.subclass(*args_, **kwargs_)
        else:
            return AMR_ANTIBIOGRAM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AMR_ANTIBIOGRAM', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AMR_ANTIBIOGRAM')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AMR_ANTIBIOGRAM':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AMR_ANTIBIOGRAM')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AMR_ANTIBIOGRAM', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AMR_ANTIBIOGRAM'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AMR_ANTIBIOGRAM', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AMR_ANTIBIOGRAM


class PATHOGEN_ANALYSIS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PATHOGEN_ANALYSIS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PATHOGEN_ANALYSIS.subclass:
            return PATHOGEN_ANALYSIS.subclass(*args_, **kwargs_)
        else:
            return PATHOGEN_ANALYSIS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PATHOGEN_ANALYSIS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PATHOGEN_ANALYSIS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PATHOGEN_ANALYSIS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PATHOGEN_ANALYSIS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PATHOGEN_ANALYSIS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PATHOGEN_ANALYSIS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PATHOGEN_ANALYSIS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PATHOGEN_ANALYSIS


class COVID19_CONSENSUS(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COVID19_CONSENSUS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COVID19_CONSENSUS.subclass:
            return COVID19_CONSENSUS.subclass(*args_, **kwargs_)
        else:
            return COVID19_CONSENSUS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COVID19_CONSENSUS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COVID19_CONSENSUS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COVID19_CONSENSUS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COVID19_CONSENSUS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COVID19_CONSENSUS', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COVID19_CONSENSUS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COVID19_CONSENSUS', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class COVID19_CONSENSUS


class COVID19_FILTERED_VCF(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COVID19_FILTERED_VCF)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COVID19_FILTERED_VCF.subclass:
            return COVID19_FILTERED_VCF.subclass(*args_, **kwargs_)
        else:
            return COVID19_FILTERED_VCF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COVID19_FILTERED_VCF', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COVID19_FILTERED_VCF')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COVID19_FILTERED_VCF':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COVID19_FILTERED_VCF')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COVID19_FILTERED_VCF', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COVID19_FILTERED_VCF'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COVID19_FILTERED_VCF', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class COVID19_FILTERED_VCF


class SEQUENCE_VARIATIONType(ReferenceSequenceType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReferenceSequenceType
    def __init__(self, ASSEMBLY=None, SEQUENCE=None, EXPERIMENT_TYPE=None, PROGRAM=None, PLATFORM=None, IMPUTATION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SEQUENCE_VARIATIONType"), self).__init__(ASSEMBLY, SEQUENCE,  **kwargs_)
        if EXPERIMENT_TYPE is None:
            self.EXPERIMENT_TYPE = []
        else:
            self.EXPERIMENT_TYPE = EXPERIMENT_TYPE
        self.EXPERIMENT_TYPE_nsprefix_ = None
        self.PROGRAM = PROGRAM
        self.PROGRAM_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.PLATFORM_nsprefix_ = None
        self.IMPUTATION = IMPUTATION
        self.IMPUTATION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEQUENCE_VARIATIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEQUENCE_VARIATIONType.subclass:
            return SEQUENCE_VARIATIONType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_VARIATIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EXPERIMENT_TYPE(self):
        return self.EXPERIMENT_TYPE
    def set_EXPERIMENT_TYPE(self, EXPERIMENT_TYPE):
        self.EXPERIMENT_TYPE = EXPERIMENT_TYPE
    def add_EXPERIMENT_TYPE(self, value):
        self.EXPERIMENT_TYPE.append(value)
    def insert_EXPERIMENT_TYPE_at(self, index, value):
        self.EXPERIMENT_TYPE.insert(index, value)
    def replace_EXPERIMENT_TYPE_at(self, index, value):
        self.EXPERIMENT_TYPE[index] = value
    def get_PROGRAM(self):
        return self.PROGRAM
    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_IMPUTATION(self):
        return self.IMPUTATION
    def set_IMPUTATION(self, IMPUTATION):
        self.IMPUTATION = IMPUTATION
    def validate_EXPERIMENT_TYPEType(self, value):
        result = True
        # Validate type EXPERIMENT_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Whole genome sequencing', 'Whole transcriptome sequencing', 'Exome sequencing', 'Genotyping by array', 'transcriptomics', 'Curation', 'Genotyping by sequencing', 'Target sequencing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on EXPERIMENT_TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.EXPERIMENT_TYPE or
            self.PROGRAM is not None or
            self.PLATFORM is not None or
            self.IMPUTATION is not None or
            super(SEQUENCE_VARIATIONType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_VARIATIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SEQUENCE_VARIATIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SEQUENCE_VARIATIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCE_VARIATIONType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SEQUENCE_VARIATIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SEQUENCE_VARIATIONType'):
        super(SEQUENCE_VARIATIONType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCE_VARIATIONType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_VARIATIONType', fromsubclass_=False, pretty_print=True):
        super(SEQUENCE_VARIATIONType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_TYPE_ in self.EXPERIMENT_TYPE:
            namespaceprefix_ = self.EXPERIMENT_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXPERIMENT_TYPE>%s</%sEXPERIMENT_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(EXPERIMENT_TYPE_), input_name='EXPERIMENT_TYPE')), namespaceprefix_ , eol_))
        if self.PROGRAM is not None:
            namespaceprefix_ = self.PROGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.PROGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROGRAM), input_name='PROGRAM')), namespaceprefix_ , eol_))
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PLATFORM), input_name='PLATFORM')), namespaceprefix_ , eol_))
        if self.IMPUTATION is not None:
            namespaceprefix_ = self.IMPUTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.IMPUTATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMPUTATION>%s</%sIMPUTATION>%s' % (namespaceprefix_ , self.gds_format_boolean(self.IMPUTATION, input_name='IMPUTATION'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SEQUENCE_VARIATIONType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EXPERIMENT_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EXPERIMENT_TYPE')
            value_ = self.gds_validate_string(value_, node, 'EXPERIMENT_TYPE')
            self.EXPERIMENT_TYPE.append(value_)
            self.EXPERIMENT_TYPE_nsprefix_ = child_.prefix
            # validate type EXPERIMENT_TYPEType
            self.validate_EXPERIMENT_TYPEType(self.EXPERIMENT_TYPE[-1])
        elif nodeName_ == 'PROGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROGRAM')
            value_ = self.gds_validate_string(value_, node, 'PROGRAM')
            self.PROGRAM = value_
            self.PROGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLATFORM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PLATFORM')
            value_ = self.gds_validate_string(value_, node, 'PLATFORM')
            self.PLATFORM = value_
            self.PLATFORM_nsprefix_ = child_.prefix
        elif nodeName_ == 'IMPUTATION':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'IMPUTATION')
            ival_ = self.gds_validate_boolean(ival_, node, 'IMPUTATION')
            self.IMPUTATION = ival_
            self.IMPUTATION_nsprefix_ = child_.prefix
        super(SEQUENCE_VARIATIONType, self)._buildChildren(child_, node, nodeName_, True)
# end class SEQUENCE_VARIATIONType


class SEQUENCE_ASSEMBLYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NAME=None, TYPE=None, PARTIAL=None, COVERAGE=None, PROGRAM=None, PLATFORM=None, MIN_GAP_LENGTH=None, MOL_TYPE=None, TPA=None, AUTHORS=None, ADDRESS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TYPE = TYPE
        self.validate_TYPEType19(self.TYPE)
        self.TYPE_nsprefix_ = None
        self.PARTIAL = PARTIAL
        self.PARTIAL_nsprefix_ = None
        self.COVERAGE = COVERAGE
        self.COVERAGE_nsprefix_ = None
        self.PROGRAM = PROGRAM
        self.PROGRAM_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.PLATFORM_nsprefix_ = None
        self.MIN_GAP_LENGTH = MIN_GAP_LENGTH
        self.MIN_GAP_LENGTH_nsprefix_ = None
        self.MOL_TYPE = MOL_TYPE
        self.validate_MOL_TYPEType(self.MOL_TYPE)
        self.MOL_TYPE_nsprefix_ = None
        self.TPA = TPA
        self.TPA_nsprefix_ = None
        self.AUTHORS = AUTHORS
        self.AUTHORS_nsprefix_ = None
        self.ADDRESS = ADDRESS
        self.ADDRESS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEQUENCE_ASSEMBLYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEQUENCE_ASSEMBLYType.subclass:
            return SEQUENCE_ASSEMBLYType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_ASSEMBLYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def get_PARTIAL(self):
        return self.PARTIAL
    def set_PARTIAL(self, PARTIAL):
        self.PARTIAL = PARTIAL
    def get_COVERAGE(self):
        return self.COVERAGE
    def set_COVERAGE(self, COVERAGE):
        self.COVERAGE = COVERAGE
    def get_PROGRAM(self):
        return self.PROGRAM
    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_MIN_GAP_LENGTH(self):
        return self.MIN_GAP_LENGTH
    def set_MIN_GAP_LENGTH(self, MIN_GAP_LENGTH):
        self.MIN_GAP_LENGTH = MIN_GAP_LENGTH
    def get_MOL_TYPE(self):
        return self.MOL_TYPE
    def set_MOL_TYPE(self, MOL_TYPE):
        self.MOL_TYPE = MOL_TYPE
    def get_TPA(self):
        return self.TPA
    def set_TPA(self, TPA):
        self.TPA = TPA
    def get_AUTHORS(self):
        return self.AUTHORS
    def set_AUTHORS(self, AUTHORS):
        self.AUTHORS = AUTHORS
    def get_ADDRESS(self):
        return self.ADDRESS
    def set_ADDRESS(self, ADDRESS):
        self.ADDRESS = ADDRESS
    def validate_TYPEType19(self, value):
        result = True
        # Validate type TYPEType19, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['clone or isolate', 'primary metagenome', 'binned metagenome', 'Metagenome-Assembled Genome (MAG)', 'Environmental Single-Cell Amplified Genome (SAG)', 'COVID-19 outbreak', 'clinical isolate assembly']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TYPEType19' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_MOL_TYPEType(self, value):
        result = True
        # Validate type MOL_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['genomic DNA', 'genomic RNA', 'viral cRNA']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MOL_TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.TYPE is not None or
            self.PARTIAL is not None or
            self.COVERAGE is not None or
            self.PROGRAM is not None or
            self.PLATFORM is not None or
            self.MIN_GAP_LENGTH is not None or
            self.MOL_TYPE is not None or
            self.TPA is not None or
            self.AUTHORS is not None or
            self.ADDRESS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_ASSEMBLYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SEQUENCE_ASSEMBLYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SEQUENCE_ASSEMBLYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCE_ASSEMBLYType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SEQUENCE_ASSEMBLYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SEQUENCE_ASSEMBLYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_ASSEMBLYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
        if self.PARTIAL is not None:
            namespaceprefix_ = self.PARTIAL_nsprefix_ + ':' if (UseCapturedNS_ and self.PARTIAL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARTIAL>%s</%sPARTIAL>%s' % (namespaceprefix_ , self.gds_format_boolean(self.PARTIAL, input_name='PARTIAL'), namespaceprefix_ , eol_))
        if self.COVERAGE is not None:
            namespaceprefix_ = self.COVERAGE_nsprefix_ + ':' if (UseCapturedNS_ and self.COVERAGE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOVERAGE>%s</%sCOVERAGE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COVERAGE), input_name='COVERAGE')), namespaceprefix_ , eol_))
        if self.PROGRAM is not None:
            namespaceprefix_ = self.PROGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.PROGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROGRAM), input_name='PROGRAM')), namespaceprefix_ , eol_))
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PLATFORM), input_name='PLATFORM')), namespaceprefix_ , eol_))
        if self.MIN_GAP_LENGTH is not None:
            namespaceprefix_ = self.MIN_GAP_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.MIN_GAP_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMIN_GAP_LENGTH>%s</%sMIN_GAP_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.MIN_GAP_LENGTH, input_name='MIN_GAP_LENGTH'), namespaceprefix_ , eol_))
        if self.MOL_TYPE is not None:
            namespaceprefix_ = self.MOL_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.MOL_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMOL_TYPE>%s</%sMOL_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.MOL_TYPE), input_name='MOL_TYPE')), namespaceprefix_ , eol_))
        if self.TPA is not None:
            namespaceprefix_ = self.TPA_nsprefix_ + ':' if (UseCapturedNS_ and self.TPA_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTPA>%s</%sTPA>%s' % (namespaceprefix_ , self.gds_format_boolean(self.TPA, input_name='TPA'), namespaceprefix_ , eol_))
        if self.AUTHORS is not None:
            namespaceprefix_ = self.AUTHORS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTHORS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTHORS>%s</%sAUTHORS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTHORS), input_name='AUTHORS')), namespaceprefix_ , eol_))
        if self.ADDRESS is not None:
            namespaceprefix_ = self.ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sADDRESS>%s</%sADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ADDRESS), input_name='ADDRESS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
            # validate type TYPEType19
            self.validate_TYPEType19(self.TYPE)
        elif nodeName_ == 'PARTIAL':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'PARTIAL')
            ival_ = self.gds_validate_boolean(ival_, node, 'PARTIAL')
            self.PARTIAL = ival_
            self.PARTIAL_nsprefix_ = child_.prefix
        elif nodeName_ == 'COVERAGE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COVERAGE')
            value_ = self.gds_validate_string(value_, node, 'COVERAGE')
            self.COVERAGE = value_
            self.COVERAGE_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROGRAM')
            value_ = self.gds_validate_string(value_, node, 'PROGRAM')
            self.PROGRAM = value_
            self.PROGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLATFORM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PLATFORM')
            value_ = self.gds_validate_string(value_, node, 'PLATFORM')
            self.PLATFORM = value_
            self.PLATFORM_nsprefix_ = child_.prefix
        elif nodeName_ == 'MIN_GAP_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MIN_GAP_LENGTH')
            ival_ = self.gds_validate_integer(ival_, node, 'MIN_GAP_LENGTH')
            self.MIN_GAP_LENGTH = ival_
            self.MIN_GAP_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'MOL_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'MOL_TYPE')
            value_ = self.gds_validate_string(value_, node, 'MOL_TYPE')
            self.MOL_TYPE = value_
            self.MOL_TYPE_nsprefix_ = child_.prefix
            # validate type MOL_TYPEType
            self.validate_MOL_TYPEType(self.MOL_TYPE)
        elif nodeName_ == 'TPA':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'TPA')
            ival_ = self.gds_validate_boolean(ival_, node, 'TPA')
            self.TPA = ival_
            self.TPA_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTHORS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTHORS')
            value_ = self.gds_validate_string(value_, node, 'AUTHORS')
            self.AUTHORS = value_
            self.AUTHORS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'ADDRESS')
            self.ADDRESS = value_
            self.ADDRESS_nsprefix_ = child_.prefix
# end class SEQUENCE_ASSEMBLYType


class SEQUENCE_FLATFILEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, AUTHORS=None, ADDRESS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.AUTHORS = AUTHORS
        self.AUTHORS_nsprefix_ = None
        self.ADDRESS = ADDRESS
        self.ADDRESS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEQUENCE_FLATFILEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEQUENCE_FLATFILEType.subclass:
            return SEQUENCE_FLATFILEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_FLATFILEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AUTHORS(self):
        return self.AUTHORS
    def set_AUTHORS(self, AUTHORS):
        self.AUTHORS = AUTHORS
    def get_ADDRESS(self):
        return self.ADDRESS
    def set_ADDRESS(self, ADDRESS):
        self.ADDRESS = ADDRESS
    def _hasContent(self):
        if (
            self.AUTHORS is not None or
            self.ADDRESS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_FLATFILEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SEQUENCE_FLATFILEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SEQUENCE_FLATFILEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCE_FLATFILEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SEQUENCE_FLATFILEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SEQUENCE_FLATFILEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCE_FLATFILEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AUTHORS is not None:
            namespaceprefix_ = self.AUTHORS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTHORS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTHORS>%s</%sAUTHORS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTHORS), input_name='AUTHORS')), namespaceprefix_ , eol_))
        if self.ADDRESS is not None:
            namespaceprefix_ = self.ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sADDRESS>%s</%sADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ADDRESS), input_name='ADDRESS')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AUTHORS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTHORS')
            value_ = self.gds_validate_string(value_, node, 'AUTHORS')
            self.AUTHORS = value_
            self.AUTHORS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'ADDRESS')
            self.ADDRESS = value_
            self.ADDRESS_nsprefix_ = child_.prefix
# end class SEQUENCE_FLATFILEType


class REFERENCE_SEQUENCEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REFERENCE_SEQUENCEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REFERENCE_SEQUENCEType.subclass:
            return REFERENCE_SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return REFERENCE_SEQUENCEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REFERENCE_SEQUENCEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REFERENCE_SEQUENCEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REFERENCE_SEQUENCEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REFERENCE_SEQUENCEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='REFERENCE_SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REFERENCE_SEQUENCEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REFERENCE_SEQUENCEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class REFERENCE_SEQUENCEType


class SAMPLE_PHENOTYPEType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_PHENOTYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_PHENOTYPEType.subclass:
            return SAMPLE_PHENOTYPEType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_PHENOTYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_PHENOTYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_PHENOTYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_PHENOTYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_PHENOTYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_PHENOTYPEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_PHENOTYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_PHENOTYPEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SAMPLE_PHENOTYPEType


class GENOME_MAPType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, PROGRAM=None, PLATFORM=None, DESCRIPTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.PROGRAM = PROGRAM
        self.PROGRAM_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.validate_PLATFORMType(self.PLATFORM)
        self.PLATFORM_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GENOME_MAPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GENOME_MAPType.subclass:
            return GENOME_MAPType.subclass(*args_, **kwargs_)
        else:
            return GENOME_MAPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROGRAM(self):
        return self.PROGRAM
    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def validate_PLATFORMType(self, value):
        result = True
        # Validate type PLATFORMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BioNano']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on PLATFORMType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.PROGRAM is not None or
            self.PLATFORM is not None or
            self.DESCRIPTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GENOME_MAPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GENOME_MAPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GENOME_MAPType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GENOME_MAPType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GENOME_MAPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GENOME_MAPType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='GENOME_MAPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PROGRAM is not None:
            namespaceprefix_ = self.PROGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.PROGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROGRAM), input_name='PROGRAM')), namespaceprefix_ , eol_))
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PLATFORM), input_name='PLATFORM')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROGRAM')
            value_ = self.gds_validate_string(value_, node, 'PROGRAM')
            self.PROGRAM = value_
            self.PROGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLATFORM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PLATFORM')
            value_ = self.gds_validate_string(value_, node, 'PLATFORM')
            self.PLATFORM = value_
            self.PLATFORM_nsprefix_ = child_.prefix
            # validate type PLATFORMType
            self.validate_PLATFORMType(self.PLATFORM)
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
# end class GENOME_MAPType


class TRANSCRIPTOME_ASSEMBLYType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NAME=None, PROGRAM=None, PLATFORM=None, TPA=None, AUTHORS=None, ADDRESS=None, TYPE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.PROGRAM = PROGRAM
        self.PROGRAM_nsprefix_ = None
        self.PLATFORM = PLATFORM
        self.PLATFORM_nsprefix_ = None
        self.TPA = TPA
        self.TPA_nsprefix_ = None
        self.AUTHORS = AUTHORS
        self.AUTHORS_nsprefix_ = None
        self.ADDRESS = ADDRESS
        self.ADDRESS_nsprefix_ = None
        self.TYPE = TYPE
        self.validate_TYPEType20(self.TYPE)
        self.TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRANSCRIPTOME_ASSEMBLYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRANSCRIPTOME_ASSEMBLYType.subclass:
            return TRANSCRIPTOME_ASSEMBLYType.subclass(*args_, **kwargs_)
        else:
            return TRANSCRIPTOME_ASSEMBLYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_PROGRAM(self):
        return self.PROGRAM
    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM
    def get_PLATFORM(self):
        return self.PLATFORM
    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM
    def get_TPA(self):
        return self.TPA
    def set_TPA(self, TPA):
        self.TPA = TPA
    def get_AUTHORS(self):
        return self.AUTHORS
    def set_AUTHORS(self, AUTHORS):
        self.AUTHORS = AUTHORS
    def get_ADDRESS(self):
        return self.ADDRESS
    def set_ADDRESS(self, ADDRESS):
        self.ADDRESS = ADDRESS
    def get_TYPE(self):
        return self.TYPE
    def set_TYPE(self, TYPE):
        self.TYPE = TYPE
    def validate_TYPEType20(self, value):
        result = True
        # Validate type TYPEType20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['isolate', 'metatranscriptome']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TYPEType20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.PROGRAM is not None or
            self.PLATFORM is not None or
            self.TPA is not None or
            self.AUTHORS is not None or
            self.ADDRESS is not None or
            self.TYPE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TRANSCRIPTOME_ASSEMBLYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRANSCRIPTOME_ASSEMBLYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TRANSCRIPTOME_ASSEMBLYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRANSCRIPTOME_ASSEMBLYType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRANSCRIPTOME_ASSEMBLYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TRANSCRIPTOME_ASSEMBLYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TRANSCRIPTOME_ASSEMBLYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.PROGRAM is not None:
            namespaceprefix_ = self.PROGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.PROGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROGRAM), input_name='PROGRAM')), namespaceprefix_ , eol_))
        if self.PLATFORM is not None:
            namespaceprefix_ = self.PLATFORM_nsprefix_ + ':' if (UseCapturedNS_ and self.PLATFORM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PLATFORM), input_name='PLATFORM')), namespaceprefix_ , eol_))
        if self.TPA is not None:
            namespaceprefix_ = self.TPA_nsprefix_ + ':' if (UseCapturedNS_ and self.TPA_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTPA>%s</%sTPA>%s' % (namespaceprefix_ , self.gds_format_boolean(self.TPA, input_name='TPA'), namespaceprefix_ , eol_))
        if self.AUTHORS is not None:
            namespaceprefix_ = self.AUTHORS_nsprefix_ + ':' if (UseCapturedNS_ and self.AUTHORS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAUTHORS>%s</%sAUTHORS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AUTHORS), input_name='AUTHORS')), namespaceprefix_ , eol_))
        if self.ADDRESS is not None:
            namespaceprefix_ = self.ADDRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.ADDRESS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sADDRESS>%s</%sADDRESS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ADDRESS), input_name='ADDRESS')), namespaceprefix_ , eol_))
        if self.TYPE is not None:
            namespaceprefix_ = self.TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTYPE>%s</%sTYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TYPE), input_name='TYPE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROGRAM')
            value_ = self.gds_validate_string(value_, node, 'PROGRAM')
            self.PROGRAM = value_
            self.PROGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'PLATFORM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PLATFORM')
            value_ = self.gds_validate_string(value_, node, 'PLATFORM')
            self.PLATFORM = value_
            self.PLATFORM_nsprefix_ = child_.prefix
        elif nodeName_ == 'TPA':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'TPA')
            ival_ = self.gds_validate_boolean(ival_, node, 'TPA')
            self.TPA = ival_
            self.TPA_nsprefix_ = child_.prefix
        elif nodeName_ == 'AUTHORS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'AUTHORS')
            value_ = self.gds_validate_string(value_, node, 'AUTHORS')
            self.AUTHORS = value_
            self.AUTHORS_nsprefix_ = child_.prefix
        elif nodeName_ == 'ADDRESS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ADDRESS')
            value_ = self.gds_validate_string(value_, node, 'ADDRESS')
            self.ADDRESS = value_
            self.ADDRESS_nsprefix_ = child_.prefix
        elif nodeName_ == 'TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TYPE')
            value_ = self.gds_validate_string(value_, node, 'TYPE')
            self.TYPE = value_
            self.TYPE_nsprefix_ = child_.prefix
            # validate type TYPEType20
            self.validate_TYPEType20(self.TYPE)
# end class TRANSCRIPTOME_ASSEMBLYType


class TAXONOMIC_REFERENCE_SETType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NAME=None, TAXONOMY_SYSTEM=None, TAXONOMY_SYSTEM_VERSION=None, CUSTOM_FIELDS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TAXONOMY_SYSTEM = TAXONOMY_SYSTEM
        self.TAXONOMY_SYSTEM_nsprefix_ = None
        self.TAXONOMY_SYSTEM_VERSION = TAXONOMY_SYSTEM_VERSION
        self.TAXONOMY_SYSTEM_VERSION_nsprefix_ = None
        self.CUSTOM_FIELDS = CUSTOM_FIELDS
        self.CUSTOM_FIELDS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TAXONOMIC_REFERENCE_SETType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TAXONOMIC_REFERENCE_SETType.subclass:
            return TAXONOMIC_REFERENCE_SETType.subclass(*args_, **kwargs_)
        else:
            return TAXONOMIC_REFERENCE_SETType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TAXONOMY_SYSTEM(self):
        return self.TAXONOMY_SYSTEM
    def set_TAXONOMY_SYSTEM(self, TAXONOMY_SYSTEM):
        self.TAXONOMY_SYSTEM = TAXONOMY_SYSTEM
    def get_TAXONOMY_SYSTEM_VERSION(self):
        return self.TAXONOMY_SYSTEM_VERSION
    def set_TAXONOMY_SYSTEM_VERSION(self, TAXONOMY_SYSTEM_VERSION):
        self.TAXONOMY_SYSTEM_VERSION = TAXONOMY_SYSTEM_VERSION
    def get_CUSTOM_FIELDS(self):
        return self.CUSTOM_FIELDS
    def set_CUSTOM_FIELDS(self, CUSTOM_FIELDS):
        self.CUSTOM_FIELDS = CUSTOM_FIELDS
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.TAXONOMY_SYSTEM is not None or
            self.TAXONOMY_SYSTEM_VERSION is not None or
            self.CUSTOM_FIELDS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXONOMIC_REFERENCE_SETType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TAXONOMIC_REFERENCE_SETType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TAXONOMIC_REFERENCE_SETType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TAXONOMIC_REFERENCE_SETType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TAXONOMIC_REFERENCE_SETType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TAXONOMIC_REFERENCE_SETType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TAXONOMIC_REFERENCE_SETType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TAXONOMY_SYSTEM is not None:
            namespaceprefix_ = self.TAXONOMY_SYSTEM_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXONOMY_SYSTEM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXONOMY_SYSTEM>%s</%sTAXONOMY_SYSTEM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TAXONOMY_SYSTEM), input_name='TAXONOMY_SYSTEM')), namespaceprefix_ , eol_))
        if self.TAXONOMY_SYSTEM_VERSION is not None:
            namespaceprefix_ = self.TAXONOMY_SYSTEM_VERSION_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXONOMY_SYSTEM_VERSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXONOMY_SYSTEM_VERSION>%s</%sTAXONOMY_SYSTEM_VERSION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TAXONOMY_SYSTEM_VERSION), input_name='TAXONOMY_SYSTEM_VERSION')), namespaceprefix_ , eol_))
        if self.CUSTOM_FIELDS is not None:
            namespaceprefix_ = self.CUSTOM_FIELDS_nsprefix_ + ':' if (UseCapturedNS_ and self.CUSTOM_FIELDS_nsprefix_) else ''
            self.CUSTOM_FIELDS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CUSTOM_FIELDS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TAXONOMY_SYSTEM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TAXONOMY_SYSTEM')
            value_ = self.gds_validate_string(value_, node, 'TAXONOMY_SYSTEM')
            self.TAXONOMY_SYSTEM = value_
            self.TAXONOMY_SYSTEM_nsprefix_ = child_.prefix
        elif nodeName_ == 'TAXONOMY_SYSTEM_VERSION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TAXONOMY_SYSTEM_VERSION')
            value_ = self.gds_validate_string(value_, node, 'TAXONOMY_SYSTEM_VERSION')
            self.TAXONOMY_SYSTEM_VERSION = value_
            self.TAXONOMY_SYSTEM_VERSION_nsprefix_ = child_.prefix
        elif nodeName_ == 'CUSTOM_FIELDS':
            obj_ = CUSTOM_FIELDSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CUSTOM_FIELDS = obj_
            obj_.original_tagname_ = 'CUSTOM_FIELDS'
# end class TAXONOMIC_REFERENCE_SETType


class CUSTOM_FIELDSType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FIELD=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FIELD is None:
            self.FIELD = []
        else:
            self.FIELD = FIELD
        self.FIELD_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUSTOM_FIELDSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUSTOM_FIELDSType.subclass:
            return CUSTOM_FIELDSType.subclass(*args_, **kwargs_)
        else:
            return CUSTOM_FIELDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FIELD(self):
        return self.FIELD
    def set_FIELD(self, FIELD):
        self.FIELD = FIELD
    def add_FIELD(self, value):
        self.FIELD.append(value)
    def insert_FIELD_at(self, index, value):
        self.FIELD.insert(index, value)
    def replace_FIELD_at(self, index, value):
        self.FIELD[index] = value
    def _hasContent(self):
        if (
            self.FIELD
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CUSTOM_FIELDSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUSTOM_FIELDSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUSTOM_FIELDSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUSTOM_FIELDSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUSTOM_FIELDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CUSTOM_FIELDSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CUSTOM_FIELDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FIELD_ in self.FIELD:
            namespaceprefix_ = self.FIELD_nsprefix_ + ':' if (UseCapturedNS_ and self.FIELD_nsprefix_) else ''
            FIELD_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FIELD', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FIELD':
            obj_ = FIELDType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FIELD.append(obj_)
            obj_.original_tagname_ = 'FIELD'
# end class CUSTOM_FIELDSType


class FIELDType21(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NAME=None, DESCRIPTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FIELDType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FIELDType21.subclass:
            return FIELDType21.subclass(*args_, **kwargs_)
        else:
            return FIELDType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.DESCRIPTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELDType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FIELDType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FIELDType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FIELDType21')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FIELDType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FIELDType21'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FIELDType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
# end class FIELDType21


class NAME(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NAME)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NAME.subclass:
            return NAME.subclass(*args_, **kwargs_)
        else:
            return NAME(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NAME', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NAME')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NAME':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NAME')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NAME', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NAME'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NAME', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class NAME


class DESCRIPTION(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESCRIPTION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESCRIPTION.subclass:
            return DESCRIPTION.subclass(*args_, **kwargs_)
        else:
            return DESCRIPTION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTION', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DESCRIPTION')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DESCRIPTION':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DESCRIPTION')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DESCRIPTION', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DESCRIPTION'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTION', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DESCRIPTION


class FILESType22(GeneratedsSuper):
    """FILESType22 -- Files associated with the
    analysis.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FILE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE
        self.FILE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILESType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILESType22.subclass:
            return FILESType22.subclass(*args_, **kwargs_)
        else:
            return FILESType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FILE(self):
        return self.FILE
    def set_FILE(self, FILE):
        self.FILE = FILE
    def add_FILE(self, value):
        self.FILE.append(value)
    def insert_FILE_at(self, index, value):
        self.FILE.insert(index, value)
    def replace_FILE_at(self, index, value):
        self.FILE[index] = value
    def _hasContent(self):
        if (
            self.FILE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILESType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FILESType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILESType22')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILESType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILESType22'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            namespaceprefix_ = self.FILE_nsprefix_ + ':' if (UseCapturedNS_ and self.FILE_nsprefix_) else ''
            FILE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FILE':
            obj_ = AnalysisFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'
# end class FILESType22


class ANALYSIS_LINKSType(GeneratedsSuper):
    """ANALYSIS_LINKSType --  Links to resources related to this analysis.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANALYSIS_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANALYSIS_LINK is None:
            self.ANALYSIS_LINK = []
        else:
            self.ANALYSIS_LINK = ANALYSIS_LINK
        self.ANALYSIS_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANALYSIS_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANALYSIS_LINKSType.subclass:
            return ANALYSIS_LINKSType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANALYSIS_LINK(self):
        return self.ANALYSIS_LINK
    def set_ANALYSIS_LINK(self, ANALYSIS_LINK):
        self.ANALYSIS_LINK = ANALYSIS_LINK
    def add_ANALYSIS_LINK(self, value):
        self.ANALYSIS_LINK.append(value)
    def insert_ANALYSIS_LINK_at(self, index, value):
        self.ANALYSIS_LINK.insert(index, value)
    def replace_ANALYSIS_LINK_at(self, index, value):
        self.ANALYSIS_LINK[index] = value
    def _hasContent(self):
        if (
            self.ANALYSIS_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANALYSIS_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANALYSIS_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANALYSIS_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANALYSIS_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_LINK_ in self.ANALYSIS_LINK:
            namespaceprefix_ = self.ANALYSIS_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_LINK_nsprefix_) else ''
            ANALYSIS_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANALYSIS_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_LINK.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_LINK'
# end class ANALYSIS_LINKSType


class ANALYSIS_ATTRIBUTESType(GeneratedsSuper):
    """ANALYSIS_ATTRIBUTESType -- Properties and attributes of an analysis. These can be
    entered as free-form tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ANALYSIS_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ANALYSIS_ATTRIBUTE is None:
            self.ANALYSIS_ATTRIBUTE = []
        else:
            self.ANALYSIS_ATTRIBUTE = ANALYSIS_ATTRIBUTE
        self.ANALYSIS_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ANALYSIS_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ANALYSIS_ATTRIBUTESType.subclass:
            return ANALYSIS_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ANALYSIS_ATTRIBUTE(self):
        return self.ANALYSIS_ATTRIBUTE
    def set_ANALYSIS_ATTRIBUTE(self, ANALYSIS_ATTRIBUTE):
        self.ANALYSIS_ATTRIBUTE = ANALYSIS_ATTRIBUTE
    def add_ANALYSIS_ATTRIBUTE(self, value):
        self.ANALYSIS_ATTRIBUTE.append(value)
    def insert_ANALYSIS_ATTRIBUTE_at(self, index, value):
        self.ANALYSIS_ATTRIBUTE.insert(index, value)
    def replace_ANALYSIS_ATTRIBUTE_at(self, index, value):
        self.ANALYSIS_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.ANALYSIS_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ANALYSIS_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ANALYSIS_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ANALYSIS_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ANALYSIS_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ANALYSIS_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ANALYSIS_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_ATTRIBUTE_ in self.ANALYSIS_ATTRIBUTE:
            namespaceprefix_ = self.ANALYSIS_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_ATTRIBUTE_nsprefix_) else ''
            ANALYSIS_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ANALYSIS_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_ATTRIBUTE'
# end class ANALYSIS_ATTRIBUTESType


class URL_LINKType(GeneratedsSuper):
    """LABEL --
    Text label to display for the link.

    * URL --  The internet service link (file:, http:, ftp: etc).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL_LINKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL_LINKType.subclass:
            return URL_LINKType.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL_LINKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL_LINKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URL_LINKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL_LINKType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='URL_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URL_LINKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
# end class URL_LINKType


class ENTREZ_LINKType(GeneratedsSuper):
    """DB --
    NCBI controlled vocabulary of permitted cross references.  Please see http://www.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi? .

    * ID --
      Numeric record id meaningful to the NCBI Entrez system.

    * QUERY --
      Accession string meaningful to the NCBI Entrez system.

    * LABEL --
      How to label the link.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, QUERY=None, LABEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DB = DB
        self.DB_nsprefix_ = None
        self.ID = ID
        self.ID_nsprefix_ = None
        self.QUERY = QUERY
        self.QUERY_nsprefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENTREZ_LINKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENTREZ_LINKType.subclass:
            return ENTREZ_LINKType.subclass(*args_, **kwargs_)
        else:
            return ENTREZ_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DB(self):
        return self.DB
    def set_DB(self, DB):
        self.DB = DB
    def get_ID(self):
        return self.ID
    def set_ID(self, ID):
        self.ID = ID
    def get_QUERY(self):
        return self.QUERY
    def set_QUERY(self, QUERY):
        self.QUERY = QUERY
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def _hasContent(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.QUERY is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENTREZ_LINKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENTREZ_LINKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ENTREZ_LINKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ENTREZ_LINKType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ENTREZ_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ENTREZ_LINKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ENTREZ_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            namespaceprefix_ = self.DB_nsprefix_ + ':' if (UseCapturedNS_ and self.DB_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DB), input_name='DB')), namespaceprefix_ , eol_))
        if self.ID is not None:
            namespaceprefix_ = self.ID_nsprefix_ + ':' if (UseCapturedNS_ and self.ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespaceprefix_ , self.gds_format_integer(self.ID, input_name='ID'), namespaceprefix_ , eol_))
        if self.QUERY is not None:
            namespaceprefix_ = self.QUERY_nsprefix_ + ':' if (UseCapturedNS_ and self.QUERY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQUERY>%s</%sQUERY>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.QUERY), input_name='QUERY')), namespaceprefix_ , eol_))
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DB':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DB')
            value_ = self.gds_validate_string(value_, node, 'DB')
            self.DB = value_
            self.DB_nsprefix_ = child_.prefix
        elif nodeName_ == 'ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ID')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
            self.ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'QUERY':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'QUERY')
            value_ = self.gds_validate_string(value_, node, 'QUERY')
            self.QUERY = value_
            self.QUERY_nsprefix_ = child_.prefix
        elif nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
# end class ENTREZ_LINKType


class SPOT_DECODE_SPECType(GeneratedsSuper):
    """SPOT_LENGTH --  Number of base/color calls, cycles, or flows per
    spot (raw sequence length or flow length including all
    application and technical tags and mate pairs, but not including
    gap lengths). This value will be platform dependent, library
    dependent, and possibly run dependent. Variable length platforms
    will still have a constant flow/cycle length.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SPOT_LENGTH=None, READ_SPEC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SPOT_LENGTH = SPOT_LENGTH
        self.SPOT_LENGTH_nsprefix_ = None
        if READ_SPEC is None:
            self.READ_SPEC = []
        else:
            self.READ_SPEC = READ_SPEC
        self.READ_SPEC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPOT_DECODE_SPECType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPOT_DECODE_SPECType.subclass:
            return SPOT_DECODE_SPECType.subclass(*args_, **kwargs_)
        else:
            return SPOT_DECODE_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SPOT_LENGTH(self):
        return self.SPOT_LENGTH
    def set_SPOT_LENGTH(self, SPOT_LENGTH):
        self.SPOT_LENGTH = SPOT_LENGTH
    def get_READ_SPEC(self):
        return self.READ_SPEC
    def set_READ_SPEC(self, READ_SPEC):
        self.READ_SPEC = READ_SPEC
    def add_READ_SPEC(self, value):
        self.READ_SPEC.append(value)
    def insert_READ_SPEC_at(self, index, value):
        self.READ_SPEC.insert(index, value)
    def replace_READ_SPEC_at(self, index, value):
        self.READ_SPEC[index] = value
    def _hasContent(self):
        if (
            self.SPOT_LENGTH is not None or
            self.READ_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPOT_DECODE_SPECType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SPOT_DECODE_SPECType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SPOT_DECODE_SPECType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SPOT_DECODE_SPECType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SPOT_DECODE_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SPOT_DECODE_SPECType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SPOT_DECODE_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_LENGTH is not None:
            namespaceprefix_ = self.SPOT_LENGTH_nsprefix_ + ':' if (UseCapturedNS_ and self.SPOT_LENGTH_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPOT_LENGTH>%s</%sSPOT_LENGTH>%s' % (namespaceprefix_ , self.gds_format_integer(self.SPOT_LENGTH, input_name='SPOT_LENGTH'), namespaceprefix_ , eol_))
        for READ_SPEC_ in self.READ_SPEC:
            namespaceprefix_ = self.READ_SPEC_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_SPEC_nsprefix_) else ''
            READ_SPEC_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='READ_SPEC', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SPOT_LENGTH' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'SPOT_LENGTH')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SPOT_LENGTH')
            self.SPOT_LENGTH = ival_
            self.SPOT_LENGTH_nsprefix_ = child_.prefix
        elif nodeName_ == 'READ_SPEC':
            obj_ = READ_SPECType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.READ_SPEC.append(obj_)
            obj_.original_tagname_ = 'READ_SPEC'
# end class SPOT_DECODE_SPECType


class READ_SPECType(GeneratedsSuper):
    """READ_SPECType --
    There are various methods to ordering the reads on the spot.

    * READ_INDEX -- READ_INDEX starts at 0 and is incrementally increased for each sequential READ_SPEC within a SPOT_DECODE_SPEC
    * READ_LABEL -- READ_LABEL is a name for this tag, and can be used to on output to determine read name, for example F or R.
    * RELATIVE_ORDER --
      The read is located beginning at the offset or cycle relative to another read.
      This choice is appropriate for example when specifying a read
      that follows a variable length expected sequence(s).

    * BASE_COORD --
      The location of the read start in terms of base count (1 is beginning of spot).

    * EXPECTED_BASECALL_TABLE --
      A set of choices of expected basecalls for a current read. Read will be zero-length if none is found.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, READ_INDEX=None, READ_LABEL=None, READ_CLASS=None, READ_TYPE='Forward', RELATIVE_ORDER=None, BASE_COORD=None, EXPECTED_BASECALL_TABLE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.READ_INDEX = READ_INDEX
        self.READ_INDEX_nsprefix_ = None
        self.READ_LABEL = READ_LABEL
        self.READ_LABEL_nsprefix_ = None
        self.READ_CLASS = READ_CLASS
        self.validate_READ_CLASSType(self.READ_CLASS)
        self.READ_CLASS_nsprefix_ = None
        self.READ_TYPE = READ_TYPE
        self.validate_READ_TYPEType(self.READ_TYPE)
        self.READ_TYPE_nsprefix_ = None
        self.RELATIVE_ORDER = RELATIVE_ORDER
        self.RELATIVE_ORDER_nsprefix_ = None
        self.BASE_COORD = BASE_COORD
        self.BASE_COORD_nsprefix_ = None
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
        self.EXPECTED_BASECALL_TABLE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, READ_SPECType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if READ_SPECType.subclass:
            return READ_SPECType.subclass(*args_, **kwargs_)
        else:
            return READ_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_READ_INDEX(self):
        return self.READ_INDEX
    def set_READ_INDEX(self, READ_INDEX):
        self.READ_INDEX = READ_INDEX
    def get_READ_LABEL(self):
        return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL):
        self.READ_LABEL = READ_LABEL
    def get_READ_CLASS(self):
        return self.READ_CLASS
    def set_READ_CLASS(self, READ_CLASS):
        self.READ_CLASS = READ_CLASS
    def get_READ_TYPE(self):
        return self.READ_TYPE
    def set_READ_TYPE(self, READ_TYPE):
        self.READ_TYPE = READ_TYPE
    def get_RELATIVE_ORDER(self):
        return self.RELATIVE_ORDER
    def set_RELATIVE_ORDER(self, RELATIVE_ORDER):
        self.RELATIVE_ORDER = RELATIVE_ORDER
    def get_BASE_COORD(self):
        return self.BASE_COORD
    def set_BASE_COORD(self, BASE_COORD):
        self.BASE_COORD = BASE_COORD
    def get_EXPECTED_BASECALL_TABLE(self):
        return self.EXPECTED_BASECALL_TABLE
    def set_EXPECTED_BASECALL_TABLE(self, EXPECTED_BASECALL_TABLE):
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def validate_READ_CLASSType(self, value):
        result = True
        # Validate type READ_CLASSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Application Read', 'Technical Read']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on READ_CLASSType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_READ_TYPEType(self, value):
        result = True
        # Validate type READ_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Forward', 'Reverse', 'Adapter', 'Primer', 'Linker', 'BarCode', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on READ_TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.READ_INDEX is not None or
            self.READ_LABEL is not None or
            self.READ_CLASS is not None or
            self.READ_TYPE != "Forward" or
            self.RELATIVE_ORDER is not None or
            self.BASE_COORD is not None or
            self.EXPECTED_BASECALL_TABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='READ_SPECType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('READ_SPECType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'READ_SPECType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='READ_SPECType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='READ_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='READ_SPECType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='READ_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.READ_INDEX is not None:
            namespaceprefix_ = self.READ_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_INDEX>%s</%sREAD_INDEX>%s' % (namespaceprefix_ , self.gds_format_integer(self.READ_INDEX, input_name='READ_INDEX'), namespaceprefix_ , eol_))
        if self.READ_LABEL is not None:
            namespaceprefix_ = self.READ_LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.READ_LABEL), input_name='READ_LABEL')), namespaceprefix_ , eol_))
        if self.READ_CLASS is not None:
            namespaceprefix_ = self.READ_CLASS_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_CLASS_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_CLASS>%s</%sREAD_CLASS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.READ_CLASS), input_name='READ_CLASS')), namespaceprefix_ , eol_))
        if self.READ_TYPE is not None:
            namespaceprefix_ = self.READ_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.READ_TYPE), input_name='READ_TYPE')), namespaceprefix_ , eol_))
        if self.RELATIVE_ORDER is not None:
            namespaceprefix_ = self.RELATIVE_ORDER_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATIVE_ORDER_nsprefix_) else ''
            self.RELATIVE_ORDER.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATIVE_ORDER', pretty_print=pretty_print)
        if self.BASE_COORD is not None:
            namespaceprefix_ = self.BASE_COORD_nsprefix_ + ':' if (UseCapturedNS_ and self.BASE_COORD_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_COORD>%s</%sBASE_COORD>%s' % (namespaceprefix_ , self.gds_format_integer(self.BASE_COORD, input_name='BASE_COORD'), namespaceprefix_ , eol_))
        if self.EXPECTED_BASECALL_TABLE is not None:
            namespaceprefix_ = self.EXPECTED_BASECALL_TABLE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPECTED_BASECALL_TABLE_nsprefix_) else ''
            self.EXPECTED_BASECALL_TABLE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPECTED_BASECALL_TABLE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'READ_INDEX' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'READ_INDEX')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'READ_INDEX')
            self.READ_INDEX = ival_
            self.READ_INDEX_nsprefix_ = child_.prefix
        elif nodeName_ == 'READ_LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'READ_LABEL')
            value_ = self.gds_validate_string(value_, node, 'READ_LABEL')
            self.READ_LABEL = value_
            self.READ_LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'READ_CLASS':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'READ_CLASS')
            value_ = self.gds_validate_string(value_, node, 'READ_CLASS')
            self.READ_CLASS = value_
            self.READ_CLASS_nsprefix_ = child_.prefix
            # validate type READ_CLASSType
            self.validate_READ_CLASSType(self.READ_CLASS)
        elif nodeName_ == 'READ_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'READ_TYPE')
            value_ = self.gds_validate_string(value_, node, 'READ_TYPE')
            self.READ_TYPE = value_
            self.READ_TYPE_nsprefix_ = child_.prefix
            # validate type READ_TYPEType
            self.validate_READ_TYPEType(self.READ_TYPE)
        elif nodeName_ == 'RELATIVE_ORDER':
            obj_ = RELATIVE_ORDERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATIVE_ORDER = obj_
            obj_.original_tagname_ = 'RELATIVE_ORDER'
        elif nodeName_ == 'BASE_COORD' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'BASE_COORD')
            ival_ = self.gds_validate_integer(ival_, node, 'BASE_COORD')
            self.BASE_COORD = ival_
            self.BASE_COORD_nsprefix_ = child_.prefix
        elif nodeName_ == 'EXPECTED_BASECALL_TABLE':
            obj_ = EXPECTED_BASECALL_TABLEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPECTED_BASECALL_TABLE = obj_
            obj_.original_tagname_ = 'EXPECTED_BASECALL_TABLE'
# end class READ_SPECType


class RELATIVE_ORDERType(GeneratedsSuper):
    """RELATIVE_ORDERType --
    The read is located beginning at the offset or cycle relative to another read.
    This choice is appropriate for example when specifying a read
    that follows a variable length expected sequence(s).

    * follows_read_index --
      Specify the read index that precedes this read.

    * precedes_read_index --
      Specify the read index that follows this read.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, follows_read_index=None, precedes_read_index=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.follows_read_index = _cast(int, follows_read_index)
        self.follows_read_index_nsprefix_ = None
        self.precedes_read_index = _cast(int, precedes_read_index)
        self.precedes_read_index_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELATIVE_ORDERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELATIVE_ORDERType.subclass:
            return RELATIVE_ORDERType.subclass(*args_, **kwargs_)
        else:
            return RELATIVE_ORDERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_follows_read_index(self):
        return self.follows_read_index
    def set_follows_read_index(self, follows_read_index):
        self.follows_read_index = follows_read_index
    def get_precedes_read_index(self):
        return self.precedes_read_index
    def set_precedes_read_index(self, precedes_read_index):
        self.precedes_read_index = precedes_read_index
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATIVE_ORDERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELATIVE_ORDERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELATIVE_ORDERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELATIVE_ORDERType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELATIVE_ORDERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELATIVE_ORDERType'):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            outfile.write(' follows_read_index="%s"' % self.gds_format_integer(self.follows_read_index, input_name='follows_read_index'))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            outfile.write(' precedes_read_index="%s"' % self.gds_format_integer(self.precedes_read_index, input_name='precedes_read_index'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATIVE_ORDERType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('follows_read_index', node)
        if value is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            self.follows_read_index = self.gds_parse_integer(value, node, 'follows_read_index')
            if self.follows_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('precedes_read_index', node)
        if value is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            self.precedes_read_index = self.gds_parse_integer(value, node, 'precedes_read_index')
            if self.precedes_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RELATIVE_ORDERType


class EXPECTED_BASECALL_TABLEType(GeneratedsSuper):
    """EXPECTED_BASECALL_TABLEType --
    A set of choices of expected basecalls for a current read. Read will be zero-length if none is found.

    * default_length --
      Specify whether the spot should have a default length for this tag if the expected base cannot be matched.

    * base_coord --
      Specify an optional starting point for tag (base offset from 1).

    * BASECALL --
      Element's body contains a basecall, attribute provide description of this read meaning as well as matching rules.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, default_length=None, base_coord=None, BASECALL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default_length = _cast(int, default_length)
        self.default_length_nsprefix_ = None
        self.base_coord = _cast(int, base_coord)
        self.base_coord_nsprefix_ = None
        if BASECALL is None:
            self.BASECALL = []
        else:
            self.BASECALL = BASECALL
        self.BASECALL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXPECTED_BASECALL_TABLEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXPECTED_BASECALL_TABLEType.subclass:
            return EXPECTED_BASECALL_TABLEType.subclass(*args_, **kwargs_)
        else:
            return EXPECTED_BASECALL_TABLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BASECALL(self):
        return self.BASECALL
    def set_BASECALL(self, BASECALL):
        self.BASECALL = BASECALL
    def add_BASECALL(self, value):
        self.BASECALL.append(value)
    def insert_BASECALL_at(self, index, value):
        self.BASECALL.insert(index, value)
    def replace_BASECALL_at(self, index, value):
        self.BASECALL[index] = value
    def get_default_length(self):
        return self.default_length
    def set_default_length(self, default_length):
        self.default_length = default_length
    def get_base_coord(self):
        return self.base_coord
    def set_base_coord(self, base_coord):
        self.base_coord = base_coord
    def _hasContent(self):
        if (
            self.BASECALL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPECTED_BASECALL_TABLEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXPECTED_BASECALL_TABLEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXPECTED_BASECALL_TABLEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPECTED_BASECALL_TABLEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXPECTED_BASECALL_TABLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXPECTED_BASECALL_TABLEType'):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            outfile.write(' default_length="%s"' % self.gds_format_integer(self.default_length, input_name='default_length'))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            outfile.write(' base_coord="%s"' % self.gds_format_integer(self.base_coord, input_name='base_coord'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPECTED_BASECALL_TABLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BASECALL_ in self.BASECALL:
            namespaceprefix_ = self.BASECALL_nsprefix_ + ':' if (UseCapturedNS_ and self.BASECALL_nsprefix_) else ''
            BASECALL_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BASECALL', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_length', node)
        if value is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            self.default_length = self.gds_parse_integer(value, node, 'default_length')
            if self.default_length < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('base_coord', node)
        if value is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            self.base_coord = self.gds_parse_integer(value, node, 'base_coord')
            if self.base_coord < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BASECALL':
            obj_ = BASECALLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BASECALL.append(obj_)
            obj_.original_tagname_ = 'BASECALL'
# end class EXPECTED_BASECALL_TABLEType


class BASECALLType(GeneratedsSuper):
    """BASECALLType --
    Element's body contains a basecall, attribute provide description of this read meaning as well as matching rules.

    * read_group_tag --
      When match occurs, the read will be tagged with this group membership

    * min_match --
      Minimum number of matches to trigger identification.

    * max_mismatch --
      Maximum number of mismatches

    * match_edge --
      Where the match should occur. Changes the rules on how min_match and max_mismatch are counted.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, read_group_tag=None, min_match=None, max_mismatch=None, match_edge=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.read_group_tag = _cast(None, read_group_tag)
        self.read_group_tag_nsprefix_ = None
        self.min_match = _cast(int, min_match)
        self.min_match_nsprefix_ = None
        self.max_mismatch = _cast(int, max_mismatch)
        self.max_mismatch_nsprefix_ = None
        self.match_edge = _cast(None, match_edge)
        self.match_edge_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BASECALLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BASECALLType.subclass:
            return BASECALLType.subclass(*args_, **kwargs_)
        else:
            return BASECALLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_read_group_tag(self):
        return self.read_group_tag
    def set_read_group_tag(self, read_group_tag):
        self.read_group_tag = read_group_tag
    def get_min_match(self):
        return self.min_match
    def set_min_match(self, min_match):
        self.min_match = min_match
    def get_max_mismatch(self):
        return self.max_mismatch
    def set_max_mismatch(self, max_mismatch):
        self.max_mismatch = max_mismatch
    def get_match_edge(self):
        return self.match_edge
    def set_match_edge(self, match_edge):
        self.match_edge = match_edge
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_match_edgeType(self, value):
        # Validate type match_edgeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'start', 'end']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on match_edgeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BASECALLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BASECALLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BASECALLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BASECALLType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BASECALLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BASECALLType'):
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.read_group_tag), input_name='read_group_tag')), ))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            outfile.write(' min_match="%s"' % self.gds_format_integer(self.min_match, input_name='min_match'))
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            outfile.write(' max_mismatch="%s"' % self.gds_format_integer(self.max_mismatch, input_name='max_mismatch'))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            outfile.write(' match_edge=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.match_edge), input_name='match_edge')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BASECALLType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
        value = find_attr_value_('min_match', node)
        if value is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            self.min_match = self.gds_parse_integer(value, node, 'min_match')
            if self.min_match < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('max_mismatch', node)
        if value is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            self.max_mismatch = self.gds_parse_integer(value, node, 'max_mismatch')
            if self.max_mismatch < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('match_edge', node)
        if value is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            self.match_edge = value
            self.validate_match_edgeType(self.match_edge)    # validate type match_edgeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class BASECALLType


class LS454Type(GeneratedsSuper):
    """LS454Type --  454 technology use 1-color sequential flows

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_type454Model(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LS454Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LS454Type.subclass:
            return LS454Type.subclass(*args_, **kwargs_)
        else:
            return LS454Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_type454Model(self, value):
        result = True
        # Validate type type454Model, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['454 GS', '454 GS 20', '454 GS FLX', '454 GS FLX+', '454 GS FLX Titanium', '454 GS Junior', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on type454Model' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LS454Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LS454Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LS454Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LS454Type')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LS454Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LS454Type'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LS454Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type type454Model
            self.validate_type454Model(self.INSTRUMENT_MODEL)
# end class LS454Type


class ILLUMINAType(GeneratedsSuper):
    """ILLUMINAType --  Illumina is 4-channel flowgram with 1-to-1 mapping between basecalls and flows

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ILLUMINAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ILLUMINAType.subclass:
            return ILLUMINAType.subclass(*args_, **kwargs_)
        else:
            return ILLUMINAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIlluminaModel(self, value):
        result = True
        # Validate type typeIlluminaModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['HiSeq X Five', 'HiSeq X Ten', 'Illumina Genome Analyzer', 'Illumina Genome Analyzer II', 'Illumina Genome Analyzer IIx', 'Illumina HiScanSQ', 'Illumina HiSeq 1000', 'Illumina HiSeq 1500', 'Illumina HiSeq 2000', 'Illumina HiSeq 2500', 'Illumina HiSeq 3000', 'Illumina HiSeq 4000', 'Illumina HiSeq X', 'Illumina iSeq 100', 'Illumina MiSeq', 'Illumina MiniSeq', 'Illumina NovaSeq 6000', 'NextSeq 500', 'NextSeq 550', 'NextSeq 1000', 'NextSeq 2000', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIlluminaModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ILLUMINAType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ILLUMINAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ILLUMINAType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ILLUMINAType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ILLUMINAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ILLUMINAType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ILLUMINAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeIlluminaModel
            self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
# end class ILLUMINAType


class HELICOSType(GeneratedsSuper):
    """HELICOSType --  Helicos is similar to 454 technology - uses 1-color sequential flows

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HELICOSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HELICOSType.subclass:
            return HELICOSType.subclass(*args_, **kwargs_)
        else:
            return HELICOSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeHelicosModel(self, value):
        result = True
        # Validate type typeHelicosModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Helicos HeliScope', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeHelicosModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HELICOSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HELICOSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HELICOSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HELICOSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HELICOSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HELICOSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HELICOSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeHelicosModel
            self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
# end class HELICOSType


class ABI_SOLIDType(GeneratedsSuper):
    """ABI_SOLIDType --  ABI is 4-channel flowgram with 1-to-1 mapping between basecalls and flows

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ABI_SOLIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ABI_SOLIDType.subclass:
            return ABI_SOLIDType.subclass(*args_, **kwargs_)
        else:
            return ABI_SOLIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeAbiSolidModel(self, value):
        result = True
        # Validate type typeAbiSolidModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AB SOLiD System', 'AB SOLiD System 2.0', 'AB SOLiD System 3.0', 'AB SOLiD 3 Plus System', 'AB SOLiD 4 System', 'AB SOLiD 4hq System', 'AB SOLiD PI System', 'AB 5500 Genetic Analyzer', 'AB 5500xl Genetic Analyzer', 'AB 5500xl-W Genetic Analysis System', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeAbiSolidModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ABI_SOLIDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ABI_SOLIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ABI_SOLIDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ABI_SOLIDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ABI_SOLIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ABI_SOLIDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ABI_SOLIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeAbiSolidModel
            self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
# end class ABI_SOLIDType


class COMPLETE_GENOMICSType(GeneratedsSuper):
    """COMPLETE_GENOMICSType --  CompleteGenomics platform type. At present there is no instrument model.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCGModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COMPLETE_GENOMICSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COMPLETE_GENOMICSType.subclass:
            return COMPLETE_GENOMICSType.subclass(*args_, **kwargs_)
        else:
            return COMPLETE_GENOMICSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCGModel(self, value):
        result = True
        # Validate type typeCGModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Complete Genomics', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeCGModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COMPLETE_GENOMICSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COMPLETE_GENOMICSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'COMPLETE_GENOMICSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COMPLETE_GENOMICSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COMPLETE_GENOMICSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COMPLETE_GENOMICSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COMPLETE_GENOMICSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeCGModel
            self.validate_typeCGModel(self.INSTRUMENT_MODEL)
# end class COMPLETE_GENOMICSType


class BGISEQType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BGISEQType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BGISEQType.subclass:
            return BGISEQType.subclass(*args_, **kwargs_)
        else:
            return BGISEQType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeBGISEQModel(self, value):
        result = True
        # Validate type typeBGISEQModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['BGISEQ-50', 'BGISEQ-500', 'MGISEQ-2000RS']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeBGISEQModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BGISEQType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BGISEQType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BGISEQType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BGISEQType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BGISEQType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BGISEQType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BGISEQType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeBGISEQModel
            self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
# end class BGISEQType


class OXFORD_NANOPOREType(GeneratedsSuper):
    """OXFORD_NANOPOREType --  Oxford Nanopore platform type. nanopore-based electronic single molecule analysis

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OXFORD_NANOPOREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OXFORD_NANOPOREType.subclass:
            return OXFORD_NANOPOREType.subclass(*args_, **kwargs_)
        else:
            return OXFORD_NANOPOREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeOxfordNanoporeModel(self, value):
        result = True
        # Validate type typeOxfordNanoporeModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MinION', 'GridION', 'PromethION', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeOxfordNanoporeModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OXFORD_NANOPOREType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OXFORD_NANOPOREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OXFORD_NANOPOREType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OXFORD_NANOPOREType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OXFORD_NANOPOREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OXFORD_NANOPOREType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OXFORD_NANOPOREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeOxfordNanoporeModel
            self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
# end class OXFORD_NANOPOREType


class PACBIO_SMRTType(GeneratedsSuper):
    """PACBIO_SMRTType --  PacificBiosciences platform type for the single molecule real time (SMRT) technology.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PACBIO_SMRTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PACBIO_SMRTType.subclass:
            return PACBIO_SMRTType.subclass(*args_, **kwargs_)
        else:
            return PACBIO_SMRTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typePacBioModel(self, value):
        result = True
        # Validate type typePacBioModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['PacBio RS', 'PacBio RS II', 'Sequel', 'Sequel II', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typePacBioModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PACBIO_SMRTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PACBIO_SMRTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PACBIO_SMRTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PACBIO_SMRTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PACBIO_SMRTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PACBIO_SMRTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PACBIO_SMRTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typePacBioModel
            self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
# end class PACBIO_SMRTType


class ION_TORRENTType(GeneratedsSuper):
    """ION_TORRENTType --  Ion Torrent Personal Genome Machine (PGM) from Life Technologies.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ION_TORRENTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ION_TORRENTType.subclass:
            return ION_TORRENTType.subclass(*args_, **kwargs_)
        else:
            return ION_TORRENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIontorrentModel(self, value):
        result = True
        # Validate type typeIontorrentModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Ion Torrent PGM', 'Ion Torrent Proton', 'Ion Torrent S5', 'Ion Torrent S5 XL', 'Ion Torrent Genexus', 'Ion GeneStudio S5', 'Ion GeneStudio S5 Prime', 'Ion GeneStudio S5 Plus', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeIontorrentModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ION_TORRENTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ION_TORRENTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ION_TORRENTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ION_TORRENTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ION_TORRENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ION_TORRENTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ION_TORRENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeIontorrentModel
            self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
# end class ION_TORRENTType


class CAPILLARYType(GeneratedsSuper):
    """CAPILLARYType --  Sequencers based on capillary electrophoresis technology manufactured by LifeTech (formerly Applied
    BioSciences).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CAPILLARYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CAPILLARYType.subclass:
            return CAPILLARYType.subclass(*args_, **kwargs_)
        else:
            return CAPILLARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCapillaryModel(self, value):
        result = True
        # Validate type typeCapillaryModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['AB 3730xL Genetic Analyzer', 'AB 3730 Genetic Analyzer', 'AB 3500xL Genetic Analyzer', 'AB 3500 Genetic Analyzer', 'AB 3130xL Genetic Analyzer', 'AB 3130 Genetic Analyzer', 'AB 310 Genetic Analyzer', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeCapillaryModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CAPILLARYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CAPILLARYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CAPILLARYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CAPILLARYType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CAPILLARYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CAPILLARYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CAPILLARYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeCapillaryModel
            self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
# end class CAPILLARYType


class DNBSEQType(GeneratedsSuper):
    """DNBSEQType --  Sequencers based on DNBSEQ by MGI Tech.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeDnbSeqModel(self.INSTRUMENT_MODEL)
        self.INSTRUMENT_MODEL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DNBSEQType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DNBSEQType.subclass:
            return DNBSEQType.subclass(*args_, **kwargs_)
        else:
            return DNBSEQType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeDnbSeqModel(self, value):
        result = True
        # Validate type typeDnbSeqModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['DNBSEQ-T7', 'DNBSEQ-G400', 'DNBSEQ-G50', 'DNBSEQ-G400 FAST', 'unspecified']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeDnbSeqModel' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DNBSEQType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DNBSEQType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DNBSEQType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DNBSEQType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DNBSEQType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DNBSEQType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DNBSEQType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            namespaceprefix_ = self.INSTRUMENT_MODEL_nsprefix_ + ':' if (UseCapturedNS_ and self.INSTRUMENT_MODEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL), input_name='INSTRUMENT_MODEL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'INSTRUMENT_MODEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INSTRUMENT_MODEL')
            value_ = self.gds_validate_string(value_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = value_
            self.INSTRUMENT_MODEL_nsprefix_ = child_.prefix
            # validate type typeDnbSeqModel
            self.validate_typeDnbSeqModel(self.INSTRUMENT_MODEL)
# end class DNBSEQType


class PIPE_SECTIONType(GeneratedsSuper):
    """section_name --
    Name of the processing pipeline section.

    * STEP_INDEX --
      Lexically ordered  value that allows for the pipe section to be hierarchically ordered.  The float primitive data type is
      used to allow for pipe sections to be inserted later on.

    * PREV_STEP_INDEX --
      STEP_INDEX of the previous step in the workflow.  Set toNIL if the first pipe section.

    * PROGRAM --
      Name of the program or process for primary analysis.   This may include a test or condition
      that leads to branching in the workflow.

    * VERSION --
      Version of the program or process for primary analysis.

    * NOTES --
      Notes about the program or process for primary analysis.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, section_name=None, STEP_INDEX=None, PREV_STEP_INDEX=None, PROGRAM=None, VERSION=None, NOTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.section_name = _cast(None, section_name)
        self.section_name_nsprefix_ = None
        self.STEP_INDEX = STEP_INDEX
        self.STEP_INDEX_nsprefix_ = None
        if PREV_STEP_INDEX is None:
            self.PREV_STEP_INDEX = []
        else:
            self.PREV_STEP_INDEX = PREV_STEP_INDEX
        self.PREV_STEP_INDEX_nsprefix_ = None
        self.PROGRAM = PROGRAM
        self.PROGRAM_nsprefix_ = None
        self.VERSION = VERSION
        self.VERSION_nsprefix_ = None
        self.NOTES = NOTES
        self.NOTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PIPE_SECTIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PIPE_SECTIONType.subclass:
            return PIPE_SECTIONType.subclass(*args_, **kwargs_)
        else:
            return PIPE_SECTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STEP_INDEX(self):
        return self.STEP_INDEX
    def set_STEP_INDEX(self, STEP_INDEX):
        self.STEP_INDEX = STEP_INDEX
    def get_PREV_STEP_INDEX(self):
        return self.PREV_STEP_INDEX
    def set_PREV_STEP_INDEX(self, PREV_STEP_INDEX):
        self.PREV_STEP_INDEX = PREV_STEP_INDEX
    def add_PREV_STEP_INDEX(self, value):
        self.PREV_STEP_INDEX.append(value)
    def insert_PREV_STEP_INDEX_at(self, index, value):
        self.PREV_STEP_INDEX.insert(index, value)
    def replace_PREV_STEP_INDEX_at(self, index, value):
        self.PREV_STEP_INDEX[index] = value
    def get_PROGRAM(self):
        return self.PROGRAM
    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM
    def get_VERSION(self):
        return self.VERSION
    def set_VERSION(self, VERSION):
        self.VERSION = VERSION
    def get_NOTES(self):
        return self.NOTES
    def set_NOTES(self, NOTES):
        self.NOTES = NOTES
    def get_section_name(self):
        return self.section_name
    def set_section_name(self, section_name):
        self.section_name = section_name
    def _hasContent(self):
        if (
            self.STEP_INDEX is not None or
            self.PREV_STEP_INDEX or
            self.PROGRAM is not None or
            self.VERSION is not None or
            self.NOTES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIPE_SECTIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PIPE_SECTIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PIPE_SECTIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PIPE_SECTIONType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PIPE_SECTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PIPE_SECTIONType'):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            outfile.write(' section_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.section_name), input_name='section_name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PIPE_SECTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STEP_INDEX is not None:
            namespaceprefix_ = self.STEP_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.STEP_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTEP_INDEX>%s</%sSTEP_INDEX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STEP_INDEX), input_name='STEP_INDEX')), namespaceprefix_ , eol_))
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            namespaceprefix_ = self.PREV_STEP_INDEX_nsprefix_ + ':' if (UseCapturedNS_ and self.PREV_STEP_INDEX_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STEP_INDEX>%s</%sPREV_STEP_INDEX>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(PREV_STEP_INDEX_), input_name='PREV_STEP_INDEX')), namespaceprefix_ , eol_))
        if self.PROGRAM is not None:
            namespaceprefix_ = self.PROGRAM_nsprefix_ + ':' if (UseCapturedNS_ and self.PROGRAM_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.PROGRAM), input_name='PROGRAM')), namespaceprefix_ , eol_))
        if self.VERSION is not None:
            namespaceprefix_ = self.VERSION_nsprefix_ + ':' if (UseCapturedNS_ and self.VERSION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VERSION), input_name='VERSION')), namespaceprefix_ , eol_))
        if self.NOTES is not None:
            namespaceprefix_ = self.NOTES_nsprefix_ + ':' if (UseCapturedNS_ and self.NOTES_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNOTES>%s</%sNOTES>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NOTES), input_name='NOTES')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('section_name', node)
        if value is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            self.section_name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STEP_INDEX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STEP_INDEX')
            value_ = self.gds_validate_string(value_, node, 'STEP_INDEX')
            self.STEP_INDEX = value_
            self.STEP_INDEX_nsprefix_ = child_.prefix
        elif nodeName_ == 'PREV_STEP_INDEX':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PREV_STEP_INDEX')
            value_ = self.gds_validate_string(value_, node, 'PREV_STEP_INDEX')
            self.PREV_STEP_INDEX.append(value_)
            self.PREV_STEP_INDEX_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROGRAM':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'PROGRAM')
            value_ = self.gds_validate_string(value_, node, 'PROGRAM')
            self.PROGRAM = value_
            self.PROGRAM_nsprefix_ = child_.prefix
        elif nodeName_ == 'VERSION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'VERSION')
            value_ = self.gds_validate_string(value_, node, 'VERSION')
            self.VERSION = value_
            self.VERSION_nsprefix_ = child_.prefix
        elif nodeName_ == 'NOTES':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NOTES')
            value_ = self.gds_validate_string(value_, node, 'NOTES')
            self.NOTES = value_
            self.NOTES_nsprefix_ = child_.prefix
# end class PIPE_SECTIONType


class STANDARDType(GeneratedsSuper):
    """STANDARDType -- A standard genome assembly.

    * refname -- A recognized name for the genome assembly.
    * accession -- Identifies the genome assembly
      using an accession number and a sequence version.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refname=None, accession=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refname = _cast(None, refname)
        self.refname_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STANDARDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STANDARDType.subclass:
            return STANDARDType.subclass(*args_, **kwargs_)
        else:
            return STANDARDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refname(self):
        return self.refname
    def set_refname(self, refname):
        self.refname = refname
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STANDARDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STANDARDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STANDARDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STANDARDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STANDARDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STANDARDType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refname), input_name='refname')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STANDARDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class STANDARDType


class CUSTOMType(GeneratedsSuper):
    """CUSTOMType -- Other genome assembly.
    DESCRIPTION -- Description of the genome
    assembly.
    URL_LINK -- A link to the genome
    assembly.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DESCRIPTION=None, URL_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        if URL_LINK is None:
            self.URL_LINK = []
        else:
            self.URL_LINK = URL_LINK
        self.URL_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CUSTOMType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CUSTOMType.subclass:
            return CUSTOMType.subclass(*args_, **kwargs_)
        else:
            return CUSTOMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_URL_LINK(self):
        return self.URL_LINK
    def set_URL_LINK(self, URL_LINK):
        self.URL_LINK = URL_LINK
    def add_URL_LINK(self, value):
        self.URL_LINK.append(value)
    def insert_URL_LINK_at(self, index, value):
        self.URL_LINK.insert(index, value)
    def replace_URL_LINK_at(self, index, value):
        self.URL_LINK[index] = value
    def _hasContent(self):
        if (
            self.DESCRIPTION is not None or
            self.URL_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CUSTOMType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CUSTOMType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CUSTOMType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CUSTOMType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CUSTOMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CUSTOMType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CUSTOMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        for URL_LINK_ in self.URL_LINK:
            namespaceprefix_ = self.URL_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_LINK_nsprefix_) else ''
            URL_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='URL_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.URL_LINK.append(obj_)
            obj_.original_tagname_ = 'URL_LINK'
# end class CUSTOMType


class URL_LINKType23(GeneratedsSuper):
    """URL_LINKType23 -- A link to the genome
    assembly.
    LABEL --  Text label to display for the
    link.
    URL --  The internet service link
    (file:, http:, ftp:, etc).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.LABEL = LABEL
        self.LABEL_nsprefix_ = None
        self.URL = URL
        self.URL_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URL_LINKType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URL_LINKType23.subclass:
            return URL_LINKType23.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LABEL(self):
        return self.LABEL
    def set_LABEL(self, LABEL):
        self.LABEL = LABEL
    def get_URL(self):
        return self.URL
    def set_URL(self, URL):
        self.URL = URL
    def _hasContent(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL_LINKType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URL_LINKType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'URL_LINKType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URL_LINKType23')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='URL_LINKType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='URL_LINKType23'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='URL_LINKType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            namespaceprefix_ = self.LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.LABEL), input_name='LABEL')), namespaceprefix_ , eol_))
        if self.URL is not None:
            namespaceprefix_ = self.URL_nsprefix_ + ':' if (UseCapturedNS_ and self.URL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.URL), input_name='URL')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'LABEL')
            value_ = self.gds_validate_string(value_, node, 'LABEL')
            self.LABEL = value_
            self.LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'URL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'URL')
            value_ = self.gds_validate_string(value_, node, 'URL')
            self.URL = value_
            self.URL_nsprefix_ = child_.prefix
# end class URL_LINKType23


class SEQUENCEType(GeneratedsSuper):
    """SEQUENCEType -- Reference sequence details.
    refname -- A recognized name for the
    reference sequence.
    accession --   Accession.version with version being mandatory

    * label --  This is how Reference Sequence is labeled in submission file(s).
      It is equivalent to  SQ label in BAM.
      Optional when submitted file uses INSDC accession.version

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refname=None, accession=None, label=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refname = _cast(None, refname)
        self.refname_nsprefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SEQUENCEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SEQUENCEType.subclass:
            return SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refname(self):
        return self.refname
    def set_refname(self, refname):
        self.refname = refname
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SEQUENCEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SEQUENCEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SEQUENCEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SEQUENCEType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refname), input_name='refname')), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SEQUENCEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SEQUENCEType


class READ_LABELType(GeneratedsSuper):
    """read_group_tag --  Assignment of read_group_tag to decoded read

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, read_group_tag=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.read_group_tag = _cast(None, read_group_tag)
        self.read_group_tag_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, READ_LABELType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if READ_LABELType.subclass:
            return READ_LABELType.subclass(*args_, **kwargs_)
        else:
            return READ_LABELType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_read_group_tag(self):
        return self.read_group_tag
    def set_read_group_tag(self, read_group_tag):
        self.read_group_tag = read_group_tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='READ_LABELType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('READ_LABELType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'READ_LABELType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='READ_LABELType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='READ_LABELType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='READ_LABELType'):
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.read_group_tag), input_name='read_group_tag')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='READ_LABELType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class READ_LABELType


class POOLType(GeneratedsSuper):
    """POOLType --
    Identifies a list of group/pool/multiplex sample members.  This implies that
    this sample record is a group, pool, or multiplex, but it continues to receive
    its own accession and can be referenced by an experiment.  By default if
    no match to any of the listed members can be determined, then the default
    sample reference is used.

    * DEFAULT_MEMBER --  Reference to the sample that is used when read membership cannot be determined. A default member should
      be provided if there exists a possibility that some reads will be left over from barcode/MID resolution. A default member
      is not needed when defining a true pool (where individual samples are not distinguished in the reads), or the reads have
      been partitioned among the pool members (no leftovers).
    * MEMBER --  Reference to the sample as determined from barcode/MID resolution or read partition.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, DEFAULT_MEMBER=None, MEMBER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.DEFAULT_MEMBER = DEFAULT_MEMBER
        self.DEFAULT_MEMBER_nsprefix_ = None
        if MEMBER is None:
            self.MEMBER = []
        else:
            self.MEMBER = MEMBER
        self.MEMBER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, POOLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if POOLType.subclass:
            return POOLType.subclass(*args_, **kwargs_)
        else:
            return POOLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DEFAULT_MEMBER(self):
        return self.DEFAULT_MEMBER
    def set_DEFAULT_MEMBER(self, DEFAULT_MEMBER):
        self.DEFAULT_MEMBER = DEFAULT_MEMBER
    def get_MEMBER(self):
        return self.MEMBER
    def set_MEMBER(self, MEMBER):
        self.MEMBER = MEMBER
    def add_MEMBER(self, value):
        self.MEMBER.append(value)
    def insert_MEMBER_at(self, index, value):
        self.MEMBER.insert(index, value)
    def replace_MEMBER_at(self, index, value):
        self.MEMBER[index] = value
    def _hasContent(self):
        if (
            self.DEFAULT_MEMBER is not None or
            self.MEMBER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POOLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('POOLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'POOLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='POOLType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='POOLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='POOLType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='POOLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEFAULT_MEMBER is not None:
            namespaceprefix_ = self.DEFAULT_MEMBER_nsprefix_ + ':' if (UseCapturedNS_ and self.DEFAULT_MEMBER_nsprefix_) else ''
            self.DEFAULT_MEMBER.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DEFAULT_MEMBER', pretty_print=pretty_print)
        for MEMBER_ in self.MEMBER:
            namespaceprefix_ = self.MEMBER_nsprefix_ + ':' if (UseCapturedNS_ and self.MEMBER_nsprefix_) else ''
            MEMBER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MEMBER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DEFAULT_MEMBER':
            obj_ = PoolMemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DEFAULT_MEMBER = obj_
            obj_.original_tagname_ = 'DEFAULT_MEMBER'
        elif nodeName_ == 'MEMBER':
            obj_ = PoolMemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MEMBER.append(obj_)
            obj_.original_tagname_ = 'MEMBER'
# end class POOLType


class LIBRARY_LAYOUTType(GeneratedsSuper):
    """LIBRARY_LAYOUTType --
    LIBRARY_LAYOUT specifies whether to expect single, paired, or other configuration of reads.
    In the case of paired reads, information about the relative distance and orientation is specified.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SINGLE=None, PAIRED=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.SINGLE = SINGLE
        self.SINGLE_nsprefix_ = None
        self.PAIRED = PAIRED
        self.PAIRED_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LIBRARY_LAYOUTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LIBRARY_LAYOUTType.subclass:
            return LIBRARY_LAYOUTType.subclass(*args_, **kwargs_)
        else:
            return LIBRARY_LAYOUTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SINGLE(self):
        return self.SINGLE
    def set_SINGLE(self, SINGLE):
        self.SINGLE = SINGLE
    def get_PAIRED(self):
        return self.PAIRED
    def set_PAIRED(self, PAIRED):
        self.PAIRED = PAIRED
    def _hasContent(self):
        if (
            self.SINGLE is not None or
            self.PAIRED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LIBRARY_LAYOUTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LIBRARY_LAYOUTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LIBRARY_LAYOUTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LIBRARY_LAYOUTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LIBRARY_LAYOUTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LIBRARY_LAYOUTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LIBRARY_LAYOUTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SINGLE is not None:
            namespaceprefix_ = self.SINGLE_nsprefix_ + ':' if (UseCapturedNS_ and self.SINGLE_nsprefix_) else ''
            self.SINGLE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SINGLE', pretty_print=pretty_print)
        if self.PAIRED is not None:
            namespaceprefix_ = self.PAIRED_nsprefix_ + ':' if (UseCapturedNS_ and self.PAIRED_nsprefix_) else ''
            self.PAIRED.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PAIRED', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SINGLE':
            obj_ = SINGLEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SINGLE = obj_
            obj_.original_tagname_ = 'SINGLE'
        elif nodeName_ == 'PAIRED':
            obj_ = PAIREDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PAIRED = obj_
            obj_.original_tagname_ = 'PAIRED'
# end class LIBRARY_LAYOUTType


class SINGLEType(GeneratedsSuper):
    """SINGLEType --
    Reads are unpaired (usual case).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SINGLEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SINGLEType.subclass:
            return SINGLEType.subclass(*args_, **kwargs_)
        else:
            return SINGLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SINGLEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SINGLEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SINGLEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SINGLEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SINGLEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SINGLEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SINGLEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SINGLEType


class PAIREDType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, NOMINAL_LENGTH=None, NOMINAL_SDEV=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.NOMINAL_LENGTH = _cast(int, NOMINAL_LENGTH)
        self.NOMINAL_LENGTH_nsprefix_ = None
        self.NOMINAL_SDEV = _cast(float, NOMINAL_SDEV)
        self.NOMINAL_SDEV_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PAIREDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PAIREDType.subclass:
            return PAIREDType.subclass(*args_, **kwargs_)
        else:
            return PAIREDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NOMINAL_LENGTH(self):
        return self.NOMINAL_LENGTH
    def set_NOMINAL_LENGTH(self, NOMINAL_LENGTH):
        self.NOMINAL_LENGTH = NOMINAL_LENGTH
    def get_NOMINAL_SDEV(self):
        return self.NOMINAL_SDEV
    def set_NOMINAL_SDEV(self, NOMINAL_SDEV):
        self.NOMINAL_SDEV = NOMINAL_SDEV
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PAIREDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PAIREDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PAIREDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PAIREDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PAIREDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PAIREDType'):
        if self.NOMINAL_LENGTH is not None and 'NOMINAL_LENGTH' not in already_processed:
            already_processed.add('NOMINAL_LENGTH')
            outfile.write(' NOMINAL_LENGTH="%s"' % self.gds_format_integer(self.NOMINAL_LENGTH, input_name='NOMINAL_LENGTH'))
        if self.NOMINAL_SDEV is not None and 'NOMINAL_SDEV' not in already_processed:
            already_processed.add('NOMINAL_SDEV')
            outfile.write(' NOMINAL_SDEV="%s"' % self.gds_format_double(self.NOMINAL_SDEV, input_name='NOMINAL_SDEV'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PAIREDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NOMINAL_LENGTH', node)
        if value is not None and 'NOMINAL_LENGTH' not in already_processed:
            already_processed.add('NOMINAL_LENGTH')
            self.NOMINAL_LENGTH = self.gds_parse_integer(value, node, 'NOMINAL_LENGTH')
            if self.NOMINAL_LENGTH < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('NOMINAL_SDEV', node)
        if value is not None and 'NOMINAL_SDEV' not in already_processed:
            already_processed.add('NOMINAL_SDEV')
            value = self.gds_parse_double(value, node, 'NOMINAL_SDEV')
            self.NOMINAL_SDEV = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PAIREDType


class TARGETED_LOCIType(GeneratedsSuper):
    """TARGETED_LOCIType --
    Names the gene(s) or locus(loci) or other genomic feature(s) targeted by the sequence.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, LOCUS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if LOCUS is None:
            self.LOCUS = []
        else:
            self.LOCUS = LOCUS
        self.LOCUS_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TARGETED_LOCIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TARGETED_LOCIType.subclass:
            return TARGETED_LOCIType.subclass(*args_, **kwargs_)
        else:
            return TARGETED_LOCIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LOCUS(self):
        return self.LOCUS
    def set_LOCUS(self, LOCUS):
        self.LOCUS = LOCUS
    def add_LOCUS(self, value):
        self.LOCUS.append(value)
    def insert_LOCUS_at(self, index, value):
        self.LOCUS.insert(index, value)
    def replace_LOCUS_at(self, index, value):
        self.LOCUS[index] = value
    def _hasContent(self):
        if (
            self.LOCUS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TARGETED_LOCIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TARGETED_LOCIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TARGETED_LOCIType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TARGETED_LOCIType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TARGETED_LOCIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TARGETED_LOCIType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TARGETED_LOCIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LOCUS_ in self.LOCUS:
            namespaceprefix_ = self.LOCUS_nsprefix_ + ':' if (UseCapturedNS_ and self.LOCUS_nsprefix_) else ''
            LOCUS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LOCUS', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LOCUS':
            obj_ = LOCUSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LOCUS.append(obj_)
            obj_.original_tagname_ = 'LOCUS'
# end class TARGETED_LOCIType


class LOCUSType(GeneratedsSuper):
    """description --  Submitter supplied description of alternate locus and auxiliary
    information.
    PROBE_SET --  Reference to an archived primer or
    probe set. Example: dbProbe

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, locus_name=None, description=None, PROBE_SET=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.locus_name = _cast(None, locus_name)
        self.locus_name_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.PROBE_SET = PROBE_SET
        self.PROBE_SET_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LOCUSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LOCUSType.subclass:
            return LOCUSType.subclass(*args_, **kwargs_)
        else:
            return LOCUSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PROBE_SET(self):
        return self.PROBE_SET
    def set_PROBE_SET(self, PROBE_SET):
        self.PROBE_SET = PROBE_SET
    def get_locus_name(self):
        return self.locus_name
    def set_locus_name(self, locus_name):
        self.locus_name = locus_name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def validate_locus_nameType(self, value):
        # Validate type locus_nameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['16S rRNA', '18S rRNA', '28S rRNA', 'RBCL', 'matK', 'COX1', 'ITS1-5.8S-ITS2', 'exome', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on locus_nameType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.PROBE_SET is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LOCUSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LOCUSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LOCUSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LOCUSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LOCUSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LOCUSType'):
        if self.locus_name is not None and 'locus_name' not in already_processed:
            already_processed.add('locus_name')
            outfile.write(' locus_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.locus_name), input_name='locus_name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LOCUSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PROBE_SET is not None:
            namespaceprefix_ = self.PROBE_SET_nsprefix_ + ':' if (UseCapturedNS_ and self.PROBE_SET_nsprefix_) else ''
            self.PROBE_SET.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROBE_SET', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locus_name', node)
        if value is not None and 'locus_name' not in already_processed:
            already_processed.add('locus_name')
            self.locus_name = value
            self.validate_locus_nameType(self.locus_name)    # validate type locus_nameType
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PROBE_SET':
            obj_ = XRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROBE_SET = obj_
            obj_.original_tagname_ = 'PROBE_SET'
# end class LOCUSType


class STUDY_REFType24(RefObjectType):
    """STUDY_REFType24 --
    Identifies the parent study.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("STUDY_REFType24"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_REFType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_REFType24.subclass:
            return STUDY_REFType24.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(STUDY_REFType24, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_REFType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_REFType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType24')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_REFType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_REFType24'):
        super(STUDY_REFType24, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_REFType24')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_REFType24', fromsubclass_=False, pretty_print=True):
        super(STUDY_REFType24, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(STUDY_REFType24, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(STUDY_REFType24, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class STUDY_REFType24


class EXPERIMENT_LINKSType(GeneratedsSuper):
    """EXPERIMENT_LINKSType --
    Links to resources related to this experiment or experiment set (publication, datasets, online databases).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if EXPERIMENT_LINK is None:
            self.EXPERIMENT_LINK = []
        else:
            self.EXPERIMENT_LINK = EXPERIMENT_LINK
        self.EXPERIMENT_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXPERIMENT_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXPERIMENT_LINKSType.subclass:
            return EXPERIMENT_LINKSType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EXPERIMENT_LINK(self):
        return self.EXPERIMENT_LINK
    def set_EXPERIMENT_LINK(self, EXPERIMENT_LINK):
        self.EXPERIMENT_LINK = EXPERIMENT_LINK
    def add_EXPERIMENT_LINK(self, value):
        self.EXPERIMENT_LINK.append(value)
    def insert_EXPERIMENT_LINK_at(self, index, value):
        self.EXPERIMENT_LINK.insert(index, value)
    def replace_EXPERIMENT_LINK_at(self, index, value):
        self.EXPERIMENT_LINK[index] = value
    def _hasContent(self):
        if (
            self.EXPERIMENT_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXPERIMENT_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXPERIMENT_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXPERIMENT_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXPERIMENT_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_LINK_ in self.EXPERIMENT_LINK:
            namespaceprefix_ = self.EXPERIMENT_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_LINK_nsprefix_) else ''
            EXPERIMENT_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EXPERIMENT_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_LINK.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT_LINK'
# end class EXPERIMENT_LINKSType


class EXPERIMENT_ATTRIBUTESType(GeneratedsSuper):
    """EXPERIMENT_ATTRIBUTESType --
    Properties and attributes of the experiment.  These can be entered as free-form
    tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if EXPERIMENT_ATTRIBUTE is None:
            self.EXPERIMENT_ATTRIBUTE = []
        else:
            self.EXPERIMENT_ATTRIBUTE = EXPERIMENT_ATTRIBUTE
        self.EXPERIMENT_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXPERIMENT_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXPERIMENT_ATTRIBUTESType.subclass:
            return EXPERIMENT_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EXPERIMENT_ATTRIBUTE(self):
        return self.EXPERIMENT_ATTRIBUTE
    def set_EXPERIMENT_ATTRIBUTE(self, EXPERIMENT_ATTRIBUTE):
        self.EXPERIMENT_ATTRIBUTE = EXPERIMENT_ATTRIBUTE
    def add_EXPERIMENT_ATTRIBUTE(self, value):
        self.EXPERIMENT_ATTRIBUTE.append(value)
    def insert_EXPERIMENT_ATTRIBUTE_at(self, index, value):
        self.EXPERIMENT_ATTRIBUTE.insert(index, value)
    def replace_EXPERIMENT_ATTRIBUTE_at(self, index, value):
        self.EXPERIMENT_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.EXPERIMENT_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXPERIMENT_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXPERIMENT_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXPERIMENT_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXPERIMENT_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_ATTRIBUTE_ in self.EXPERIMENT_ATTRIBUTE:
            namespaceprefix_ = self.EXPERIMENT_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_ATTRIBUTE_nsprefix_) else ''
            EXPERIMENT_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EXPERIMENT_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT_ATTRIBUTE'
# end class EXPERIMENT_ATTRIBUTESType


class EXT_IDType(GeneratedsSuper):
    """EXT_IDType -- The REF identifies the reference of that object .

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, accession=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.accession = _cast(None, accession)
        self.accession_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXT_IDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXT_IDType.subclass:
            return EXT_IDType.subclass(*args_, **kwargs_)
        else:
            return EXT_IDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accession(self):
        return self.accession
    def set_accession(self, accession):
        self.accession = accession
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_accessionType(self, value):
        # Validate type accessionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on accessionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on accessionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['study', 'experiment', 'sample', 'sampleGroup', 'run', 'analysis', 'dataset', 'policy', 'dac', 'ArrayExpress', 'LocusTagPrefix', 'Taxon', 'Project', 'checklist', 'biosample']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXT_IDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXT_IDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXT_IDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXT_IDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXT_IDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXT_IDType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accession), input_name='accession')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXT_IDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.validate_accessionType(self.accession)    # validate type accessionType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType(self.type_)    # validate type typeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class EXT_IDType


class MESSAGESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ERROR=None, INFO=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ERROR is None:
            self.ERROR = []
        else:
            self.ERROR = ERROR
        self.ERROR_nsprefix_ = None
        if INFO is None:
            self.INFO = []
        else:
            self.INFO = INFO
        self.INFO_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MESSAGESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MESSAGESType.subclass:
            return MESSAGESType.subclass(*args_, **kwargs_)
        else:
            return MESSAGESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ERROR(self):
        return self.ERROR
    def set_ERROR(self, ERROR):
        self.ERROR = ERROR
    def add_ERROR(self, value):
        self.ERROR.append(value)
    def insert_ERROR_at(self, index, value):
        self.ERROR.insert(index, value)
    def replace_ERROR_at(self, index, value):
        self.ERROR[index] = value
    def get_INFO(self):
        return self.INFO
    def set_INFO(self, INFO):
        self.INFO = INFO
    def add_INFO(self, value):
        self.INFO.append(value)
    def insert_INFO_at(self, index, value):
        self.INFO.insert(index, value)
    def replace_INFO_at(self, index, value):
        self.INFO[index] = value
    def _hasContent(self):
        if (
            self.ERROR or
            self.INFO
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MESSAGESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MESSAGESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MESSAGESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MESSAGESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MESSAGESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MESSAGESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MESSAGESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ERROR_ in self.ERROR:
            namespaceprefix_ = self.ERROR_nsprefix_ + ':' if (UseCapturedNS_ and self.ERROR_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sERROR>%s</%sERROR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ERROR_), input_name='ERROR')), namespaceprefix_ , eol_))
        for INFO_ in self.INFO:
            namespaceprefix_ = self.INFO_nsprefix_ + ':' if (UseCapturedNS_ and self.INFO_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINFO>%s</%sINFO>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(INFO_), input_name='INFO')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ERROR':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ERROR')
            value_ = self.gds_validate_string(value_, node, 'ERROR')
            self.ERROR.append(value_)
            self.ERROR_nsprefix_ = child_.prefix
        elif nodeName_ == 'INFO':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'INFO')
            value_ = self.gds_validate_string(value_, node, 'INFO')
            self.INFO.append(value_)
            self.INFO_nsprefix_ = child_.prefix
# end class MESSAGESType


class EXPERIMENT_REFType25(RefObjectType):
    """EXPERIMENT_REFType25 -- Identifies the parent experiment.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RefObjectType
    def __init__(self, refname=None, refcenter=None, accession=None, IDENTIFIERS=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EXPERIMENT_REFType25"), self).__init__(refname, refcenter, accession, IDENTIFIERS,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EXPERIMENT_REFType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EXPERIMENT_REFType25.subclass:
            return EXPERIMENT_REFType25.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_REFType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(EXPERIMENT_REFType25, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_REFType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EXPERIMENT_REFType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EXPERIMENT_REFType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_REFType25')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EXPERIMENT_REFType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EXPERIMENT_REFType25'):
        super(EXPERIMENT_REFType25, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EXPERIMENT_REFType25')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EXPERIMENT_REFType25', fromsubclass_=False, pretty_print=True):
        super(EXPERIMENT_REFType25, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EXPERIMENT_REFType25, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EXPERIMENT_REFType25, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EXPERIMENT_REFType25


class RUN_TYPEType(GeneratedsSuper):
    """RUN_TYPEType -- The type of the run.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, REFERENCE_ALIGNMENT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
        self.REFERENCE_ALIGNMENT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUN_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUN_TYPEType.subclass:
            return RUN_TYPEType.subclass(*args_, **kwargs_)
        else:
            return RUN_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_REFERENCE_ALIGNMENT(self):
        return self.REFERENCE_ALIGNMENT
    def set_REFERENCE_ALIGNMENT(self, REFERENCE_ALIGNMENT):
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
    def _hasContent(self):
        if (
            self.REFERENCE_ALIGNMENT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUN_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RUN_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUN_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUN_TYPEType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.REFERENCE_ALIGNMENT is not None:
            namespaceprefix_ = self.REFERENCE_ALIGNMENT_nsprefix_ + ':' if (UseCapturedNS_ and self.REFERENCE_ALIGNMENT_nsprefix_) else ''
            self.REFERENCE_ALIGNMENT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REFERENCE_ALIGNMENT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'REFERENCE_ALIGNMENT':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.REFERENCE_ALIGNMENT = obj_
            obj_.original_tagname_ = 'REFERENCE_ALIGNMENT'
# end class RUN_TYPEType


class DATA_BLOCKType(GeneratedsSuper):
    """member_name --
    Allow for an individual DATA_BLOCK to be associated with a member of a sample pool.

    * FILES --  Data files associated with the run.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, member_name=None, FILES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.member_name = _cast(None, member_name)
        self.member_name_nsprefix_ = None
        self.FILES = FILES
        self.FILES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DATA_BLOCKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DATA_BLOCKType.subclass:
            return DATA_BLOCKType.subclass(*args_, **kwargs_)
        else:
            return DATA_BLOCKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FILES(self):
        return self.FILES
    def set_FILES(self, FILES):
        self.FILES = FILES
    def get_member_name(self):
        return self.member_name
    def set_member_name(self, member_name):
        self.member_name = member_name
    def _hasContent(self):
        if (
            self.FILES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATA_BLOCKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DATA_BLOCKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DATA_BLOCKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DATA_BLOCKType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DATA_BLOCKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DATA_BLOCKType'):
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            outfile.write(' member_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.member_name), input_name='member_name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DATA_BLOCKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FILES is not None:
            namespaceprefix_ = self.FILES_nsprefix_ + ':' if (UseCapturedNS_ and self.FILES_nsprefix_) else ''
            self.FILES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('member_name', node)
        if value is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            self.member_name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FILES':
            obj_ = FILESType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
# end class DATA_BLOCKType


class FILESType26(GeneratedsSuper):
    """FILESType26 --  Data files associated with the run.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, FILE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE
        self.FILE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILESType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILESType26.subclass:
            return FILESType26.subclass(*args_, **kwargs_)
        else:
            return FILESType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FILE(self):
        return self.FILE
    def set_FILE(self, FILE):
        self.FILE = FILE
    def add_FILE(self, value):
        self.FILE.append(value)
    def insert_FILE_at(self, index, value):
        self.FILE.insert(index, value)
    def replace_FILE_at(self, index, value):
        self.FILE[index] = value
    def _hasContent(self):
        if (
            self.FILE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILESType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FILESType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILESType26')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILESType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILESType26'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILESType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            namespaceprefix_ = self.FILE_nsprefix_ + ':' if (UseCapturedNS_ and self.FILE_nsprefix_) else ''
            FILE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FILE':
            obj_ = FILEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'
# end class FILESType26


class FILEType(GeneratedsSuper):
    """filename -- The name or relative pathname of a run data file.
    filetype --  The run data file model.
    quality_scoring_system --
    How the input data are scored for quality.

    * quality_encoding --
      Character used in representing the minimum quality value.
      Helps specify how to decode text rendering of quality data.

    * ascii_offset --
      Character used in representing the minimum quality value.  Helps specify how to decode text rendering of quality data.

    * checksum_method --
      Checksum method used.

    * checksum --
      Checksum of uncompressed file.

    * unencrypted_checksum --
      Checksum of unenrypted file(used in conjunction with checksum of encrypted file).

    * READ_LABEL --
      The READ_LABEL can associate a certain file to a certain read_label defined in the SPOT_DESCRIPTOR.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filename=None, filetype=None, quality_scoring_system=None, quality_encoding=None, ascii_offset=None, checksum_method=None, checksum=None, unencrypted_checksum=None, READ_LABEL=None, READ_TYPE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filename = _cast(None, filename)
        self.filename_nsprefix_ = None
        self.filetype = _cast(None, filetype)
        self.filetype_nsprefix_ = None
        self.quality_scoring_system = _cast(None, quality_scoring_system)
        self.quality_scoring_system_nsprefix_ = None
        self.quality_encoding = _cast(None, quality_encoding)
        self.quality_encoding_nsprefix_ = None
        self.ascii_offset = _cast(None, ascii_offset)
        self.ascii_offset_nsprefix_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.checksum_method_nsprefix_ = None
        self.checksum = _cast(None, checksum)
        self.checksum_nsprefix_ = None
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.unencrypted_checksum_nsprefix_ = None
        if READ_LABEL is None:
            self.READ_LABEL = []
        else:
            self.READ_LABEL = READ_LABEL
        self.READ_LABEL_nsprefix_ = None
        if READ_TYPE is None:
            self.READ_TYPE = []
        else:
            self.READ_TYPE = READ_TYPE
        self.READ_TYPE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FILEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FILEType.subclass:
            return FILEType.subclass(*args_, **kwargs_)
        else:
            return FILEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_READ_LABEL(self):
        return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL):
        self.READ_LABEL = READ_LABEL
    def add_READ_LABEL(self, value):
        self.READ_LABEL.append(value)
    def insert_READ_LABEL_at(self, index, value):
        self.READ_LABEL.insert(index, value)
    def replace_READ_LABEL_at(self, index, value):
        self.READ_LABEL[index] = value
    def get_READ_TYPE(self):
        return self.READ_TYPE
    def set_READ_TYPE(self, READ_TYPE):
        self.READ_TYPE = READ_TYPE
    def add_READ_TYPE(self, value):
        self.READ_TYPE.append(value)
    def insert_READ_TYPE_at(self, index, value):
        self.READ_TYPE.insert(index, value)
    def replace_READ_TYPE_at(self, index, value):
        self.READ_TYPE[index] = value
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def get_filetype(self):
        return self.filetype
    def set_filetype(self, filetype):
        self.filetype = filetype
    def get_quality_scoring_system(self):
        return self.quality_scoring_system
    def set_quality_scoring_system(self, quality_scoring_system):
        self.quality_scoring_system = quality_scoring_system
    def get_quality_encoding(self):
        return self.quality_encoding
    def set_quality_encoding(self, quality_encoding):
        self.quality_encoding = quality_encoding
    def get_ascii_offset(self):
        return self.ascii_offset
    def set_ascii_offset(self, ascii_offset):
        self.ascii_offset = ascii_offset
    def get_checksum_method(self):
        return self.checksum_method
    def set_checksum_method(self, checksum_method):
        self.checksum_method = checksum_method
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    def get_unencrypted_checksum(self):
        return self.unencrypted_checksum
    def set_unencrypted_checksum(self, unencrypted_checksum):
        self.unencrypted_checksum = unencrypted_checksum
    def validate_READ_TYPEType27(self, value):
        result = True
        # Validate type READ_TYPEType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['single', 'paired', 'cell_barcode', 'umi_barcode', 'feature_barcode', 'sample_barcode', '']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on READ_TYPEType27' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_filetypeType28(self, value):
        # Validate type filetypeType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sra', 'srf', 'sff', 'fastq', 'fasta', 'tab', '454_native', '454_native_seq', '454_native_qual', 'Helicos_native', 'Illumina_native', 'Illumina_native_seq', 'Illumina_native_prb', 'Illumina_native_int', 'Illumina_native_qseq', 'Illumina_native_scarf', 'SOLiD_native', 'SOLiD_native_csfasta', 'SOLiD_native_qual', 'PacBio_HDF5', 'bam', 'cram', 'CompleteGenomics_native', 'OxfordNanopore_native']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on filetypeType28' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_quality_scoring_systemType(self, value):
        # Validate type quality_scoring_systemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['phred', 'log-odds']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on quality_scoring_systemType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_quality_encodingType(self, value):
        # Validate type quality_encodingType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ascii', 'decimal', 'hexadecimal']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on quality_encodingType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ascii_offsetType(self, value):
        # Validate type ascii_offsetType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['!', '@']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ascii_offsetType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_checksum_methodType29(self, value):
        # Validate type checksum_methodType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['MD5', 'SHA-256']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on checksum_methodType29' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.READ_LABEL or
            self.READ_TYPE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FILEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FILEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FILEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FILEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FILEType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filetype), input_name='filetype')), ))
        if self.quality_scoring_system is not None and 'quality_scoring_system' not in already_processed:
            already_processed.add('quality_scoring_system')
            outfile.write(' quality_scoring_system=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.quality_scoring_system), input_name='quality_scoring_system')), ))
        if self.quality_encoding is not None and 'quality_encoding' not in already_processed:
            already_processed.add('quality_encoding')
            outfile.write(' quality_encoding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.quality_encoding), input_name='quality_encoding')), ))
        if self.ascii_offset is not None and 'ascii_offset' not in already_processed:
            already_processed.add('ascii_offset')
            outfile.write(' ascii_offset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ascii_offset), input_name='ascii_offset')), ))
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum_method), input_name='checksum_method')), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checksum), input_name='checksum')), ))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unencrypted_checksum), input_name='unencrypted_checksum')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FILEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for READ_LABEL_ in self.READ_LABEL:
            namespaceprefix_ = self.READ_LABEL_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_LABEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(READ_LABEL_), input_name='READ_LABEL')), namespaceprefix_ , eol_))
        for READ_TYPE_ in self.READ_TYPE:
            namespaceprefix_ = self.READ_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.READ_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(READ_TYPE_), input_name='READ_TYPE')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
            self.validate_filetypeType28(self.filetype)    # validate type filetypeType28
        value = find_attr_value_('quality_scoring_system', node)
        if value is not None and 'quality_scoring_system' not in already_processed:
            already_processed.add('quality_scoring_system')
            self.quality_scoring_system = value
            self.validate_quality_scoring_systemType(self.quality_scoring_system)    # validate type quality_scoring_systemType
        value = find_attr_value_('quality_encoding', node)
        if value is not None and 'quality_encoding' not in already_processed:
            already_processed.add('quality_encoding')
            self.quality_encoding = value
            self.validate_quality_encodingType(self.quality_encoding)    # validate type quality_encodingType
        value = find_attr_value_('ascii_offset', node)
        if value is not None and 'ascii_offset' not in already_processed:
            already_processed.add('ascii_offset')
            self.ascii_offset = value
            self.validate_ascii_offsetType(self.ascii_offset)    # validate type ascii_offsetType
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
            self.validate_checksum_methodType29(self.checksum_method)    # validate type checksum_methodType29
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'READ_LABEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'READ_LABEL')
            value_ = self.gds_validate_string(value_, node, 'READ_LABEL')
            self.READ_LABEL.append(value_)
            self.READ_LABEL_nsprefix_ = child_.prefix
        elif nodeName_ == 'READ_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'READ_TYPE')
            value_ = self.gds_validate_string(value_, node, 'READ_TYPE')
            self.READ_TYPE.append(value_)
            self.READ_TYPE_nsprefix_ = child_.prefix
            # validate type READ_TYPEType27
            self.validate_READ_TYPEType27(self.READ_TYPE[-1])
# end class FILEType


class RUN_LINKSType(GeneratedsSuper):
    """RUN_LINKSType --
    Links to resources related to this RUN or RUN set (publication, datasets, online databases).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RUN_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RUN_LINK is None:
            self.RUN_LINK = []
        else:
            self.RUN_LINK = RUN_LINK
        self.RUN_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUN_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUN_LINKSType.subclass:
            return RUN_LINKSType.subclass(*args_, **kwargs_)
        else:
            return RUN_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RUN_LINK(self):
        return self.RUN_LINK
    def set_RUN_LINK(self, RUN_LINK):
        self.RUN_LINK = RUN_LINK
    def add_RUN_LINK(self, value):
        self.RUN_LINK.append(value)
    def insert_RUN_LINK_at(self, index, value):
        self.RUN_LINK.insert(index, value)
    def replace_RUN_LINK_at(self, index, value):
        self.RUN_LINK[index] = value
    def _hasContent(self):
        if (
            self.RUN_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUN_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RUN_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUN_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUN_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_LINK_ in self.RUN_LINK:
            namespaceprefix_ = self.RUN_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_LINK_nsprefix_) else ''
            RUN_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RUN_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_LINK.append(obj_)
            obj_.original_tagname_ = 'RUN_LINK'
# end class RUN_LINKSType


class RUN_ATTRIBUTESType(GeneratedsSuper):
    """RUN_ATTRIBUTESType --
    Properties and attributes of a RUN.  These can be entered as free-form
    tag-value pairs. For certain studies, submitters may be asked to follow a
    community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RUN_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RUN_ATTRIBUTE is None:
            self.RUN_ATTRIBUTE = []
        else:
            self.RUN_ATTRIBUTE = RUN_ATTRIBUTE
        self.RUN_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RUN_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RUN_ATTRIBUTESType.subclass:
            return RUN_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return RUN_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RUN_ATTRIBUTE(self):
        return self.RUN_ATTRIBUTE
    def set_RUN_ATTRIBUTE(self, RUN_ATTRIBUTE):
        self.RUN_ATTRIBUTE = RUN_ATTRIBUTE
    def add_RUN_ATTRIBUTE(self, value):
        self.RUN_ATTRIBUTE.append(value)
    def insert_RUN_ATTRIBUTE_at(self, index, value):
        self.RUN_ATTRIBUTE.insert(index, value)
    def replace_RUN_ATTRIBUTE_at(self, index, value):
        self.RUN_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.RUN_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RUN_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RUN_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RUN_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RUN_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RUN_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RUN_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_ATTRIBUTE_ in self.RUN_ATTRIBUTE:
            namespaceprefix_ = self.RUN_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_ATTRIBUTE_nsprefix_) else ''
            RUN_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RUN_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'RUN_ATTRIBUTE'
# end class RUN_ATTRIBUTESType


class SAMPLE_NAMEType(GeneratedsSuper):
    """TAXON_ID --
    NCBI Taxonomy Identifier.  This is appropriate for individual organisms and
    some environmental samples.

    * SCIENTIFIC_NAME --
      Scientific name of sample that distinguishes its taxonomy.  Please use a
      name or synonym that is tracked in the INSDC Taxonomy database.
      Also, this field can be used to confirm the TAXON_ID setting.

    * COMMON_NAME --
      GenBank common name of the organism.  Examples: human, mouse.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, display_name=None, TAXON_ID=None, SCIENTIFIC_NAME=None, COMMON_NAME=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.display_name = _cast(None, display_name)
        self.display_name_nsprefix_ = None
        self.TAXON_ID = TAXON_ID
        self.TAXON_ID_nsprefix_ = None
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
        self.SCIENTIFIC_NAME_nsprefix_ = None
        self.COMMON_NAME = COMMON_NAME
        self.COMMON_NAME_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_NAMEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_NAMEType.subclass:
            return SAMPLE_NAMEType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_NAMEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TAXON_ID(self):
        return self.TAXON_ID
    def set_TAXON_ID(self, TAXON_ID):
        self.TAXON_ID = TAXON_ID
    def get_SCIENTIFIC_NAME(self):
        return self.SCIENTIFIC_NAME
    def set_SCIENTIFIC_NAME(self, SCIENTIFIC_NAME):
        self.SCIENTIFIC_NAME = SCIENTIFIC_NAME
    def get_COMMON_NAME(self):
        return self.COMMON_NAME
    def set_COMMON_NAME(self, COMMON_NAME):
        self.COMMON_NAME = COMMON_NAME
    def get_display_name(self):
        return self.display_name
    def set_display_name(self, display_name):
        self.display_name = display_name
    def _hasContent(self):
        if (
            self.TAXON_ID is not None or
            self.SCIENTIFIC_NAME is not None or
            self.COMMON_NAME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_NAMEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_NAMEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_NAMEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_NAMEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_NAMEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_NAMEType'):
        if self.display_name is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            outfile.write(' display_name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.display_name), input_name='display_name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_NAMEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAXON_ID is not None:
            namespaceprefix_ = self.TAXON_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAXON_ID>%s</%sTAXON_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.TAXON_ID, input_name='TAXON_ID'), namespaceprefix_ , eol_))
        if self.SCIENTIFIC_NAME is not None:
            namespaceprefix_ = self.SCIENTIFIC_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.SCIENTIFIC_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSCIENTIFIC_NAME>%s</%sSCIENTIFIC_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SCIENTIFIC_NAME), input_name='SCIENTIFIC_NAME')), namespaceprefix_ , eol_))
        if self.COMMON_NAME is not None:
            namespaceprefix_ = self.COMMON_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.COMMON_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOMMON_NAME>%s</%sCOMMON_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.COMMON_NAME), input_name='COMMON_NAME')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('display_name', node)
        if value is not None and 'display_name' not in already_processed:
            already_processed.add('display_name')
            self.display_name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TAXON_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'TAXON_ID')
            ival_ = self.gds_validate_integer(ival_, node, 'TAXON_ID')
            self.TAXON_ID = ival_
            self.TAXON_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'SCIENTIFIC_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SCIENTIFIC_NAME')
            value_ = self.gds_validate_string(value_, node, 'SCIENTIFIC_NAME')
            self.SCIENTIFIC_NAME = value_
            self.SCIENTIFIC_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'COMMON_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'COMMON_NAME')
            value_ = self.gds_validate_string(value_, node, 'COMMON_NAME')
            self.COMMON_NAME = value_
            self.COMMON_NAME_nsprefix_ = child_.prefix
# end class SAMPLE_NAMEType


class SAMPLE_LINKSType(GeneratedsSuper):
    """SAMPLE_LINKSType --
    Links to resources related to this sample or sample set (publication, datasets, online databases).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SAMPLE_LINK is None:
            self.SAMPLE_LINK = []
        else:
            self.SAMPLE_LINK = SAMPLE_LINK
        self.SAMPLE_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_LINKSType.subclass:
            return SAMPLE_LINKSType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE_LINK(self):
        return self.SAMPLE_LINK
    def set_SAMPLE_LINK(self, SAMPLE_LINK):
        self.SAMPLE_LINK = SAMPLE_LINK
    def add_SAMPLE_LINK(self, value):
        self.SAMPLE_LINK.append(value)
    def insert_SAMPLE_LINK_at(self, index, value):
        self.SAMPLE_LINK.insert(index, value)
    def replace_SAMPLE_LINK_at(self, index, value):
        self.SAMPLE_LINK[index] = value
    def _hasContent(self):
        if (
            self.SAMPLE_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SAMPLE_LINK_ in self.SAMPLE_LINK:
            namespaceprefix_ = self.SAMPLE_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_LINK_nsprefix_) else ''
            SAMPLE_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_LINK.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_LINK'
# end class SAMPLE_LINKSType


class SAMPLE_ATTRIBUTESType(GeneratedsSuper):
    """SAMPLE_ATTRIBUTESType --
    Properties and attributes of a sample.  These can be entered as free-form
    tag-value pairs. For certain studies, submitters may be asked to follow a
    community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SAMPLE_ATTRIBUTE is None:
            self.SAMPLE_ATTRIBUTE = []
        else:
            self.SAMPLE_ATTRIBUTE = SAMPLE_ATTRIBUTE
        self.SAMPLE_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SAMPLE_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SAMPLE_ATTRIBUTESType.subclass:
            return SAMPLE_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE_ATTRIBUTE(self):
        return self.SAMPLE_ATTRIBUTE
    def set_SAMPLE_ATTRIBUTE(self, SAMPLE_ATTRIBUTE):
        self.SAMPLE_ATTRIBUTE = SAMPLE_ATTRIBUTE
    def add_SAMPLE_ATTRIBUTE(self, value):
        self.SAMPLE_ATTRIBUTE.append(value)
    def insert_SAMPLE_ATTRIBUTE_at(self, index, value):
        self.SAMPLE_ATTRIBUTE.insert(index, value)
    def replace_SAMPLE_ATTRIBUTE_at(self, index, value):
        self.SAMPLE_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.SAMPLE_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SAMPLE_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SAMPLE_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SAMPLE_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SAMPLE_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SAMPLE_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SAMPLE_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SAMPLE_ATTRIBUTE_ in self.SAMPLE_ATTRIBUTE:
            namespaceprefix_ = self.SAMPLE_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_ATTRIBUTE_nsprefix_) else ''
            SAMPLE_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_ATTRIBUTE'
# end class SAMPLE_ATTRIBUTESType


class DESCRIPTORType30(GeneratedsSuper):
    """STUDY_TITLE --
    Title of the study as would be used in a publication.

    * STUDY_TYPE -- The STUDY_TYPE presents a controlled vocabulary for expressing the overall purpose of the study.
    * STUDY_ABSTRACT --
      Briefly describes the goals, purpose, and scope of the Study.  This need not be listed if it can be
      inherited from a referenced publication.

    * CENTER_NAME --
      DEPRECATED.  Use STUDY@center_name instead.
      Controlled vocabulary identifying the sequencing center, core facility, consortium, or laboratory responsible for the study.

    * CENTER_PROJECT_NAME --
      Submitter defined project name.  This field is intended for backward tracking of the study record to the submitter's LIMS.

    * PROJECT_ID --
      DEPRECATED (use RELATED_STUDIES.STUDY instead).
      The required PROJECT_ID accession is generated by the Genome Project database at NCBI
      and will be valid also at the other archival institutions.

    * STUDY_DESCRIPTION --
      More extensive free-form description of the study.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, STUDY_TITLE=None, STUDY_TYPE=None, STUDY_ABSTRACT=None, CENTER_NAME=None, CENTER_PROJECT_NAME=None, PROJECT_ID=None, RELATED_STUDIES=None, STUDY_DESCRIPTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.STUDY_TITLE = STUDY_TITLE
        self.STUDY_TITLE_nsprefix_ = None
        self.STUDY_TYPE = STUDY_TYPE
        self.STUDY_TYPE_nsprefix_ = None
        self.STUDY_ABSTRACT = STUDY_ABSTRACT
        self.STUDY_ABSTRACT_nsprefix_ = None
        self.CENTER_NAME = CENTER_NAME
        self.CENTER_NAME_nsprefix_ = None
        self.CENTER_PROJECT_NAME = CENTER_PROJECT_NAME
        self.CENTER_PROJECT_NAME_nsprefix_ = None
        self.PROJECT_ID = PROJECT_ID
        self.PROJECT_ID_nsprefix_ = None
        self.RELATED_STUDIES = RELATED_STUDIES
        self.RELATED_STUDIES_nsprefix_ = None
        self.STUDY_DESCRIPTION = STUDY_DESCRIPTION
        self.STUDY_DESCRIPTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESCRIPTORType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESCRIPTORType30.subclass:
            return DESCRIPTORType30.subclass(*args_, **kwargs_)
        else:
            return DESCRIPTORType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STUDY_TITLE(self):
        return self.STUDY_TITLE
    def set_STUDY_TITLE(self, STUDY_TITLE):
        self.STUDY_TITLE = STUDY_TITLE
    def get_STUDY_TYPE(self):
        return self.STUDY_TYPE
    def set_STUDY_TYPE(self, STUDY_TYPE):
        self.STUDY_TYPE = STUDY_TYPE
    def get_STUDY_ABSTRACT(self):
        return self.STUDY_ABSTRACT
    def set_STUDY_ABSTRACT(self, STUDY_ABSTRACT):
        self.STUDY_ABSTRACT = STUDY_ABSTRACT
    def get_CENTER_NAME(self):
        return self.CENTER_NAME
    def set_CENTER_NAME(self, CENTER_NAME):
        self.CENTER_NAME = CENTER_NAME
    def get_CENTER_PROJECT_NAME(self):
        return self.CENTER_PROJECT_NAME
    def set_CENTER_PROJECT_NAME(self, CENTER_PROJECT_NAME):
        self.CENTER_PROJECT_NAME = CENTER_PROJECT_NAME
    def get_PROJECT_ID(self):
        return self.PROJECT_ID
    def set_PROJECT_ID(self, PROJECT_ID):
        self.PROJECT_ID = PROJECT_ID
    def get_RELATED_STUDIES(self):
        return self.RELATED_STUDIES
    def set_RELATED_STUDIES(self, RELATED_STUDIES):
        self.RELATED_STUDIES = RELATED_STUDIES
    def get_STUDY_DESCRIPTION(self):
        return self.STUDY_DESCRIPTION
    def set_STUDY_DESCRIPTION(self, STUDY_DESCRIPTION):
        self.STUDY_DESCRIPTION = STUDY_DESCRIPTION
    def _hasContent(self):
        if (
            self.STUDY_TITLE is not None or
            self.STUDY_TYPE is not None or
            self.STUDY_ABSTRACT is not None or
            self.CENTER_NAME is not None or
            self.CENTER_PROJECT_NAME is not None or
            self.PROJECT_ID is not None or
            self.RELATED_STUDIES is not None or
            self.STUDY_DESCRIPTION is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTORType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DESCRIPTORType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DESCRIPTORType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DESCRIPTORType30')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DESCRIPTORType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DESCRIPTORType30'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DESCRIPTORType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STUDY_TITLE is not None:
            namespaceprefix_ = self.STUDY_TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTUDY_TITLE>%s</%sSTUDY_TITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STUDY_TITLE), input_name='STUDY_TITLE')), namespaceprefix_ , eol_))
        if self.STUDY_TYPE is not None:
            namespaceprefix_ = self.STUDY_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_TYPE_nsprefix_) else ''
            self.STUDY_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_TYPE', pretty_print=pretty_print)
        if self.STUDY_ABSTRACT is not None:
            namespaceprefix_ = self.STUDY_ABSTRACT_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_ABSTRACT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTUDY_ABSTRACT>%s</%sSTUDY_ABSTRACT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STUDY_ABSTRACT), input_name='STUDY_ABSTRACT')), namespaceprefix_ , eol_))
        if self.CENTER_NAME is not None:
            namespaceprefix_ = self.CENTER_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.CENTER_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCENTER_NAME>%s</%sCENTER_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CENTER_NAME), input_name='CENTER_NAME')), namespaceprefix_ , eol_))
        if self.CENTER_PROJECT_NAME is not None:
            namespaceprefix_ = self.CENTER_PROJECT_NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.CENTER_PROJECT_NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCENTER_PROJECT_NAME>%s</%sCENTER_PROJECT_NAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CENTER_PROJECT_NAME), input_name='CENTER_PROJECT_NAME')), namespaceprefix_ , eol_))
        if self.PROJECT_ID is not None:
            namespaceprefix_ = self.PROJECT_ID_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_ID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROJECT_ID>%s</%sPROJECT_ID>%s' % (namespaceprefix_ , self.gds_format_integer(self.PROJECT_ID, input_name='PROJECT_ID'), namespaceprefix_ , eol_))
        if self.RELATED_STUDIES is not None:
            namespaceprefix_ = self.RELATED_STUDIES_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATED_STUDIES_nsprefix_) else ''
            self.RELATED_STUDIES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATED_STUDIES', pretty_print=pretty_print)
        if self.STUDY_DESCRIPTION is not None:
            namespaceprefix_ = self.STUDY_DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTUDY_DESCRIPTION>%s</%sSTUDY_DESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.STUDY_DESCRIPTION), input_name='STUDY_DESCRIPTION')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STUDY_TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STUDY_TITLE')
            value_ = self.gds_validate_string(value_, node, 'STUDY_TITLE')
            self.STUDY_TITLE = value_
            self.STUDY_TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'STUDY_TYPE':
            obj_ = STUDY_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_TYPE = obj_
            obj_.original_tagname_ = 'STUDY_TYPE'
        elif nodeName_ == 'STUDY_ABSTRACT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STUDY_ABSTRACT')
            value_ = self.gds_validate_string(value_, node, 'STUDY_ABSTRACT')
            self.STUDY_ABSTRACT = value_
            self.STUDY_ABSTRACT_nsprefix_ = child_.prefix
        elif nodeName_ == 'CENTER_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CENTER_NAME')
            value_ = self.gds_validate_string(value_, node, 'CENTER_NAME')
            self.CENTER_NAME = value_
            self.CENTER_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'CENTER_PROJECT_NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'CENTER_PROJECT_NAME')
            value_ = self.gds_validate_string(value_, node, 'CENTER_PROJECT_NAME')
            self.CENTER_PROJECT_NAME = value_
            self.CENTER_PROJECT_NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'PROJECT_ID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PROJECT_ID')
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'PROJECT_ID')
            self.PROJECT_ID = ival_
            self.PROJECT_ID_nsprefix_ = child_.prefix
        elif nodeName_ == 'RELATED_STUDIES':
            obj_ = RELATED_STUDIESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATED_STUDIES = obj_
            obj_.original_tagname_ = 'RELATED_STUDIES'
        elif nodeName_ == 'STUDY_DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'STUDY_DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'STUDY_DESCRIPTION')
            self.STUDY_DESCRIPTION = value_
            self.STUDY_DESCRIPTION_nsprefix_ = child_.prefix
# end class DESCRIPTORType30


class STUDY_TYPEType(GeneratedsSuper):
    """STUDY_TYPEType -- The STUDY_TYPE presents a controlled vocabulary for expressing the overall purpose of the study.
    new_study_type --
    To propose a new term, select Other and enter a new study type.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, existing_study_type=None, new_study_type=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.existing_study_type = _cast(None, existing_study_type)
        self.existing_study_type_nsprefix_ = None
        self.new_study_type = _cast(None, new_study_type)
        self.new_study_type_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_TYPEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_TYPEType.subclass:
            return STUDY_TYPEType.subclass(*args_, **kwargs_)
        else:
            return STUDY_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_existing_study_type(self):
        return self.existing_study_type
    def set_existing_study_type(self, existing_study_type):
        self.existing_study_type = existing_study_type
    def get_new_study_type(self):
        return self.new_study_type
    def set_new_study_type(self, new_study_type):
        self.new_study_type = new_study_type
    def validate_existing_study_typeType(self, value):
        # Validate type existing_study_typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Whole Genome Sequencing', 'Metagenomics', 'Transcriptome Analysis', 'Resequencing', 'Epigenetics', 'Synthetic Genomics', 'Forensic or Paleo-genomics', 'Gene Regulation Study', 'Cancer Genomics', 'Population Genomics', 'RNASeq', 'Exome Sequencing', 'Pooled Clone Sequencing', 'Transcriptome Sequencing', 'Other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on existing_study_typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_TYPEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_TYPEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_TYPEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_TYPEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_TYPEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_TYPEType'):
        if self.existing_study_type is not None and 'existing_study_type' not in already_processed:
            already_processed.add('existing_study_type')
            outfile.write(' existing_study_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.existing_study_type), input_name='existing_study_type')), ))
        if self.new_study_type is not None and 'new_study_type' not in already_processed:
            already_processed.add('new_study_type')
            outfile.write(' new_study_type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.new_study_type), input_name='new_study_type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_TYPEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('existing_study_type', node)
        if value is not None and 'existing_study_type' not in already_processed:
            already_processed.add('existing_study_type')
            self.existing_study_type = value
            self.validate_existing_study_typeType(self.existing_study_type)    # validate type existing_study_typeType
        value = find_attr_value_('new_study_type', node)
        if value is not None and 'new_study_type' not in already_processed:
            already_processed.add('new_study_type')
            self.new_study_type = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class STUDY_TYPEType


class RELATED_STUDIESType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RELATED_STUDY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if RELATED_STUDY is None:
            self.RELATED_STUDY = []
        else:
            self.RELATED_STUDY = RELATED_STUDY
        self.RELATED_STUDY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELATED_STUDIESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELATED_STUDIESType.subclass:
            return RELATED_STUDIESType.subclass(*args_, **kwargs_)
        else:
            return RELATED_STUDIESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RELATED_STUDY(self):
        return self.RELATED_STUDY
    def set_RELATED_STUDY(self, RELATED_STUDY):
        self.RELATED_STUDY = RELATED_STUDY
    def add_RELATED_STUDY(self, value):
        self.RELATED_STUDY.append(value)
    def insert_RELATED_STUDY_at(self, index, value):
        self.RELATED_STUDY.insert(index, value)
    def replace_RELATED_STUDY_at(self, index, value):
        self.RELATED_STUDY[index] = value
    def _hasContent(self):
        if (
            self.RELATED_STUDY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_STUDIESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELATED_STUDIESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELATED_STUDIESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELATED_STUDIESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELATED_STUDIESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELATED_STUDIESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_STUDIESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RELATED_STUDY_ in self.RELATED_STUDY:
            namespaceprefix_ = self.RELATED_STUDY_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATED_STUDY_nsprefix_) else ''
            RELATED_STUDY_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATED_STUDY', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RELATED_STUDY':
            obj_ = RELATED_STUDYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATED_STUDY.append(obj_)
            obj_.original_tagname_ = 'RELATED_STUDY'
# end class RELATED_STUDIESType


class RELATED_STUDYType(GeneratedsSuper):
    """RELATED_LINK --
    Related study or project record from a list of supported databases.
    The study's information is derived from this project record rather
    than stored as first class information.

    * IS_PRIMARY --
      Whether this study object is designated as the primary source
      of the study or project information.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RELATED_LINK=None, IS_PRIMARY=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RELATED_LINK = RELATED_LINK
        self.RELATED_LINK_nsprefix_ = None
        self.IS_PRIMARY = IS_PRIMARY
        self.IS_PRIMARY_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELATED_STUDYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELATED_STUDYType.subclass:
            return RELATED_STUDYType.subclass(*args_, **kwargs_)
        else:
            return RELATED_STUDYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RELATED_LINK(self):
        return self.RELATED_LINK
    def set_RELATED_LINK(self, RELATED_LINK):
        self.RELATED_LINK = RELATED_LINK
    def get_IS_PRIMARY(self):
        return self.IS_PRIMARY
    def set_IS_PRIMARY(self, IS_PRIMARY):
        self.IS_PRIMARY = IS_PRIMARY
    def _hasContent(self):
        if (
            self.RELATED_LINK is not None or
            self.IS_PRIMARY is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_STUDYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELATED_STUDYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELATED_STUDYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELATED_STUDYType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELATED_STUDYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELATED_STUDYType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELATED_STUDYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RELATED_LINK is not None:
            namespaceprefix_ = self.RELATED_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATED_LINK_nsprefix_) else ''
            self.RELATED_LINK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATED_LINK', pretty_print=pretty_print)
        if self.IS_PRIMARY is not None:
            namespaceprefix_ = self.IS_PRIMARY_nsprefix_ + ':' if (UseCapturedNS_ and self.IS_PRIMARY_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIS_PRIMARY>%s</%sIS_PRIMARY>%s' % (namespaceprefix_ , self.gds_format_boolean(self.IS_PRIMARY, input_name='IS_PRIMARY'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RELATED_LINK':
            obj_ = XRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATED_LINK = obj_
            obj_.original_tagname_ = 'RELATED_LINK'
        elif nodeName_ == 'IS_PRIMARY':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'IS_PRIMARY')
            ival_ = self.gds_validate_boolean(ival_, node, 'IS_PRIMARY')
            self.IS_PRIMARY = ival_
            self.IS_PRIMARY_nsprefix_ = child_.prefix
# end class RELATED_STUDYType


class STUDY_LINKSType(GeneratedsSuper):
    """STUDY_LINKSType --
    Links to resources related to this study (publication, datasets, online databases).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, STUDY_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if STUDY_LINK is None:
            self.STUDY_LINK = []
        else:
            self.STUDY_LINK = STUDY_LINK
        self.STUDY_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_LINKSType.subclass:
            return STUDY_LINKSType.subclass(*args_, **kwargs_)
        else:
            return STUDY_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STUDY_LINK(self):
        return self.STUDY_LINK
    def set_STUDY_LINK(self, STUDY_LINK):
        self.STUDY_LINK = STUDY_LINK
    def add_STUDY_LINK(self, value):
        self.STUDY_LINK.append(value)
    def insert_STUDY_LINK_at(self, index, value):
        self.STUDY_LINK.insert(index, value)
    def replace_STUDY_LINK_at(self, index, value):
        self.STUDY_LINK[index] = value
    def _hasContent(self):
        if (
            self.STUDY_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for STUDY_LINK_ in self.STUDY_LINK:
            namespaceprefix_ = self.STUDY_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_LINK_nsprefix_) else ''
            STUDY_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STUDY_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_LINK.append(obj_)
            obj_.original_tagname_ = 'STUDY_LINK'
# end class STUDY_LINKSType


class STUDY_ATTRIBUTESType(GeneratedsSuper):
    """STUDY_ATTRIBUTESType --
    Properties and attributes of the study.  These can be entered as free-form
    tag-value pairs. For certain studies, submitters may be asked to follow a
    community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, STUDY_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if STUDY_ATTRIBUTE is None:
            self.STUDY_ATTRIBUTE = []
        else:
            self.STUDY_ATTRIBUTE = STUDY_ATTRIBUTE
        self.STUDY_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, STUDY_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if STUDY_ATTRIBUTESType.subclass:
            return STUDY_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return STUDY_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_STUDY_ATTRIBUTE(self):
        return self.STUDY_ATTRIBUTE
    def set_STUDY_ATTRIBUTE(self, STUDY_ATTRIBUTE):
        self.STUDY_ATTRIBUTE = STUDY_ATTRIBUTE
    def add_STUDY_ATTRIBUTE(self, value):
        self.STUDY_ATTRIBUTE.append(value)
    def insert_STUDY_ATTRIBUTE_at(self, index, value):
        self.STUDY_ATTRIBUTE.insert(index, value)
    def replace_STUDY_ATTRIBUTE_at(self, index, value):
        self.STUDY_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.STUDY_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('STUDY_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'STUDY_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='STUDY_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='STUDY_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='STUDY_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='STUDY_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for STUDY_ATTRIBUTE_ in self.STUDY_ATTRIBUTE:
            namespaceprefix_ = self.STUDY_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_ATTRIBUTE_nsprefix_) else ''
            STUDY_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'STUDY_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'STUDY_ATTRIBUTE'
# end class STUDY_ATTRIBUTESType


class CONTACTSType31(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, CONTACT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if CONTACT is None:
            self.CONTACT = []
        else:
            self.CONTACT = CONTACT
        self.CONTACT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTACTSType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTACTSType31.subclass:
            return CONTACTSType31.subclass(*args_, **kwargs_)
        else:
            return CONTACTSType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CONTACT(self):
        return self.CONTACT
    def set_CONTACT(self, CONTACT):
        self.CONTACT = CONTACT
    def add_CONTACT(self, value):
        self.CONTACT.append(value)
    def insert_CONTACT_at(self, index, value):
        self.CONTACT.insert(index, value)
    def replace_CONTACT_at(self, index, value):
        self.CONTACT[index] = value
    def _hasContent(self):
        if (
            self.CONTACT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTSType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTACTSType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONTACTSType31':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTACTSType31')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTACTSType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTACTSType31'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTSType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CONTACT_ in self.CONTACT:
            namespaceprefix_ = self.CONTACT_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTACT_nsprefix_) else ''
            CONTACT_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONTACT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CONTACT':
            obj_ = CONTACTType32.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CONTACT.append(obj_)
            obj_.original_tagname_ = 'CONTACT'
# end class CONTACTSType31


class CONTACTType32(GeneratedsSuper):
    """name --
    Name of contact person for this submission.

    * inform_on_status --
      Internet address of person or service to inform on any status changes for this submission.

    * inform_on_error --
      Internet address of person or service to inform on any errors for this submission.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, inform_on_status=None, inform_on_error=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.inform_on_status = _cast(None, inform_on_status)
        self.inform_on_status_nsprefix_ = None
        self.inform_on_error = _cast(None, inform_on_error)
        self.inform_on_error_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONTACTType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONTACTType32.subclass:
            return CONTACTType32.subclass(*args_, **kwargs_)
        else:
            return CONTACTType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_inform_on_status(self):
        return self.inform_on_status
    def set_inform_on_status(self, inform_on_status):
        self.inform_on_status = inform_on_status
    def get_inform_on_error(self):
        return self.inform_on_error
    def set_inform_on_error(self, inform_on_error):
        self.inform_on_error = inform_on_error
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONTACTType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CONTACTType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CONTACTType32')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CONTACTType32', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CONTACTType32'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.inform_on_status is not None and 'inform_on_status' not in already_processed:
            already_processed.add('inform_on_status')
            outfile.write(' inform_on_status=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inform_on_status), input_name='inform_on_status')), ))
        if self.inform_on_error is not None and 'inform_on_error' not in already_processed:
            already_processed.add('inform_on_error')
            outfile.write(' inform_on_error=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inform_on_error), input_name='inform_on_error')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CONTACTType32', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('inform_on_status', node)
        if value is not None and 'inform_on_status' not in already_processed:
            already_processed.add('inform_on_status')
            self.inform_on_status = value
        value = find_attr_value_('inform_on_error', node)
        if value is not None and 'inform_on_error' not in already_processed:
            already_processed.add('inform_on_error')
            self.inform_on_error = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CONTACTType32


class ACTIONSType33(GeneratedsSuper):
    """ACTION -- Action to be executed by the archive.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ACTION=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ACTION is None:
            self.ACTION = []
        else:
            self.ACTION = ACTION
        self.ACTION_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACTIONSType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACTIONSType33.subclass:
            return ACTIONSType33.subclass(*args_, **kwargs_)
        else:
            return ACTIONSType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ACTION(self):
        return self.ACTION
    def set_ACTION(self, ACTION):
        self.ACTION = ACTION
    def add_ACTION(self, value):
        self.ACTION.append(value)
    def insert_ACTION_at(self, index, value):
        self.ACTION.insert(index, value)
    def replace_ACTION_at(self, index, value):
        self.ACTION[index] = value
    def _hasContent(self):
        if (
            self.ACTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ACTIONSType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACTIONSType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ACTIONSType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACTIONSType33')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACTIONSType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACTIONSType33'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ACTIONSType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ACTION_ in self.ACTION:
            namespaceprefix_ = self.ACTION_nsprefix_ + ':' if (UseCapturedNS_ and self.ACTION_nsprefix_) else ''
            ACTION_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ACTION', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ACTION':
            obj_ = ACTIONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ACTION.append(obj_)
            obj_.original_tagname_ = 'ACTION'
# end class ACTIONSType33


class ACTIONType(GeneratedsSuper):
    """ACTIONType -- Action to be executed by the archive.
    ADD -- Add an object to the archive.
    MODIFY -- Modify an object in the archive.
    CANCEL -- Cancels a private object and its dependent objects.
    SUPPRESS -- Suppresses a public object and its dependent objects.
    KILL -- Kills a public object and its dependent objects.
    HOLD -- Make the object public only when the hold date expires.
    RELEASE -- The object will be released immediately to public.
    PROTECT -- This action is required for data submitted to European Genome-Phenome Archive (EGA).
    ROLLBACK -- This action will rollback the submission from the database
    VALIDATE -- Validates the submitted XMLs without actually submitting them.
    RECEIPT -- Returns the receipt for a given submission alias.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ADD=None, MODIFY=None, CANCEL=None, SUPPRESS=None, KILL=None, HOLD=None, RELEASE=None, PROTECT=None, ROLLBACK=None, VALIDATE=None, RECEIPT=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ADD = ADD
        self.ADD_nsprefix_ = None
        self.MODIFY = MODIFY
        self.MODIFY_nsprefix_ = None
        self.CANCEL = CANCEL
        self.CANCEL_nsprefix_ = None
        self.SUPPRESS = SUPPRESS
        self.SUPPRESS_nsprefix_ = None
        self.KILL = KILL
        self.KILL_nsprefix_ = None
        self.HOLD = HOLD
        self.HOLD_nsprefix_ = None
        self.RELEASE = RELEASE
        self.RELEASE_nsprefix_ = None
        self.PROTECT = PROTECT
        self.PROTECT_nsprefix_ = None
        self.ROLLBACK = ROLLBACK
        self.ROLLBACK_nsprefix_ = None
        self.VALIDATE = VALIDATE
        self.VALIDATE_nsprefix_ = None
        self.RECEIPT = RECEIPT
        self.RECEIPT_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ACTIONType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ACTIONType.subclass:
            return ACTIONType.subclass(*args_, **kwargs_)
        else:
            return ACTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ADD(self):
        return self.ADD
    def set_ADD(self, ADD):
        self.ADD = ADD
    def get_MODIFY(self):
        return self.MODIFY
    def set_MODIFY(self, MODIFY):
        self.MODIFY = MODIFY
    def get_CANCEL(self):
        return self.CANCEL
    def set_CANCEL(self, CANCEL):
        self.CANCEL = CANCEL
    def get_SUPPRESS(self):
        return self.SUPPRESS
    def set_SUPPRESS(self, SUPPRESS):
        self.SUPPRESS = SUPPRESS
    def get_KILL(self):
        return self.KILL
    def set_KILL(self, KILL):
        self.KILL = KILL
    def get_HOLD(self):
        return self.HOLD
    def set_HOLD(self, HOLD):
        self.HOLD = HOLD
    def get_RELEASE(self):
        return self.RELEASE
    def set_RELEASE(self, RELEASE):
        self.RELEASE = RELEASE
    def get_PROTECT(self):
        return self.PROTECT
    def set_PROTECT(self, PROTECT):
        self.PROTECT = PROTECT
    def get_ROLLBACK(self):
        return self.ROLLBACK
    def set_ROLLBACK(self, ROLLBACK):
        self.ROLLBACK = ROLLBACK
    def get_VALIDATE(self):
        return self.VALIDATE
    def set_VALIDATE(self, VALIDATE):
        self.VALIDATE = VALIDATE
    def get_RECEIPT(self):
        return self.RECEIPT
    def set_RECEIPT(self, RECEIPT):
        self.RECEIPT = RECEIPT
    def _hasContent(self):
        if (
            self.ADD is not None or
            self.MODIFY is not None or
            self.CANCEL is not None or
            self.SUPPRESS is not None or
            self.KILL is not None or
            self.HOLD is not None or
            self.RELEASE is not None or
            self.PROTECT is not None or
            self.ROLLBACK is not None or
            self.VALIDATE is not None or
            self.RECEIPT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ACTIONType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ACTIONType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ACTIONType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ACTIONType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ACTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ACTIONType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ACTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ADD is not None:
            namespaceprefix_ = self.ADD_nsprefix_ + ':' if (UseCapturedNS_ and self.ADD_nsprefix_) else ''
            self.ADD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ADD', pretty_print=pretty_print)
        if self.MODIFY is not None:
            namespaceprefix_ = self.MODIFY_nsprefix_ + ':' if (UseCapturedNS_ and self.MODIFY_nsprefix_) else ''
            self.MODIFY.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MODIFY', pretty_print=pretty_print)
        if self.CANCEL is not None:
            namespaceprefix_ = self.CANCEL_nsprefix_ + ':' if (UseCapturedNS_ and self.CANCEL_nsprefix_) else ''
            self.CANCEL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CANCEL', pretty_print=pretty_print)
        if self.SUPPRESS is not None:
            namespaceprefix_ = self.SUPPRESS_nsprefix_ + ':' if (UseCapturedNS_ and self.SUPPRESS_nsprefix_) else ''
            self.SUPPRESS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUPPRESS', pretty_print=pretty_print)
        if self.KILL is not None:
            namespaceprefix_ = self.KILL_nsprefix_ + ':' if (UseCapturedNS_ and self.KILL_nsprefix_) else ''
            self.KILL.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KILL', pretty_print=pretty_print)
        if self.HOLD is not None:
            namespaceprefix_ = self.HOLD_nsprefix_ + ':' if (UseCapturedNS_ and self.HOLD_nsprefix_) else ''
            self.HOLD.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HOLD', pretty_print=pretty_print)
        if self.RELEASE is not None:
            namespaceprefix_ = self.RELEASE_nsprefix_ + ':' if (UseCapturedNS_ and self.RELEASE_nsprefix_) else ''
            self.RELEASE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELEASE', pretty_print=pretty_print)
        if self.PROTECT is not None:
            namespaceprefix_ = self.PROTECT_nsprefix_ + ':' if (UseCapturedNS_ and self.PROTECT_nsprefix_) else ''
            self.PROTECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROTECT', pretty_print=pretty_print)
        if self.ROLLBACK is not None:
            namespaceprefix_ = self.ROLLBACK_nsprefix_ + ':' if (UseCapturedNS_ and self.ROLLBACK_nsprefix_) else ''
            self.ROLLBACK.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ROLLBACK', pretty_print=pretty_print)
        if self.VALIDATE is not None:
            namespaceprefix_ = self.VALIDATE_nsprefix_ + ':' if (UseCapturedNS_ and self.VALIDATE_nsprefix_) else ''
            self.VALIDATE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VALIDATE', pretty_print=pretty_print)
        if self.RECEIPT is not None:
            namespaceprefix_ = self.RECEIPT_nsprefix_ + ':' if (UseCapturedNS_ and self.RECEIPT_nsprefix_) else ''
            self.RECEIPT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RECEIPT', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ADD':
            obj_ = ADDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ADD = obj_
            obj_.original_tagname_ = 'ADD'
        elif nodeName_ == 'MODIFY':
            obj_ = MODIFYType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MODIFY = obj_
            obj_.original_tagname_ = 'MODIFY'
        elif nodeName_ == 'CANCEL':
            obj_ = CANCELType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CANCEL = obj_
            obj_.original_tagname_ = 'CANCEL'
        elif nodeName_ == 'SUPPRESS':
            obj_ = SUPPRESSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUPPRESS = obj_
            obj_.original_tagname_ = 'SUPPRESS'
        elif nodeName_ == 'KILL':
            obj_ = KILLType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KILL = obj_
            obj_.original_tagname_ = 'KILL'
        elif nodeName_ == 'HOLD':
            obj_ = HOLDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HOLD = obj_
            obj_.original_tagname_ = 'HOLD'
        elif nodeName_ == 'RELEASE':
            obj_ = RELEASEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELEASE = obj_
            obj_.original_tagname_ = 'RELEASE'
        elif nodeName_ == 'PROTECT':
            obj_ = PROTECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROTECT = obj_
            obj_.original_tagname_ = 'PROTECT'
        elif nodeName_ == 'ROLLBACK':
            obj_ = ROLLBACKType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ROLLBACK = obj_
            obj_.original_tagname_ = 'ROLLBACK'
        elif nodeName_ == 'VALIDATE':
            obj_ = VALIDATEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VALIDATE = obj_
            obj_.original_tagname_ = 'VALIDATE'
        elif nodeName_ == 'RECEIPT':
            obj_ = RECEIPTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RECEIPT = obj_
            obj_.original_tagname_ = 'RECEIPT'
# end class ACTIONType


class ADDType(GeneratedsSuper):
    """ADDType -- Add an object to the archive.
    source -- Filename or relative path to the XML file being submitted.
    schema -- The type of the XML file being submitted.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.schema = _cast(None, schema)
        self.schema_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ADDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ADDType.subclass:
            return ADDType.subclass(*args_, **kwargs_)
        else:
            return ADDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_schema(self):
        return self.schema
    def set_schema(self, schema):
        self.schema = schema
    def validate_schemaType(self, value):
        # Validate type schemaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['study', 'experiment', 'sample', 'run', 'analysis', 'dataset', 'policy', 'dac', 'project', 'checklist', 'sampleGroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemaType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ADDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ADDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ADDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ADDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ADDType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.schema), input_name='schema')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ADDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
            self.validate_schemaType(self.schema)    # validate type schemaType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ADDType


class MODIFYType(GeneratedsSuper):
    """MODIFYType -- Modify an object in the archive.
    source -- Filename or relative path to the XML file being updated.
    schema -- The type of the XML file being updated.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.schema = _cast(None, schema)
        self.schema_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MODIFYType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MODIFYType.subclass:
            return MODIFYType.subclass(*args_, **kwargs_)
        else:
            return MODIFYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_schema(self):
        return self.schema
    def set_schema(self, schema):
        self.schema = schema
    def validate_schemaType34(self, value):
        # Validate type schemaType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['study', 'experiment', 'sample', 'run', 'analysis', 'dataset', 'policy', 'dac', 'project', 'checklist', 'sampleGroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemaType34' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MODIFYType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MODIFYType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MODIFYType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MODIFYType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MODIFYType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MODIFYType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.schema), input_name='schema')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MODIFYType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
            self.validate_schemaType34(self.schema)    # validate type schemaType34
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MODIFYType


class CANCELType(GeneratedsSuper):
    """CANCELType -- Cancels a private object and its dependent objects.
    target -- Accession or refname of the object that is being cancelled.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CANCELType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CANCELType.subclass:
            return CANCELType.subclass(*args_, **kwargs_)
        else:
            return CANCELType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CANCELType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CANCELType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CANCELType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CANCELType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CANCELType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CANCELType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CANCELType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CANCELType


class SUPPRESSType(GeneratedsSuper):
    """SUPPRESSType -- Suppresses a public object and its dependent objects.
    target -- Accession or refname of the object that is being suppressed.
    HoldUntilDate -- The date when a temporarily suppressed object will be made public.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, HoldUntilDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        if isinstance(HoldUntilDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(HoldUntilDate, '%Y-%m-%d').date()
        else:
            initvalue_ = HoldUntilDate
        self.HoldUntilDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUPPRESSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUPPRESSType.subclass:
            return SUPPRESSType.subclass(*args_, **kwargs_)
        else:
            return SUPPRESSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_HoldUntilDate(self):
        return self.HoldUntilDate
    def set_HoldUntilDate(self, HoldUntilDate):
        self.HoldUntilDate = HoldUntilDate
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUPPRESSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SUPPRESSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SUPPRESSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SUPPRESSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SUPPRESSType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SUPPRESSType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.HoldUntilDate is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            outfile.write(' HoldUntilDate="%s"' % self.gds_format_date(self.HoldUntilDate, input_name='HoldUntilDate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUPPRESSType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('HoldUntilDate', node)
        if value is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            try:
                self.HoldUntilDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (HoldUntilDate): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SUPPRESSType


class KILLType(GeneratedsSuper):
    """KILLType -- Kills a public object and its dependent objects.
    target -- Accession or refname of the object that is being killed.
    HoldUntilDate -- The date when a temporarily killed object will be made public.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, HoldUntilDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        if isinstance(HoldUntilDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(HoldUntilDate, '%Y-%m-%d').date()
        else:
            initvalue_ = HoldUntilDate
        self.HoldUntilDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KILLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KILLType.subclass:
            return KILLType.subclass(*args_, **kwargs_)
        else:
            return KILLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_HoldUntilDate(self):
        return self.HoldUntilDate
    def set_HoldUntilDate(self, HoldUntilDate):
        self.HoldUntilDate = HoldUntilDate
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='KILLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KILLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KILLType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KILLType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KILLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='KILLType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.HoldUntilDate is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            outfile.write(' HoldUntilDate="%s"' % self.gds_format_date(self.HoldUntilDate, input_name='HoldUntilDate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='KILLType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('HoldUntilDate', node)
        if value is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            try:
                self.HoldUntilDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (HoldUntilDate): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class KILLType


class HOLDType(GeneratedsSuper):
    """HOLDType -- Make the object public only when the hold date expires.
    target --
    Accession or refname of the object that is being made public
    when the hold date expires. If not specified then
    all objects in the submission will be assigned the hold date.

    * HoldUntilDate -- The date when the submission will be made public.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, HoldUntilDate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        if isinstance(HoldUntilDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(HoldUntilDate, '%Y-%m-%d').date()
        else:
            initvalue_ = HoldUntilDate
        self.HoldUntilDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HOLDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HOLDType.subclass:
            return HOLDType.subclass(*args_, **kwargs_)
        else:
            return HOLDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_HoldUntilDate(self):
        return self.HoldUntilDate
    def set_HoldUntilDate(self, HoldUntilDate):
        self.HoldUntilDate = HoldUntilDate
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HOLDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HOLDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HOLDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HOLDType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HOLDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HOLDType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.HoldUntilDate is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            outfile.write(' HoldUntilDate="%s"' % self.gds_format_date(self.HoldUntilDate, input_name='HoldUntilDate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HOLDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('HoldUntilDate', node)
        if value is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            try:
                self.HoldUntilDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (HoldUntilDate): %s' % exp)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class HOLDType


class RELEASEType(GeneratedsSuper):
    """RELEASEType -- The object will be released immediately to public.
    target --
    Accession or refname of the object that is made public.
    If not specified then all objects in the submission will
    made public.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RELEASEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RELEASEType.subclass:
            return RELEASEType.subclass(*args_, **kwargs_)
        else:
            return RELEASEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELEASEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RELEASEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RELEASEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RELEASEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RELEASEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RELEASEType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RELEASEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RELEASEType


class PROTECTType(GeneratedsSuper):
    """PROTECTType -- This action is required for data submitted to European Genome-Phenome Archive (EGA).

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PROTECTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PROTECTType.subclass:
            return PROTECTType.subclass(*args_, **kwargs_)
        else:
            return PROTECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROTECTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PROTECTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PROTECTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PROTECTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PROTECTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PROTECTType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PROTECTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PROTECTType


class ROLLBACKType(GeneratedsSuper):
    """ROLLBACKType -- This action will rollback the submission from the database

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROLLBACKType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROLLBACKType.subclass:
            return ROLLBACKType.subclass(*args_, **kwargs_)
        else:
            return ROLLBACKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ROLLBACKType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROLLBACKType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ROLLBACKType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ROLLBACKType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ROLLBACKType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ROLLBACKType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ROLLBACKType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ROLLBACKType


class VALIDATEType(GeneratedsSuper):
    """VALIDATEType -- Validates the submitted XMLs without actually submitting them.
    source -- Filename or relative path to the XML file being validated.
    schema -- The type of the XML file being validated.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.schema = _cast(None, schema)
        self.schema_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VALIDATEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VALIDATEType.subclass:
            return VALIDATEType.subclass(*args_, **kwargs_)
        else:
            return VALIDATEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_schema(self):
        return self.schema
    def set_schema(self, schema):
        self.schema = schema
    def validate_schemaType35(self, value):
        # Validate type schemaType35, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['study', 'experiment', 'sample', 'run', 'analysis', 'dataset', 'policy', 'dac', 'project', 'checklist', 'sampleGroup']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on schemaType35' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VALIDATEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VALIDATEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VALIDATEType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VALIDATEType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VALIDATEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VALIDATEType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.schema), input_name='schema')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VALIDATEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
            self.validate_schemaType35(self.schema)    # validate type schemaType35
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VALIDATEType


class RECEIPTType(GeneratedsSuper):
    """RECEIPTType -- Returns the receipt for a given submission alias.
    target -- Submission alias.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RECEIPTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RECEIPTType.subclass:
            return RECEIPTType.subclass(*args_, **kwargs_)
        else:
            return RECEIPTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RECEIPTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RECEIPTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RECEIPTType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RECEIPTType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RECEIPTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RECEIPTType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RECEIPTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RECEIPTType


class SUBMISSION_LINKSType(GeneratedsSuper):
    """SUBMISSION_LINKSType --
    Archive created links to associated submissions.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION_LINK=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SUBMISSION_LINK is None:
            self.SUBMISSION_LINK = []
        else:
            self.SUBMISSION_LINK = SUBMISSION_LINK
        self.SUBMISSION_LINK_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBMISSION_LINKSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBMISSION_LINKSType.subclass:
            return SUBMISSION_LINKSType.subclass(*args_, **kwargs_)
        else:
            return SUBMISSION_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SUBMISSION_LINK(self):
        return self.SUBMISSION_LINK
    def set_SUBMISSION_LINK(self, SUBMISSION_LINK):
        self.SUBMISSION_LINK = SUBMISSION_LINK
    def add_SUBMISSION_LINK(self, value):
        self.SUBMISSION_LINK.append(value)
    def insert_SUBMISSION_LINK_at(self, index, value):
        self.SUBMISSION_LINK.insert(index, value)
    def replace_SUBMISSION_LINK_at(self, index, value):
        self.SUBMISSION_LINK[index] = value
    def _hasContent(self):
        if (
            self.SUBMISSION_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_LINKSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SUBMISSION_LINKSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SUBMISSION_LINKSType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SUBMISSION_LINKSType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SUBMISSION_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SUBMISSION_LINKSType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_LINK_ in self.SUBMISSION_LINK:
            namespaceprefix_ = self.SUBMISSION_LINK_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_LINK_nsprefix_) else ''
            SUBMISSION_LINK_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION_LINK', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SUBMISSION_LINK':
            obj_ = LinkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION_LINK.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION_LINK'
# end class SUBMISSION_LINKSType


class SUBMISSION_ATTRIBUTESType(GeneratedsSuper):
    """SUBMISSION_ATTRIBUTESType --
    Archive assigned properties and attributes of a SUBMISSION.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION_ATTRIBUTE=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if SUBMISSION_ATTRIBUTE is None:
            self.SUBMISSION_ATTRIBUTE = []
        else:
            self.SUBMISSION_ATTRIBUTE = SUBMISSION_ATTRIBUTE
        self.SUBMISSION_ATTRIBUTE_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SUBMISSION_ATTRIBUTESType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SUBMISSION_ATTRIBUTESType.subclass:
            return SUBMISSION_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return SUBMISSION_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SUBMISSION_ATTRIBUTE(self):
        return self.SUBMISSION_ATTRIBUTE
    def set_SUBMISSION_ATTRIBUTE(self, SUBMISSION_ATTRIBUTE):
        self.SUBMISSION_ATTRIBUTE = SUBMISSION_ATTRIBUTE
    def add_SUBMISSION_ATTRIBUTE(self, value):
        self.SUBMISSION_ATTRIBUTE.append(value)
    def insert_SUBMISSION_ATTRIBUTE_at(self, index, value):
        self.SUBMISSION_ATTRIBUTE.insert(index, value)
    def replace_SUBMISSION_ATTRIBUTE_at(self, index, value):
        self.SUBMISSION_ATTRIBUTE[index] = value
    def _hasContent(self):
        if (
            self.SUBMISSION_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_ATTRIBUTESType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SUBMISSION_ATTRIBUTESType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SUBMISSION_ATTRIBUTESType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SUBMISSION_ATTRIBUTESType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SUBMISSION_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SUBMISSION_ATTRIBUTESType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SUBMISSION_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_ATTRIBUTE_ in self.SUBMISSION_ATTRIBUTE:
            namespaceprefix_ = self.SUBMISSION_ATTRIBUTE_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_ATTRIBUTE_nsprefix_) else ''
            SUBMISSION_ATTRIBUTE_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SUBMISSION_ATTRIBUTE':
            obj_ = AttributeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION_ATTRIBUTE'
# end class SUBMISSION_ATTRIBUTESType


class AnalysisType(ObjectType):
    """AnalysisType -- A SRA analysis object captures sequence analysis results including sequence alignments, sequence variations and sequence annotations.

    * analysis_center -- If applicable, the center name of the institution responsible
      for this analysis.
    * analysis_date -- The date when this analysis was produced.
    * TITLE -- Title of the analysis object which will be displayed in
      search results.
    * DESCRIPTION -- Describes the analysis in detail.
    * STUDY_REF -- Identifies the parent study.
    * SAMPLE_REF -- One of more samples associated with the
      analysis.
    * RUN_REF -- One or more runs associated with the
      analysis.
    * ANALYSIS_REF -- One or more analyses associated with the
      analysis.
    * ANALYSIS_TYPE -- The type of the analysis.
    * FILES -- Files associated with the
      analysis.
    * ANALYSIS_LINKS --  Links to resources related to this analysis.

    * ANALYSIS_ATTRIBUTES -- Properties and attributes of an analysis. These can be
      entered as free-form tag-value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, analysis_center=None, analysis_date=None, TITLE=None, DESCRIPTION=None, STUDY_REF=None, SAMPLE_REF=None, EXPERIMENT_REF=None, RUN_REF=None, ANALYSIS_REF=None, ANALYSIS_TYPE=None, FILES=None, ANALYSIS_LINKS=None, ANALYSIS_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AnalysisType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.analysis_center = _cast(None, analysis_center)
        self.analysis_center_nsprefix_ = None
        if isinstance(analysis_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(analysis_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = analysis_date
        self.analysis_date = initvalue_
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.STUDY_REF = STUDY_REF
        self.STUDY_REF_nsprefix_ = None
        if SAMPLE_REF is None:
            self.SAMPLE_REF = []
        else:
            self.SAMPLE_REF = SAMPLE_REF
        self.SAMPLE_REF_nsprefix_ = None
        if EXPERIMENT_REF is None:
            self.EXPERIMENT_REF = []
        else:
            self.EXPERIMENT_REF = EXPERIMENT_REF
        self.EXPERIMENT_REF_nsprefix_ = None
        if RUN_REF is None:
            self.RUN_REF = []
        else:
            self.RUN_REF = RUN_REF
        self.RUN_REF_nsprefix_ = None
        if ANALYSIS_REF is None:
            self.ANALYSIS_REF = []
        else:
            self.ANALYSIS_REF = ANALYSIS_REF
        self.ANALYSIS_REF_nsprefix_ = None
        self.ANALYSIS_TYPE = ANALYSIS_TYPE
        self.ANALYSIS_TYPE_nsprefix_ = None
        self.FILES = FILES
        self.FILES_nsprefix_ = None
        self.ANALYSIS_LINKS = ANALYSIS_LINKS
        self.ANALYSIS_LINKS_nsprefix_ = None
        self.ANALYSIS_ATTRIBUTES = ANALYSIS_ATTRIBUTES
        self.ANALYSIS_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnalysisType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnalysisType.subclass:
            return AnalysisType.subclass(*args_, **kwargs_)
        else:
            return AnalysisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_STUDY_REF(self):
        return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF
    def get_SAMPLE_REF(self):
        return self.SAMPLE_REF
    def set_SAMPLE_REF(self, SAMPLE_REF):
        self.SAMPLE_REF = SAMPLE_REF
    def add_SAMPLE_REF(self, value):
        self.SAMPLE_REF.append(value)
    def insert_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF.insert(index, value)
    def replace_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF[index] = value
    def get_EXPERIMENT_REF(self):
        return self.EXPERIMENT_REF
    def set_EXPERIMENT_REF(self, EXPERIMENT_REF):
        self.EXPERIMENT_REF = EXPERIMENT_REF
    def add_EXPERIMENT_REF(self, value):
        self.EXPERIMENT_REF.append(value)
    def insert_EXPERIMENT_REF_at(self, index, value):
        self.EXPERIMENT_REF.insert(index, value)
    def replace_EXPERIMENT_REF_at(self, index, value):
        self.EXPERIMENT_REF[index] = value
    def get_RUN_REF(self):
        return self.RUN_REF
    def set_RUN_REF(self, RUN_REF):
        self.RUN_REF = RUN_REF
    def add_RUN_REF(self, value):
        self.RUN_REF.append(value)
    def insert_RUN_REF_at(self, index, value):
        self.RUN_REF.insert(index, value)
    def replace_RUN_REF_at(self, index, value):
        self.RUN_REF[index] = value
    def get_ANALYSIS_REF(self):
        return self.ANALYSIS_REF
    def set_ANALYSIS_REF(self, ANALYSIS_REF):
        self.ANALYSIS_REF = ANALYSIS_REF
    def add_ANALYSIS_REF(self, value):
        self.ANALYSIS_REF.append(value)
    def insert_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF.insert(index, value)
    def replace_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF[index] = value
    def get_ANALYSIS_TYPE(self):
        return self.ANALYSIS_TYPE
    def set_ANALYSIS_TYPE(self, ANALYSIS_TYPE):
        self.ANALYSIS_TYPE = ANALYSIS_TYPE
    def get_FILES(self):
        return self.FILES
    def set_FILES(self, FILES):
        self.FILES = FILES
    def get_ANALYSIS_LINKS(self):
        return self.ANALYSIS_LINKS
    def set_ANALYSIS_LINKS(self, ANALYSIS_LINKS):
        self.ANALYSIS_LINKS = ANALYSIS_LINKS
    def get_ANALYSIS_ATTRIBUTES(self):
        return self.ANALYSIS_ATTRIBUTES
    def set_ANALYSIS_ATTRIBUTES(self, ANALYSIS_ATTRIBUTES):
        self.ANALYSIS_ATTRIBUTES = ANALYSIS_ATTRIBUTES
    def get_analysis_center(self):
        return self.analysis_center
    def set_analysis_center(self, analysis_center):
        self.analysis_center = analysis_center
    def get_analysis_date(self):
        return self.analysis_date
    def set_analysis_date(self, analysis_date):
        self.analysis_date = analysis_date
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.STUDY_REF is not None or
            self.SAMPLE_REF or
            self.EXPERIMENT_REF or
            self.RUN_REF or
            self.ANALYSIS_REF or
            self.ANALYSIS_TYPE is not None or
            self.FILES is not None or
            self.ANALYSIS_LINKS is not None or
            self.ANALYSIS_ATTRIBUTES is not None or
            super(AnalysisType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnalysisType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnalysisType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnalysisType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnalysisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnalysisType'):
        super(AnalysisType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnalysisType')
        if self.analysis_center is not None and 'analysis_center' not in already_processed:
            already_processed.add('analysis_center')
            outfile.write(' analysis_center=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.analysis_center), input_name='analysis_center')), ))
        if self.analysis_date is not None and 'analysis_date' not in already_processed:
            already_processed.add('analysis_date')
            outfile.write(' analysis_date="%s"' % self.gds_format_datetime(self.analysis_date, input_name='analysis_date'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnalysisType', fromsubclass_=False, pretty_print=True):
        super(AnalysisType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.STUDY_REF is not None:
            namespaceprefix_ = self.STUDY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_REF_nsprefix_) else ''
            self.STUDY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_REF', pretty_print=pretty_print)
        for SAMPLE_REF_ in self.SAMPLE_REF:
            namespaceprefix_ = self.SAMPLE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_REF_nsprefix_) else ''
            SAMPLE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_REF', pretty_print=pretty_print)
        for EXPERIMENT_REF_ in self.EXPERIMENT_REF:
            namespaceprefix_ = self.EXPERIMENT_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.EXPERIMENT_REF_nsprefix_) else ''
            EXPERIMENT_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EXPERIMENT_REF', pretty_print=pretty_print)
        for RUN_REF_ in self.RUN_REF:
            namespaceprefix_ = self.RUN_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_REF_nsprefix_) else ''
            RUN_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_REF', pretty_print=pretty_print)
        for ANALYSIS_REF_ in self.ANALYSIS_REF:
            namespaceprefix_ = self.ANALYSIS_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_REF_nsprefix_) else ''
            ANALYSIS_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_REF', pretty_print=pretty_print)
        if self.ANALYSIS_TYPE is not None:
            namespaceprefix_ = self.ANALYSIS_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_TYPE_nsprefix_) else ''
            self.ANALYSIS_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_TYPE', pretty_print=pretty_print)
        if self.FILES is not None:
            namespaceprefix_ = self.FILES_nsprefix_ + ':' if (UseCapturedNS_ and self.FILES_nsprefix_) else ''
            self.FILES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILES', pretty_print=pretty_print)
        if self.ANALYSIS_LINKS is not None:
            namespaceprefix_ = self.ANALYSIS_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_LINKS_nsprefix_) else ''
            self.ANALYSIS_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_LINKS', pretty_print=pretty_print)
        if self.ANALYSIS_ATTRIBUTES is not None:
            namespaceprefix_ = self.ANALYSIS_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_ATTRIBUTES_nsprefix_) else ''
            self.ANALYSIS_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('analysis_center', node)
        if value is not None and 'analysis_center' not in already_processed:
            already_processed.add('analysis_center')
            self.analysis_center = value
        value = find_attr_value_('analysis_date', node)
        if value is not None and 'analysis_date' not in already_processed:
            already_processed.add('analysis_date')
            try:
                self.analysis_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (analysis_date): %s' % exp)
        super(AnalysisType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'SAMPLE_REF':
            obj_ = SAMPLE_REFType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_REF.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_REF'
        elif nodeName_ == 'EXPERIMENT_REF':
            obj_ = EXPERIMENT_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EXPERIMENT_REF.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT_REF'
        elif nodeName_ == 'RUN_REF':
            obj_ = RUN_REFType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_REF.append(obj_)
            obj_.original_tagname_ = 'RUN_REF'
        elif nodeName_ == 'ANALYSIS_REF':
            obj_ = ANALYSIS_REFType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_REF.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_REF'
        elif nodeName_ == 'ANALYSIS_TYPE':
            obj_ = ANALYSIS_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_TYPE = obj_
            obj_.original_tagname_ = 'ANALYSIS_TYPE'
        elif nodeName_ == 'FILES':
            obj_ = FILESType22.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
        elif nodeName_ == 'ANALYSIS_LINKS':
            obj_ = ANALYSIS_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_LINKS = obj_
            obj_.original_tagname_ = 'ANALYSIS_LINKS'
        elif nodeName_ == 'ANALYSIS_ATTRIBUTES':
            obj_ = ANALYSIS_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'ANALYSIS_ATTRIBUTES'
        super(AnalysisType, self)._buildChildren(child_, node, nodeName_, True)
# end class AnalysisType


class ProjectType(ObjectType):
    """NAME --  A short name of the project.
    TITLE --  A short descriptive title for the project.

    * DESCRIPTION --  A long description of the scope of the project.

    * SUBMISSION_PROJECT --  A project for grouping submitted data together.

    * UMBRELLA_PROJECT --  A project for grouping other projects together.

    * RELATED_PROJECTS --  Other projects related to this project.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, first_public=None, NAME=None, TITLE=None, DESCRIPTION=None, COLLABORATORS=None, SUBMISSION_PROJECT=None, UMBRELLA_PROJECT=None, RELATED_PROJECTS=None, PROJECT_LINKS=None, PROJECT_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProjectType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        if isinstance(first_public, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(first_public, '%Y-%m-%d').date()
        else:
            initvalue_ = first_public
        self.first_public = initvalue_
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.COLLABORATORS = COLLABORATORS
        self.COLLABORATORS_nsprefix_ = None
        self.SUBMISSION_PROJECT = SUBMISSION_PROJECT
        self.SUBMISSION_PROJECT_nsprefix_ = None
        self.UMBRELLA_PROJECT = UMBRELLA_PROJECT
        self.UMBRELLA_PROJECT_nsprefix_ = None
        self.RELATED_PROJECTS = RELATED_PROJECTS
        self.RELATED_PROJECTS_nsprefix_ = None
        self.PROJECT_LINKS = PROJECT_LINKS
        self.PROJECT_LINKS_nsprefix_ = None
        self.PROJECT_ATTRIBUTES = PROJECT_ATTRIBUTES
        self.PROJECT_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectType.subclass:
            return ProjectType.subclass(*args_, **kwargs_)
        else:
            return ProjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_COLLABORATORS(self):
        return self.COLLABORATORS
    def set_COLLABORATORS(self, COLLABORATORS):
        self.COLLABORATORS = COLLABORATORS
    def get_SUBMISSION_PROJECT(self):
        return self.SUBMISSION_PROJECT
    def set_SUBMISSION_PROJECT(self, SUBMISSION_PROJECT):
        self.SUBMISSION_PROJECT = SUBMISSION_PROJECT
    def get_UMBRELLA_PROJECT(self):
        return self.UMBRELLA_PROJECT
    def set_UMBRELLA_PROJECT(self, UMBRELLA_PROJECT):
        self.UMBRELLA_PROJECT = UMBRELLA_PROJECT
    def get_RELATED_PROJECTS(self):
        return self.RELATED_PROJECTS
    def set_RELATED_PROJECTS(self, RELATED_PROJECTS):
        self.RELATED_PROJECTS = RELATED_PROJECTS
    def get_PROJECT_LINKS(self):
        return self.PROJECT_LINKS
    def set_PROJECT_LINKS(self, PROJECT_LINKS):
        self.PROJECT_LINKS = PROJECT_LINKS
    def get_PROJECT_ATTRIBUTES(self):
        return self.PROJECT_ATTRIBUTES
    def set_PROJECT_ATTRIBUTES(self, PROJECT_ATTRIBUTES):
        self.PROJECT_ATTRIBUTES = PROJECT_ATTRIBUTES
    def get_first_public(self):
        return self.first_public
    def set_first_public(self, first_public):
        self.first_public = first_public
    def _hasContent(self):
        if (
            self.NAME is not None or
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.COLLABORATORS is not None or
            self.SUBMISSION_PROJECT is not None or
            self.UMBRELLA_PROJECT is not None or
            self.RELATED_PROJECTS is not None or
            self.PROJECT_LINKS is not None or
            self.PROJECT_ATTRIBUTES is not None or
            super(ProjectType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectType'):
        super(ProjectType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectType')
        if self.first_public is not None and 'first_public' not in already_processed:
            already_processed.add('first_public')
            outfile.write(' first_public="%s"' % self.gds_format_date(self.first_public, input_name='first_public'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectType', fromsubclass_=False, pretty_print=True):
        super(ProjectType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.COLLABORATORS is not None:
            namespaceprefix_ = self.COLLABORATORS_nsprefix_ + ':' if (UseCapturedNS_ and self.COLLABORATORS_nsprefix_) else ''
            self.COLLABORATORS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COLLABORATORS', pretty_print=pretty_print)
        if self.SUBMISSION_PROJECT is not None:
            namespaceprefix_ = self.SUBMISSION_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.SUBMISSION_PROJECT_nsprefix_) else ''
            self.SUBMISSION_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SUBMISSION_PROJECT', pretty_print=pretty_print)
        if self.UMBRELLA_PROJECT is not None:
            namespaceprefix_ = self.UMBRELLA_PROJECT_nsprefix_ + ':' if (UseCapturedNS_ and self.UMBRELLA_PROJECT_nsprefix_) else ''
            self.UMBRELLA_PROJECT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UMBRELLA_PROJECT', pretty_print=pretty_print)
        if self.RELATED_PROJECTS is not None:
            namespaceprefix_ = self.RELATED_PROJECTS_nsprefix_ + ':' if (UseCapturedNS_ and self.RELATED_PROJECTS_nsprefix_) else ''
            self.RELATED_PROJECTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RELATED_PROJECTS', pretty_print=pretty_print)
        if self.PROJECT_LINKS is not None:
            namespaceprefix_ = self.PROJECT_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_LINKS_nsprefix_) else ''
            self.PROJECT_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT_LINKS', pretty_print=pretty_print)
        if self.PROJECT_ATTRIBUTES is not None:
            namespaceprefix_ = self.PROJECT_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.PROJECT_ATTRIBUTES_nsprefix_) else ''
            self.PROJECT_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PROJECT_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('first_public', node)
        if value is not None and 'first_public' not in already_processed:
            already_processed.add('first_public')
            try:
                self.first_public = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (first_public): %s' % exp)
        super(ProjectType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'COLLABORATORS':
            obj_ = COLLABORATORSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.COLLABORATORS = obj_
            obj_.original_tagname_ = 'COLLABORATORS'
        elif nodeName_ == 'SUBMISSION_PROJECT':
            obj_ = SUBMISSION_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SUBMISSION_PROJECT = obj_
            obj_.original_tagname_ = 'SUBMISSION_PROJECT'
        elif nodeName_ == 'UMBRELLA_PROJECT':
            obj_ = UMBRELLA_PROJECTType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UMBRELLA_PROJECT = obj_
            obj_.original_tagname_ = 'UMBRELLA_PROJECT'
        elif nodeName_ == 'RELATED_PROJECTS':
            obj_ = RELATED_PROJECTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RELATED_PROJECTS = obj_
            obj_.original_tagname_ = 'RELATED_PROJECTS'
        elif nodeName_ == 'PROJECT_LINKS':
            obj_ = PROJECT_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT_LINKS = obj_
            obj_.original_tagname_ = 'PROJECT_LINKS'
        elif nodeName_ == 'PROJECT_ATTRIBUTES':
            obj_ = PROJECT_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PROJECT_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'PROJECT_ATTRIBUTES'
        super(ProjectType, self)._buildChildren(child_, node, nodeName_, True)
# end class ProjectType


class ChecklistType(ObjectType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, checklistType=None, DESCRIPTOR=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ChecklistType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.checklistType = _cast(None, checklistType)
        self.checklistType_nsprefix_ = None
        self.DESCRIPTOR = DESCRIPTOR
        self.DESCRIPTOR_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChecklistType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChecklistType.subclass:
            return ChecklistType.subclass(*args_, **kwargs_)
        else:
            return ChecklistType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DESCRIPTOR(self):
        return self.DESCRIPTOR
    def set_DESCRIPTOR(self, DESCRIPTOR):
        self.DESCRIPTOR = DESCRIPTOR
    def get_checklistType(self):
        return self.checklistType
    def set_checklistType(self, checklistType):
        self.checklistType = checklistType
    def _hasContent(self):
        if (
            self.DESCRIPTOR is not None or
            super(ChecklistType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChecklistType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChecklistType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChecklistType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChecklistType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChecklistType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChecklistType'):
        super(ChecklistType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChecklistType')
        if self.checklistType is not None and 'checklistType' not in already_processed:
            already_processed.add('checklistType')
            outfile.write(' checklistType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.checklistType), input_name='checklistType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChecklistType', fromsubclass_=False, pretty_print=True):
        super(ChecklistType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTOR is not None:
            namespaceprefix_ = self.DESCRIPTOR_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTOR_nsprefix_) else ''
            self.DESCRIPTOR.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DESCRIPTOR', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('checklistType', node)
        if value is not None and 'checklistType' not in already_processed:
            already_processed.add('checklistType')
            self.checklistType = value
        super(ChecklistType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DESCRIPTOR':
            obj_ = DESCRIPTORType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DESCRIPTOR = obj_
            obj_.original_tagname_ = 'DESCRIPTOR'
        super(ChecklistType, self)._buildChildren(child_, node, nodeName_, True)
# end class ChecklistType


class AssemblyType(ObjectType):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, DESCRIPTION=None, NAME=None, ASSEMBLY_LEVEL=None, GENOME_REPRESENTATION=None, TAXON=None, SAMPLE_REF=None, STUDY_REF=None, WGS_SET=None, CHROMOSOMES=None, ASSEMBLY_LINKS=None, ASSEMBLY_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AssemblyType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.NAME = NAME
        self.NAME_nsprefix_ = None
        self.ASSEMBLY_LEVEL = ASSEMBLY_LEVEL
        self.validate_ASSEMBLY_LEVELType(self.ASSEMBLY_LEVEL)
        self.ASSEMBLY_LEVEL_nsprefix_ = None
        self.GENOME_REPRESENTATION = GENOME_REPRESENTATION
        self.validate_GENOME_REPRESENTATIONType(self.GENOME_REPRESENTATION)
        self.GENOME_REPRESENTATION_nsprefix_ = None
        self.TAXON = TAXON
        self.TAXON_nsprefix_ = None
        self.SAMPLE_REF = SAMPLE_REF
        self.SAMPLE_REF_nsprefix_ = None
        self.STUDY_REF = STUDY_REF
        self.STUDY_REF_nsprefix_ = None
        if WGS_SET is None:
            self.WGS_SET = []
        else:
            self.WGS_SET = WGS_SET
        self.WGS_SET_nsprefix_ = None
        self.CHROMOSOMES = CHROMOSOMES
        self.CHROMOSOMES_nsprefix_ = None
        self.ASSEMBLY_LINKS = ASSEMBLY_LINKS
        self.ASSEMBLY_LINKS_nsprefix_ = None
        self.ASSEMBLY_ATTRIBUTES = ASSEMBLY_ATTRIBUTES
        self.ASSEMBLY_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssemblyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssemblyType.subclass:
            return AssemblyType.subclass(*args_, **kwargs_)
        else:
            return AssemblyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_NAME(self):
        return self.NAME
    def set_NAME(self, NAME):
        self.NAME = NAME
    def get_ASSEMBLY_LEVEL(self):
        return self.ASSEMBLY_LEVEL
    def set_ASSEMBLY_LEVEL(self, ASSEMBLY_LEVEL):
        self.ASSEMBLY_LEVEL = ASSEMBLY_LEVEL
    def get_GENOME_REPRESENTATION(self):
        return self.GENOME_REPRESENTATION
    def set_GENOME_REPRESENTATION(self, GENOME_REPRESENTATION):
        self.GENOME_REPRESENTATION = GENOME_REPRESENTATION
    def get_TAXON(self):
        return self.TAXON
    def set_TAXON(self, TAXON):
        self.TAXON = TAXON
    def get_SAMPLE_REF(self):
        return self.SAMPLE_REF
    def set_SAMPLE_REF(self, SAMPLE_REF):
        self.SAMPLE_REF = SAMPLE_REF
    def get_STUDY_REF(self):
        return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF
    def get_WGS_SET(self):
        return self.WGS_SET
    def set_WGS_SET(self, WGS_SET):
        self.WGS_SET = WGS_SET
    def add_WGS_SET(self, value):
        self.WGS_SET.append(value)
    def insert_WGS_SET_at(self, index, value):
        self.WGS_SET.insert(index, value)
    def replace_WGS_SET_at(self, index, value):
        self.WGS_SET[index] = value
    def get_CHROMOSOMES(self):
        return self.CHROMOSOMES
    def set_CHROMOSOMES(self, CHROMOSOMES):
        self.CHROMOSOMES = CHROMOSOMES
    def get_ASSEMBLY_LINKS(self):
        return self.ASSEMBLY_LINKS
    def set_ASSEMBLY_LINKS(self, ASSEMBLY_LINKS):
        self.ASSEMBLY_LINKS = ASSEMBLY_LINKS
    def get_ASSEMBLY_ATTRIBUTES(self):
        return self.ASSEMBLY_ATTRIBUTES
    def set_ASSEMBLY_ATTRIBUTES(self, ASSEMBLY_ATTRIBUTES):
        self.ASSEMBLY_ATTRIBUTES = ASSEMBLY_ATTRIBUTES
    def validate_ASSEMBLY_LEVELType(self, value):
        result = True
        # Validate type ASSEMBLY_LEVELType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['complete genome', 'chromosome', 'scaffold', 'contig']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ASSEMBLY_LEVELType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_GENOME_REPRESENTATIONType(self, value):
        result = True
        # Validate type GENOME_REPRESENTATIONType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['full', 'partial']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on GENOME_REPRESENTATIONType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.NAME is not None or
            self.ASSEMBLY_LEVEL is not None or
            self.GENOME_REPRESENTATION is not None or
            self.TAXON is not None or
            self.SAMPLE_REF is not None or
            self.STUDY_REF is not None or
            self.WGS_SET or
            self.CHROMOSOMES is not None or
            self.ASSEMBLY_LINKS is not None or
            self.ASSEMBLY_ATTRIBUTES is not None or
            super(AssemblyType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssemblyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssemblyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblyType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssemblyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssemblyType'):
        super(AssemblyType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssemblyType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssemblyType', fromsubclass_=False, pretty_print=True):
        super(AssemblyType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.NAME is not None:
            namespaceprefix_ = self.NAME_nsprefix_ + ':' if (UseCapturedNS_ and self.NAME_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NAME), input_name='NAME')), namespaceprefix_ , eol_))
        if self.ASSEMBLY_LEVEL is not None:
            namespaceprefix_ = self.ASSEMBLY_LEVEL_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_LEVEL_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sASSEMBLY_LEVEL>%s</%sASSEMBLY_LEVEL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ASSEMBLY_LEVEL), input_name='ASSEMBLY_LEVEL')), namespaceprefix_ , eol_))
        if self.GENOME_REPRESENTATION is not None:
            namespaceprefix_ = self.GENOME_REPRESENTATION_nsprefix_ + ':' if (UseCapturedNS_ and self.GENOME_REPRESENTATION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGENOME_REPRESENTATION>%s</%sGENOME_REPRESENTATION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.GENOME_REPRESENTATION), input_name='GENOME_REPRESENTATION')), namespaceprefix_ , eol_))
        if self.TAXON is not None:
            namespaceprefix_ = self.TAXON_nsprefix_ + ':' if (UseCapturedNS_ and self.TAXON_nsprefix_) else ''
            self.TAXON.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TAXON', pretty_print=pretty_print)
        if self.SAMPLE_REF is not None:
            namespaceprefix_ = self.SAMPLE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_REF_nsprefix_) else ''
            self.SAMPLE_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_REF', pretty_print=pretty_print)
        if self.STUDY_REF is not None:
            namespaceprefix_ = self.STUDY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_REF_nsprefix_) else ''
            self.STUDY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_REF', pretty_print=pretty_print)
        for WGS_SET_ in self.WGS_SET:
            namespaceprefix_ = self.WGS_SET_nsprefix_ + ':' if (UseCapturedNS_ and self.WGS_SET_nsprefix_) else ''
            WGS_SET_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='WGS_SET', pretty_print=pretty_print)
        if self.CHROMOSOMES is not None:
            namespaceprefix_ = self.CHROMOSOMES_nsprefix_ + ':' if (UseCapturedNS_ and self.CHROMOSOMES_nsprefix_) else ''
            self.CHROMOSOMES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CHROMOSOMES', pretty_print=pretty_print)
        if self.ASSEMBLY_LINKS is not None:
            namespaceprefix_ = self.ASSEMBLY_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_LINKS_nsprefix_) else ''
            self.ASSEMBLY_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY_LINKS', pretty_print=pretty_print)
        if self.ASSEMBLY_ATTRIBUTES is not None:
            namespaceprefix_ = self.ASSEMBLY_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.ASSEMBLY_ATTRIBUTES_nsprefix_) else ''
            self.ASSEMBLY_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ASSEMBLY_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AssemblyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'NAME':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'NAME')
            value_ = self.gds_validate_string(value_, node, 'NAME')
            self.NAME = value_
            self.NAME_nsprefix_ = child_.prefix
        elif nodeName_ == 'ASSEMBLY_LEVEL':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ASSEMBLY_LEVEL')
            value_ = self.gds_validate_string(value_, node, 'ASSEMBLY_LEVEL')
            self.ASSEMBLY_LEVEL = value_
            self.ASSEMBLY_LEVEL_nsprefix_ = child_.prefix
            # validate type ASSEMBLY_LEVELType
            self.validate_ASSEMBLY_LEVELType(self.ASSEMBLY_LEVEL)
        elif nodeName_ == 'GENOME_REPRESENTATION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'GENOME_REPRESENTATION')
            value_ = self.gds_validate_string(value_, node, 'GENOME_REPRESENTATION')
            self.GENOME_REPRESENTATION = value_
            self.GENOME_REPRESENTATION_nsprefix_ = child_.prefix
            # validate type GENOME_REPRESENTATIONType
            self.validate_GENOME_REPRESENTATIONType(self.GENOME_REPRESENTATION)
        elif nodeName_ == 'TAXON':
            obj_ = TAXONType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TAXON = obj_
            obj_.original_tagname_ = 'TAXON'
        elif nodeName_ == 'SAMPLE_REF':
            obj_ = SAMPLE_REFType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_REF = obj_
            obj_.original_tagname_ = 'SAMPLE_REF'
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'WGS_SET':
            obj_ = WGS_SETType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.WGS_SET.append(obj_)
            obj_.original_tagname_ = 'WGS_SET'
        elif nodeName_ == 'CHROMOSOMES':
            obj_ = CHROMOSOMESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CHROMOSOMES = obj_
            obj_.original_tagname_ = 'CHROMOSOMES'
        elif nodeName_ == 'ASSEMBLY_LINKS':
            obj_ = ASSEMBLY_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY_LINKS = obj_
            obj_.original_tagname_ = 'ASSEMBLY_LINKS'
        elif nodeName_ == 'ASSEMBLY_ATTRIBUTES':
            obj_ = ASSEMBLY_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ASSEMBLY_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'ASSEMBLY_ATTRIBUTES'
        super(AssemblyType, self)._buildChildren(child_, node, nodeName_, True)
# end class AssemblyType


class PolicyType(ObjectType):
    """PolicyType -- Describes an object that contains data access policy information.
    TITLE -- Short text that can be used to call out data access policies in searches or in displays.
    DAC_REF -- Identifies the data access committee to which this policy pertains.

    * POLICY_TEXT -- Text containing the policy.
    * POLICY_FILE -- File containing the policy text.
    * DATA_USES -- Data use ontologies (DUO) related to the policy
    * POLICY_LINKS -- Links to related resources.
    * POLICY_ATTRIBUTES -- Properties and attributes of the policy. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, DAC_REF=None, POLICY_TEXT=None, POLICY_FILE=None, DATA_USES=None, POLICY_LINKS=None, POLICY_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PolicyType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DAC_REF = DAC_REF
        self.DAC_REF_nsprefix_ = None
        self.POLICY_TEXT = POLICY_TEXT
        self.POLICY_TEXT_nsprefix_ = None
        self.POLICY_FILE = POLICY_FILE
        self.POLICY_FILE_nsprefix_ = None
        self.DATA_USES = DATA_USES
        self.DATA_USES_nsprefix_ = None
        self.POLICY_LINKS = POLICY_LINKS
        self.POLICY_LINKS_nsprefix_ = None
        self.POLICY_ATTRIBUTES = POLICY_ATTRIBUTES
        self.POLICY_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolicyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolicyType.subclass:
            return PolicyType.subclass(*args_, **kwargs_)
        else:
            return PolicyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DAC_REF(self):
        return self.DAC_REF
    def set_DAC_REF(self, DAC_REF):
        self.DAC_REF = DAC_REF
    def get_POLICY_TEXT(self):
        return self.POLICY_TEXT
    def set_POLICY_TEXT(self, POLICY_TEXT):
        self.POLICY_TEXT = POLICY_TEXT
    def get_POLICY_FILE(self):
        return self.POLICY_FILE
    def set_POLICY_FILE(self, POLICY_FILE):
        self.POLICY_FILE = POLICY_FILE
    def get_DATA_USES(self):
        return self.DATA_USES
    def set_DATA_USES(self, DATA_USES):
        self.DATA_USES = DATA_USES
    def get_POLICY_LINKS(self):
        return self.POLICY_LINKS
    def set_POLICY_LINKS(self, POLICY_LINKS):
        self.POLICY_LINKS = POLICY_LINKS
    def get_POLICY_ATTRIBUTES(self):
        return self.POLICY_ATTRIBUTES
    def set_POLICY_ATTRIBUTES(self, POLICY_ATTRIBUTES):
        self.POLICY_ATTRIBUTES = POLICY_ATTRIBUTES
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DAC_REF is not None or
            self.POLICY_TEXT is not None or
            self.POLICY_FILE is not None or
            self.DATA_USES is not None or
            self.POLICY_LINKS is not None or
            self.POLICY_ATTRIBUTES is not None or
            super(PolicyType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolicyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolicyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolicyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolicyType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolicyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolicyType'):
        super(PolicyType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolicyType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PolicyType', fromsubclass_=False, pretty_print=True):
        super(PolicyType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DAC_REF is not None:
            namespaceprefix_ = self.DAC_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_REF_nsprefix_) else ''
            self.DAC_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC_REF', pretty_print=pretty_print)
        if self.POLICY_TEXT is not None:
            namespaceprefix_ = self.POLICY_TEXT_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_TEXT_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOLICY_TEXT>%s</%sPOLICY_TEXT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.POLICY_TEXT), input_name='POLICY_TEXT')), namespaceprefix_ , eol_))
        if self.POLICY_FILE is not None:
            namespaceprefix_ = self.POLICY_FILE_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_FILE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOLICY_FILE>%s</%sPOLICY_FILE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.POLICY_FILE), input_name='POLICY_FILE')), namespaceprefix_ , eol_))
        if self.DATA_USES is not None:
            namespaceprefix_ = self.DATA_USES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATA_USES_nsprefix_) else ''
            self.DATA_USES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATA_USES', pretty_print=pretty_print)
        if self.POLICY_LINKS is not None:
            namespaceprefix_ = self.POLICY_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_LINKS_nsprefix_) else ''
            self.POLICY_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY_LINKS', pretty_print=pretty_print)
        if self.POLICY_ATTRIBUTES is not None:
            namespaceprefix_ = self.POLICY_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_ATTRIBUTES_nsprefix_) else ''
            self.POLICY_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PolicyType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DAC_REF':
            obj_ = DAC_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC_REF = obj_
            obj_.original_tagname_ = 'DAC_REF'
        elif nodeName_ == 'POLICY_TEXT':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'POLICY_TEXT')
            value_ = self.gds_validate_string(value_, node, 'POLICY_TEXT')
            self.POLICY_TEXT = value_
            self.POLICY_TEXT_nsprefix_ = child_.prefix
        elif nodeName_ == 'POLICY_FILE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'POLICY_FILE')
            value_ = self.gds_validate_string(value_, node, 'POLICY_FILE')
            self.POLICY_FILE = value_
            self.POLICY_FILE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATA_USES':
            obj_ = DATA_USESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATA_USES = obj_
            obj_.original_tagname_ = 'DATA_USES'
        elif nodeName_ == 'POLICY_LINKS':
            obj_ = POLICY_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY_LINKS = obj_
            obj_.original_tagname_ = 'POLICY_LINKS'
        elif nodeName_ == 'POLICY_ATTRIBUTES':
            obj_ = POLICY_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'POLICY_ATTRIBUTES'
        super(PolicyType, self)._buildChildren(child_, node, nodeName_, True)
# end class PolicyType


class DatasetType(ObjectType):
    """DatasetType -- Describes an object that contains the samples in the data set.

    * TITLE -- Short text that can be used to call out data sets in searches or in displays.
    * DESCRIPTION --
      Free-form text describing the data sets.

    * RUN_REF --
      Identifies the runs which are part of this dataset.

    * ANALYSIS_REF --
      Identifies the analyses which are part of this dataset.

    * POLICY_REF -- Identifies the data access policy controlling this data set.

    * DATASET_LINKS -- Links to related resources.
    * DATASET_ATTRIBUTES -- Properties and attributes of the data set. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, DESCRIPTION=None, DATASET_TYPE=None, RUN_REF=None, ANALYSIS_REF=None, POLICY_REF=None, DATASET_LINKS=None, DATASET_ATTRIBUTES=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DatasetType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS, extensiontype_,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        if DATASET_TYPE is None:
            self.DATASET_TYPE = []
        else:
            self.DATASET_TYPE = DATASET_TYPE
        self.DATASET_TYPE_nsprefix_ = None
        if RUN_REF is None:
            self.RUN_REF = []
        else:
            self.RUN_REF = RUN_REF
        self.RUN_REF_nsprefix_ = None
        if ANALYSIS_REF is None:
            self.ANALYSIS_REF = []
        else:
            self.ANALYSIS_REF = ANALYSIS_REF
        self.ANALYSIS_REF_nsprefix_ = None
        self.POLICY_REF = POLICY_REF
        self.POLICY_REF_nsprefix_ = None
        self.DATASET_LINKS = DATASET_LINKS
        self.DATASET_LINKS_nsprefix_ = None
        self.DATASET_ATTRIBUTES = DATASET_ATTRIBUTES
        self.DATASET_ATTRIBUTES_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatasetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatasetType.subclass:
            return DatasetType.subclass(*args_, **kwargs_)
        else:
            return DatasetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_DATASET_TYPE(self):
        return self.DATASET_TYPE
    def set_DATASET_TYPE(self, DATASET_TYPE):
        self.DATASET_TYPE = DATASET_TYPE
    def add_DATASET_TYPE(self, value):
        self.DATASET_TYPE.append(value)
    def insert_DATASET_TYPE_at(self, index, value):
        self.DATASET_TYPE.insert(index, value)
    def replace_DATASET_TYPE_at(self, index, value):
        self.DATASET_TYPE[index] = value
    def get_RUN_REF(self):
        return self.RUN_REF
    def set_RUN_REF(self, RUN_REF):
        self.RUN_REF = RUN_REF
    def add_RUN_REF(self, value):
        self.RUN_REF.append(value)
    def insert_RUN_REF_at(self, index, value):
        self.RUN_REF.insert(index, value)
    def replace_RUN_REF_at(self, index, value):
        self.RUN_REF[index] = value
    def get_ANALYSIS_REF(self):
        return self.ANALYSIS_REF
    def set_ANALYSIS_REF(self, ANALYSIS_REF):
        self.ANALYSIS_REF = ANALYSIS_REF
    def add_ANALYSIS_REF(self, value):
        self.ANALYSIS_REF.append(value)
    def insert_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF.insert(index, value)
    def replace_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF[index] = value
    def get_POLICY_REF(self):
        return self.POLICY_REF
    def set_POLICY_REF(self, POLICY_REF):
        self.POLICY_REF = POLICY_REF
    def get_DATASET_LINKS(self):
        return self.DATASET_LINKS
    def set_DATASET_LINKS(self, DATASET_LINKS):
        self.DATASET_LINKS = DATASET_LINKS
    def get_DATASET_ATTRIBUTES(self):
        return self.DATASET_ATTRIBUTES
    def set_DATASET_ATTRIBUTES(self, DATASET_ATTRIBUTES):
        self.DATASET_ATTRIBUTES = DATASET_ATTRIBUTES
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_DATASET_TYPEType9(self, value):
        result = True
        # Validate type DATASET_TYPEType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Whole genome sequencing', 'Exome sequencing', 'Genotyping by array', 'Transcriptome profiling by high-throughput sequencing', 'Transcriptome profiling by array', 'Amplicon sequencing', 'Methylation binding domain sequencing', 'Methylation profiling by high-throughput sequencing', 'Phenotype information', 'Study summary information', 'Genomic variant calling', 'Chromatin accessibility profiling by high-throughput sequencing', 'Histone modification profiling by high-throughput sequencing', 'Chip-Seq']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATASET_TYPEType9' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.DATASET_TYPE or
            self.RUN_REF or
            self.ANALYSIS_REF or
            self.POLICY_REF is not None or
            self.DATASET_LINKS is not None or
            self.DATASET_ATTRIBUTES is not None or
            super(DatasetType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DatasetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatasetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DatasetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatasetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DatasetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DatasetType'):
        super(DatasetType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatasetType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DatasetType', fromsubclass_=False, pretty_print=True):
        super(DatasetType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        for DATASET_TYPE_ in self.DATASET_TYPE:
            namespaceprefix_ = self.DATASET_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASET_TYPE>%s</%sDATASET_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DATASET_TYPE_), input_name='DATASET_TYPE')), namespaceprefix_ , eol_))
        for RUN_REF_ in self.RUN_REF:
            namespaceprefix_ = self.RUN_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.RUN_REF_nsprefix_) else ''
            RUN_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RUN_REF', pretty_print=pretty_print)
        for ANALYSIS_REF_ in self.ANALYSIS_REF:
            namespaceprefix_ = self.ANALYSIS_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.ANALYSIS_REF_nsprefix_) else ''
            ANALYSIS_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANALYSIS_REF', pretty_print=pretty_print)
        if self.POLICY_REF is not None:
            namespaceprefix_ = self.POLICY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.POLICY_REF_nsprefix_) else ''
            self.POLICY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='POLICY_REF', pretty_print=pretty_print)
        if self.DATASET_LINKS is not None:
            namespaceprefix_ = self.DATASET_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_LINKS_nsprefix_) else ''
            self.DATASET_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_LINKS', pretty_print=pretty_print)
        if self.DATASET_ATTRIBUTES is not None:
            namespaceprefix_ = self.DATASET_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_ATTRIBUTES_nsprefix_) else ''
            self.DATASET_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DatasetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'DATASET_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASET_TYPE')
            value_ = self.gds_validate_string(value_, node, 'DATASET_TYPE')
            self.DATASET_TYPE.append(value_)
            self.DATASET_TYPE_nsprefix_ = child_.prefix
            # validate type DATASET_TYPEType9
            self.validate_DATASET_TYPEType9(self.DATASET_TYPE[-1])
        elif nodeName_ == 'RUN_REF':
            obj_ = RUN_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RUN_REF.append(obj_)
            obj_.original_tagname_ = 'RUN_REF'
        elif nodeName_ == 'ANALYSIS_REF':
            obj_ = ANALYSIS_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANALYSIS_REF.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_REF'
        elif nodeName_ == 'POLICY_REF':
            obj_ = POLICY_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.POLICY_REF = obj_
            obj_.original_tagname_ = 'POLICY_REF'
        elif nodeName_ == 'DATASET_LINKS':
            obj_ = DATASET_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_LINKS = obj_
            obj_.original_tagname_ = 'DATASET_LINKS'
        elif nodeName_ == 'DATASET_ATTRIBUTES':
            obj_ = DATASET_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'DATASET_ATTRIBUTES'
        super(DatasetType, self)._buildChildren(child_, node, nodeName_, True)
# end class DatasetType


class DacType(ObjectType):
    """DacType -- Describes an object that contains data access comittee  information including contacts.

    * TITLE --
      Short text that can be used to call out DAC records in searches or in displays.

    * DAC_LINKS -- Links to related resources.
    * DAC_ATTRIBUTES -- Properties and attributes of the DAC. These can be entered as free-form tag-value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, CONTACTS=None, DAC_LINKS=None, DAC_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DacType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.CONTACTS = CONTACTS
        self.CONTACTS_nsprefix_ = None
        self.DAC_LINKS = DAC_LINKS
        self.DAC_LINKS_nsprefix_ = None
        self.DAC_ATTRIBUTES = DAC_ATTRIBUTES
        self.DAC_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DacType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DacType.subclass:
            return DacType.subclass(*args_, **kwargs_)
        else:
            return DacType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_CONTACTS(self):
        return self.CONTACTS
    def set_CONTACTS(self, CONTACTS):
        self.CONTACTS = CONTACTS
    def get_DAC_LINKS(self):
        return self.DAC_LINKS
    def set_DAC_LINKS(self, DAC_LINKS):
        self.DAC_LINKS = DAC_LINKS
    def get_DAC_ATTRIBUTES(self):
        return self.DAC_ATTRIBUTES
    def set_DAC_ATTRIBUTES(self, DAC_ATTRIBUTES):
        self.DAC_ATTRIBUTES = DAC_ATTRIBUTES
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.CONTACTS is not None or
            self.DAC_LINKS is not None or
            self.DAC_ATTRIBUTES is not None or
            super(DacType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DacType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DacType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DacType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DacType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DacType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DacType'):
        super(DacType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DacType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DacType', fromsubclass_=False, pretty_print=True):
        super(DacType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.CONTACTS is not None:
            namespaceprefix_ = self.CONTACTS_nsprefix_ + ':' if (UseCapturedNS_ and self.CONTACTS_nsprefix_) else ''
            self.CONTACTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CONTACTS', pretty_print=pretty_print)
        if self.DAC_LINKS is not None:
            namespaceprefix_ = self.DAC_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_LINKS_nsprefix_) else ''
            self.DAC_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC_LINKS', pretty_print=pretty_print)
        if self.DAC_ATTRIBUTES is not None:
            namespaceprefix_ = self.DAC_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DAC_ATTRIBUTES_nsprefix_) else ''
            self.DAC_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DAC_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DacType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'CONTACTS':
            obj_ = CONTACTSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CONTACTS = obj_
            obj_.original_tagname_ = 'CONTACTS'
        elif nodeName_ == 'DAC_LINKS':
            obj_ = DAC_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC_LINKS = obj_
            obj_.original_tagname_ = 'DAC_LINKS'
        elif nodeName_ == 'DAC_ATTRIBUTES':
            obj_ = DAC_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DAC_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'DAC_ATTRIBUTES'
        super(DacType, self)._buildChildren(child_, node, nodeName_, True)
# end class DacType


class BPSampleType(SampleType):
    """BPSampleType --
    A Sample defines an biological item.

    * SAMPLE_TYPE -- The type of the sample.
    * SAMPLE_REF -- One of more samples associated with the
      sample.
    * SAMPLE_CODED_ATTRIBUTES --
      Properties and attributes of a sample.  These can be entered as
      tag-coded value pairs. For certain studies, submitters may be asked to follow a
      community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SampleType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, SAMPLE_NAME=None, DESCRIPTION=None, SAMPLE_LINKS=None, SAMPLE_ATTRIBUTES=None, SAMPLE_TYPE=None, SAMPLE_REF=None, SAMPLE_CODED_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BPSampleType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS, TITLE, SAMPLE_NAME, DESCRIPTION, SAMPLE_LINKS, SAMPLE_ATTRIBUTES,  **kwargs_)
        self.SAMPLE_TYPE = SAMPLE_TYPE
        self.SAMPLE_TYPE_nsprefix_ = None
        if SAMPLE_REF is None:
            self.SAMPLE_REF = []
        else:
            self.SAMPLE_REF = SAMPLE_REF
        self.SAMPLE_REF_nsprefix_ = None
        self.SAMPLE_CODED_ATTRIBUTES = SAMPLE_CODED_ATTRIBUTES
        self.SAMPLE_CODED_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BPSampleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BPSampleType.subclass:
            return BPSampleType.subclass(*args_, **kwargs_)
        else:
            return BPSampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SAMPLE_TYPE(self):
        return self.SAMPLE_TYPE
    def set_SAMPLE_TYPE(self, SAMPLE_TYPE):
        self.SAMPLE_TYPE = SAMPLE_TYPE
    def get_SAMPLE_REF(self):
        return self.SAMPLE_REF
    def set_SAMPLE_REF(self, SAMPLE_REF):
        self.SAMPLE_REF = SAMPLE_REF
    def add_SAMPLE_REF(self, value):
        self.SAMPLE_REF.append(value)
    def insert_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF.insert(index, value)
    def replace_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF[index] = value
    def get_SAMPLE_CODED_ATTRIBUTES(self):
        return self.SAMPLE_CODED_ATTRIBUTES
    def set_SAMPLE_CODED_ATTRIBUTES(self, SAMPLE_CODED_ATTRIBUTES):
        self.SAMPLE_CODED_ATTRIBUTES = SAMPLE_CODED_ATTRIBUTES
    def _hasContent(self):
        if (
            self.SAMPLE_TYPE is not None or
            self.SAMPLE_REF or
            self.SAMPLE_CODED_ATTRIBUTES is not None or
            super(BPSampleType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPSampleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BPSampleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BPSampleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPSampleType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BPSampleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BPSampleType'):
        super(BPSampleType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPSampleType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPSampleType', fromsubclass_=False, pretty_print=True):
        super(BPSampleType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_TYPE is not None:
            namespaceprefix_ = self.SAMPLE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_TYPE_nsprefix_) else ''
            self.SAMPLE_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_TYPE', pretty_print=pretty_print)
        for SAMPLE_REF_ in self.SAMPLE_REF:
            namespaceprefix_ = self.SAMPLE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_REF_nsprefix_) else ''
            SAMPLE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_REF', pretty_print=pretty_print)
        if self.SAMPLE_CODED_ATTRIBUTES is not None:
            namespaceprefix_ = self.SAMPLE_CODED_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_CODED_ATTRIBUTES_nsprefix_) else ''
            self.SAMPLE_CODED_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_CODED_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BPSampleType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SAMPLE_TYPE':
            obj_ = SAMPLE_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_TYPE = obj_
            obj_.original_tagname_ = 'SAMPLE_TYPE'
        elif nodeName_ == 'SAMPLE_REF':
            obj_ = SAMPLE_REFType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_REF.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_REF'
        elif nodeName_ == 'SAMPLE_CODED_ATTRIBUTES':
            obj_ = SAMPLE_CODED_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_CODED_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'SAMPLE_CODED_ATTRIBUTES'
        super(BPSampleType, self)._buildChildren(child_, node, nodeName_, True)
# end class BPSampleType


class ImageType(ObjectType):
    """ImageType -- A BP image object captures image objects.

    * image_center -- If applicable, the center name of the institution responsible
      for this image.
    * image_date -- The date when this image was produced.
    * TITLE -- Title of the image object which will be displayed in
      search results.
    * DESCRIPTION -- Describes the image in detail.
    * STUDY_REF -- Identifies the parent study.
    * SAMPLE_REF -- One of more samples associated with the
      image.
    * IMAGE_REF -- One or more images associated with the
      image.
    * IMAGE_TYPE -- The type of the image.
    * FILES -- Files associated with the
      image.
    * IMAGE_LINKS --  Links to resources related to this image.

    * IMAGE_ATTRIBUTES -- Properties and attributes of an image. These can be
      entered as free-form tag-value pairs.
    * IMAGE_CODED_ATTRIBUTES -- Coded properties and attributes of an image. These can be
      entered as tag-coded value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, image_center=None, image_date=None, TITLE=None, DESCRIPTION=None, STUDY_REF=None, SAMPLE_REF=None, IMAGE_REF=None, IMAGE_TYPE=None, FILES=None, IMAGE_LINKS=None, IMAGE_ATTRIBUTES=None, IMAGE_CODED_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ImageType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.image_center = _cast(None, image_center)
        self.image_center_nsprefix_ = None
        if isinstance(image_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(image_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = image_date
        self.image_date = initvalue_
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.STUDY_REF = STUDY_REF
        self.STUDY_REF_nsprefix_ = None
        if SAMPLE_REF is None:
            self.SAMPLE_REF = []
        else:
            self.SAMPLE_REF = SAMPLE_REF
        self.SAMPLE_REF_nsprefix_ = None
        if IMAGE_REF is None:
            self.IMAGE_REF = []
        else:
            self.IMAGE_REF = IMAGE_REF
        self.IMAGE_REF_nsprefix_ = None
        self.IMAGE_TYPE = IMAGE_TYPE
        self.IMAGE_TYPE_nsprefix_ = None
        self.FILES = FILES
        self.FILES_nsprefix_ = None
        self.IMAGE_LINKS = IMAGE_LINKS
        self.IMAGE_LINKS_nsprefix_ = None
        self.IMAGE_ATTRIBUTES = IMAGE_ATTRIBUTES
        self.IMAGE_ATTRIBUTES_nsprefix_ = None
        self.IMAGE_CODED_ATTRIBUTES = IMAGE_CODED_ATTRIBUTES
        self.IMAGE_CODED_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImageType.subclass:
            return ImageType.subclass(*args_, **kwargs_)
        else:
            return ImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_STUDY_REF(self):
        return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF
    def get_SAMPLE_REF(self):
        return self.SAMPLE_REF
    def set_SAMPLE_REF(self, SAMPLE_REF):
        self.SAMPLE_REF = SAMPLE_REF
    def add_SAMPLE_REF(self, value):
        self.SAMPLE_REF.append(value)
    def insert_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF.insert(index, value)
    def replace_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF[index] = value
    def get_IMAGE_REF(self):
        return self.IMAGE_REF
    def set_IMAGE_REF(self, IMAGE_REF):
        self.IMAGE_REF = IMAGE_REF
    def add_IMAGE_REF(self, value):
        self.IMAGE_REF.append(value)
    def insert_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF.insert(index, value)
    def replace_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF[index] = value
    def get_IMAGE_TYPE(self):
        return self.IMAGE_TYPE
    def set_IMAGE_TYPE(self, IMAGE_TYPE):
        self.IMAGE_TYPE = IMAGE_TYPE
    def get_FILES(self):
        return self.FILES
    def set_FILES(self, FILES):
        self.FILES = FILES
    def get_IMAGE_LINKS(self):
        return self.IMAGE_LINKS
    def set_IMAGE_LINKS(self, IMAGE_LINKS):
        self.IMAGE_LINKS = IMAGE_LINKS
    def get_IMAGE_ATTRIBUTES(self):
        return self.IMAGE_ATTRIBUTES
    def set_IMAGE_ATTRIBUTES(self, IMAGE_ATTRIBUTES):
        self.IMAGE_ATTRIBUTES = IMAGE_ATTRIBUTES
    def get_IMAGE_CODED_ATTRIBUTES(self):
        return self.IMAGE_CODED_ATTRIBUTES
    def set_IMAGE_CODED_ATTRIBUTES(self, IMAGE_CODED_ATTRIBUTES):
        self.IMAGE_CODED_ATTRIBUTES = IMAGE_CODED_ATTRIBUTES
    def get_image_center(self):
        return self.image_center
    def set_image_center(self, image_center):
        self.image_center = image_center
    def get_image_date(self):
        return self.image_date
    def set_image_date(self, image_date):
        self.image_date = image_date
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.STUDY_REF is not None or
            self.SAMPLE_REF or
            self.IMAGE_REF or
            self.IMAGE_TYPE is not None or
            self.FILES is not None or
            self.IMAGE_LINKS is not None or
            self.IMAGE_ATTRIBUTES is not None or
            self.IMAGE_CODED_ATTRIBUTES is not None or
            super(ImageType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ImageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ImageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImageType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ImageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ImageType'):
        super(ImageType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ImageType')
        if self.image_center is not None and 'image_center' not in already_processed:
            already_processed.add('image_center')
            outfile.write(' image_center=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image_center), input_name='image_center')), ))
        if self.image_date is not None and 'image_date' not in already_processed:
            already_processed.add('image_date')
            outfile.write(' image_date="%s"' % self.gds_format_datetime(self.image_date, input_name='image_date'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ImageType', fromsubclass_=False, pretty_print=True):
        super(ImageType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.STUDY_REF is not None:
            namespaceprefix_ = self.STUDY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_REF_nsprefix_) else ''
            self.STUDY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_REF', pretty_print=pretty_print)
        for SAMPLE_REF_ in self.SAMPLE_REF:
            namespaceprefix_ = self.SAMPLE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.SAMPLE_REF_nsprefix_) else ''
            SAMPLE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SAMPLE_REF', pretty_print=pretty_print)
        for IMAGE_REF_ in self.IMAGE_REF:
            namespaceprefix_ = self.IMAGE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_REF_nsprefix_) else ''
            IMAGE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_REF', pretty_print=pretty_print)
        if self.IMAGE_TYPE is not None:
            namespaceprefix_ = self.IMAGE_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_TYPE_nsprefix_) else ''
            self.IMAGE_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_TYPE', pretty_print=pretty_print)
        if self.FILES is not None:
            namespaceprefix_ = self.FILES_nsprefix_ + ':' if (UseCapturedNS_ and self.FILES_nsprefix_) else ''
            self.FILES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILES', pretty_print=pretty_print)
        if self.IMAGE_LINKS is not None:
            namespaceprefix_ = self.IMAGE_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_LINKS_nsprefix_) else ''
            self.IMAGE_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_LINKS', pretty_print=pretty_print)
        if self.IMAGE_ATTRIBUTES is not None:
            namespaceprefix_ = self.IMAGE_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_ATTRIBUTES_nsprefix_) else ''
            self.IMAGE_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_ATTRIBUTES', pretty_print=pretty_print)
        if self.IMAGE_CODED_ATTRIBUTES is not None:
            namespaceprefix_ = self.IMAGE_CODED_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_CODED_ATTRIBUTES_nsprefix_) else ''
            self.IMAGE_CODED_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_CODED_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('image_center', node)
        if value is not None and 'image_center' not in already_processed:
            already_processed.add('image_center')
            self.image_center = value
        value = find_attr_value_('image_date', node)
        if value is not None and 'image_date' not in already_processed:
            already_processed.add('image_date')
            try:
                self.image_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (image_date): %s' % exp)
        super(ImageType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'SAMPLE_REF':
            obj_ = SAMPLE_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SAMPLE_REF.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_REF'
        elif nodeName_ == 'IMAGE_REF':
            obj_ = IMAGE_REFType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_REF.append(obj_)
            obj_.original_tagname_ = 'IMAGE_REF'
        elif nodeName_ == 'IMAGE_TYPE':
            obj_ = IMAGE_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_TYPE = obj_
            obj_.original_tagname_ = 'IMAGE_TYPE'
        elif nodeName_ == 'FILES':
            obj_ = FILESType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
        elif nodeName_ == 'IMAGE_LINKS':
            obj_ = IMAGE_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_LINKS = obj_
            obj_.original_tagname_ = 'IMAGE_LINKS'
        elif nodeName_ == 'IMAGE_ATTRIBUTES':
            obj_ = IMAGE_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'IMAGE_ATTRIBUTES'
        elif nodeName_ == 'IMAGE_CODED_ATTRIBUTES':
            obj_ = IMAGE_CODED_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_CODED_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'IMAGE_CODED_ATTRIBUTES'
        super(ImageType, self)._buildChildren(child_, node, nodeName_, True)
# end class ImageType


class BPDatasetType(DatasetType):
    """BPDatasetType -- Describes an object that contains the samples in the data set.

    * IMAGE_REF --
      Identifies the images which are part of this dataset.

    * ANNOTATION_REF --
      Identifies the annotations which are part of this dataset.

    * DATASET_CODED_ATTRIBUTES -- Coded properties and attributes of the data set. These can be entered as tag-code value pairs. Submitters may be asked to follow a community established ontology when describing the work.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = DatasetType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, DESCRIPTION=None, DATASET_TYPE=None, RUN_REF=None, ANALYSIS_REF=None, POLICY_REF=None, DATASET_LINKS=None, DATASET_ATTRIBUTES=None, IMAGE_REF=None, ANNOTATION_REF=None, DATASET_CODED_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BPDatasetType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS, TITLE, DESCRIPTION, DATASET_TYPE, RUN_REF, ANALYSIS_REF, POLICY_REF, DATASET_LINKS, DATASET_ATTRIBUTES,  **kwargs_)
        if DATASET_TYPE is None:
            self.DATASET_TYPE = []
        else:
            self.DATASET_TYPE = DATASET_TYPE
        self.DATASET_TYPE_nsprefix_ = None
        if IMAGE_REF is None:
            self.IMAGE_REF = []
        else:
            self.IMAGE_REF = IMAGE_REF
        self.IMAGE_REF_nsprefix_ = None
        if ANNOTATION_REF is None:
            self.ANNOTATION_REF = []
        else:
            self.ANNOTATION_REF = ANNOTATION_REF
        self.ANNOTATION_REF_nsprefix_ = None
        self.DATASET_CODED_ATTRIBUTES = DATASET_CODED_ATTRIBUTES
        self.DATASET_CODED_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BPDatasetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BPDatasetType.subclass:
            return BPDatasetType.subclass(*args_, **kwargs_)
        else:
            return BPDatasetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DATASET_TYPE(self):
        return self.DATASET_TYPE
    def set_DATASET_TYPE(self, DATASET_TYPE):
        self.DATASET_TYPE = DATASET_TYPE
    def add_DATASET_TYPE(self, value):
        self.DATASET_TYPE.append(value)
    def insert_DATASET_TYPE_at(self, index, value):
        self.DATASET_TYPE.insert(index, value)
    def replace_DATASET_TYPE_at(self, index, value):
        self.DATASET_TYPE[index] = value
    def get_IMAGE_REF(self):
        return self.IMAGE_REF
    def set_IMAGE_REF(self, IMAGE_REF):
        self.IMAGE_REF = IMAGE_REF
    def add_IMAGE_REF(self, value):
        self.IMAGE_REF.append(value)
    def insert_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF.insert(index, value)
    def replace_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF[index] = value
    def get_ANNOTATION_REF(self):
        return self.ANNOTATION_REF
    def set_ANNOTATION_REF(self, ANNOTATION_REF):
        self.ANNOTATION_REF = ANNOTATION_REF
    def add_ANNOTATION_REF(self, value):
        self.ANNOTATION_REF.append(value)
    def insert_ANNOTATION_REF_at(self, index, value):
        self.ANNOTATION_REF.insert(index, value)
    def replace_ANNOTATION_REF_at(self, index, value):
        self.ANNOTATION_REF[index] = value
    def get_DATASET_CODED_ATTRIBUTES(self):
        return self.DATASET_CODED_ATTRIBUTES
    def set_DATASET_CODED_ATTRIBUTES(self, DATASET_CODED_ATTRIBUTES):
        self.DATASET_CODED_ATTRIBUTES = DATASET_CODED_ATTRIBUTES
    def validate_DATASET_TYPEType(self, value):
        result = True
        # Validate type DATASET_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Whole slide imaging']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATASET_TYPEType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.DATASET_TYPE or
            self.IMAGE_REF or
            self.ANNOTATION_REF or
            self.DATASET_CODED_ATTRIBUTES is not None or
            super(BPDatasetType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPDatasetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BPDatasetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BPDatasetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPDatasetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BPDatasetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BPDatasetType'):
        super(BPDatasetType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BPDatasetType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BPDatasetType', fromsubclass_=False, pretty_print=True):
        super(BPDatasetType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DATASET_TYPE_ in self.DATASET_TYPE:
            namespaceprefix_ = self.DATASET_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_TYPE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDATASET_TYPE>%s</%sDATASET_TYPE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(DATASET_TYPE_), input_name='DATASET_TYPE')), namespaceprefix_ , eol_))
        for IMAGE_REF_ in self.IMAGE_REF:
            namespaceprefix_ = self.IMAGE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_REF_nsprefix_) else ''
            IMAGE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_REF', pretty_print=pretty_print)
        for ANNOTATION_REF_ in self.ANNOTATION_REF:
            namespaceprefix_ = self.ANNOTATION_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_REF_nsprefix_) else ''
            ANNOTATION_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_REF', pretty_print=pretty_print)
        if self.DATASET_CODED_ATTRIBUTES is not None:
            namespaceprefix_ = self.DATASET_CODED_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.DATASET_CODED_ATTRIBUTES_nsprefix_) else ''
            self.DATASET_CODED_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DATASET_CODED_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BPDatasetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DATASET_TYPE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DATASET_TYPE')
            value_ = self.gds_validate_string(value_, node, 'DATASET_TYPE')
            self.DATASET_TYPE.append(value_)
            self.DATASET_TYPE_nsprefix_ = child_.prefix
            # validate type DATASET_TYPEType
            self.validate_DATASET_TYPEType(self.DATASET_TYPE[-1])
        elif nodeName_ == 'IMAGE_REF':
            obj_ = IMAGE_REFType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_REF.append(obj_)
            obj_.original_tagname_ = 'IMAGE_REF'
        elif nodeName_ == 'ANNOTATION_REF':
            obj_ = ANNOTATION_REFType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_REF.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION_REF'
        elif nodeName_ == 'DATASET_CODED_ATTRIBUTES':
            obj_ = DATASET_CODED_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DATASET_CODED_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'DATASET_CODED_ATTRIBUTES'
        super(BPDatasetType, self)._buildChildren(child_, node, nodeName_, True)
# end class BPDatasetType


class AnnotationType(ObjectType):
    """AnnotationType -- A BP annotation object captures annotation objects.
    annotation_center -- If applicable, the center name of the institution responsible for this annotation.
    annotation_date -- The date when this annotation was produced.
    TITLE -- Title of the annotation object which will be displayed in search results.
    DESCRIPTION -- Describes the annotation in detail.
    STUDY_REF -- Identifies the parent study.
    IMAGE_REF -- One or more images associated with the annotation.
    ANNOTATION_REF -- One or more annotations associated with the annotation.
    ANNOTATION_TYPE -- The type of the annotation.
    FILES -- Files associated with the image.
    ANNOTATION_LINKS --  Links to resources related to this annotation.
    ANNOTATION_ATTRIBUTES -- Properties and attributes of an annotation. These can be entered as free-form tag-value pairs.
    ANNOTATION_CODED_ATTRIBUTES -- Coded properties and attributes of an analysis. These can be entered as tag-coded value pairs.

    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ObjectType
    def __init__(self, alias=None, center_name=None, broker_name=None, accession=None, IDENTIFIERS=None, annotation_center=None, annotation_date=None, TITLE=None, DESCRIPTION=None, STUDY_REF=None, IMAGE_REF=None, ANNOTATION_REF=None, ANNOTATION_TYPE=None, FILES=None, ANNOTATION_LINKS=None, ANNOTATION_ATTRIBUTES=None, ANNOTATION_CODED_ATTRIBUTES=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AnnotationType"), self).__init__(alias, center_name, broker_name, accession, IDENTIFIERS,  **kwargs_)
        self.annotation_center = _cast(None, annotation_center)
        self.annotation_center_nsprefix_ = None
        if isinstance(annotation_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(annotation_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = annotation_date
        self.annotation_date = initvalue_
        self.TITLE = TITLE
        self.TITLE_nsprefix_ = None
        self.DESCRIPTION = DESCRIPTION
        self.DESCRIPTION_nsprefix_ = None
        self.STUDY_REF = STUDY_REF
        self.STUDY_REF_nsprefix_ = None
        if IMAGE_REF is None:
            self.IMAGE_REF = []
        else:
            self.IMAGE_REF = IMAGE_REF
        self.IMAGE_REF_nsprefix_ = None
        if ANNOTATION_REF is None:
            self.ANNOTATION_REF = []
        else:
            self.ANNOTATION_REF = ANNOTATION_REF
        self.ANNOTATION_REF_nsprefix_ = None
        self.ANNOTATION_TYPE = ANNOTATION_TYPE
        self.ANNOTATION_TYPE_nsprefix_ = None
        self.FILES = FILES
        self.FILES_nsprefix_ = None
        self.ANNOTATION_LINKS = ANNOTATION_LINKS
        self.ANNOTATION_LINKS_nsprefix_ = None
        self.ANNOTATION_ATTRIBUTES = ANNOTATION_ATTRIBUTES
        self.ANNOTATION_ATTRIBUTES_nsprefix_ = None
        self.ANNOTATION_CODED_ATTRIBUTES = ANNOTATION_CODED_ATTRIBUTES
        self.ANNOTATION_CODED_ATTRIBUTES_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnnotationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnnotationType.subclass:
            return AnnotationType.subclass(*args_, **kwargs_)
        else:
            return AnnotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TITLE(self):
        return self.TITLE
    def set_TITLE(self, TITLE):
        self.TITLE = TITLE
    def get_DESCRIPTION(self):
        return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION
    def get_STUDY_REF(self):
        return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF
    def get_IMAGE_REF(self):
        return self.IMAGE_REF
    def set_IMAGE_REF(self, IMAGE_REF):
        self.IMAGE_REF = IMAGE_REF
    def add_IMAGE_REF(self, value):
        self.IMAGE_REF.append(value)
    def insert_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF.insert(index, value)
    def replace_IMAGE_REF_at(self, index, value):
        self.IMAGE_REF[index] = value
    def get_ANNOTATION_REF(self):
        return self.ANNOTATION_REF
    def set_ANNOTATION_REF(self, ANNOTATION_REF):
        self.ANNOTATION_REF = ANNOTATION_REF
    def add_ANNOTATION_REF(self, value):
        self.ANNOTATION_REF.append(value)
    def insert_ANNOTATION_REF_at(self, index, value):
        self.ANNOTATION_REF.insert(index, value)
    def replace_ANNOTATION_REF_at(self, index, value):
        self.ANNOTATION_REF[index] = value
    def get_ANNOTATION_TYPE(self):
        return self.ANNOTATION_TYPE
    def set_ANNOTATION_TYPE(self, ANNOTATION_TYPE):
        self.ANNOTATION_TYPE = ANNOTATION_TYPE
    def get_FILES(self):
        return self.FILES
    def set_FILES(self, FILES):
        self.FILES = FILES
    def get_ANNOTATION_LINKS(self):
        return self.ANNOTATION_LINKS
    def set_ANNOTATION_LINKS(self, ANNOTATION_LINKS):
        self.ANNOTATION_LINKS = ANNOTATION_LINKS
    def get_ANNOTATION_ATTRIBUTES(self):
        return self.ANNOTATION_ATTRIBUTES
    def set_ANNOTATION_ATTRIBUTES(self, ANNOTATION_ATTRIBUTES):
        self.ANNOTATION_ATTRIBUTES = ANNOTATION_ATTRIBUTES
    def get_ANNOTATION_CODED_ATTRIBUTES(self):
        return self.ANNOTATION_CODED_ATTRIBUTES
    def set_ANNOTATION_CODED_ATTRIBUTES(self, ANNOTATION_CODED_ATTRIBUTES):
        self.ANNOTATION_CODED_ATTRIBUTES = ANNOTATION_CODED_ATTRIBUTES
    def get_annotation_center(self):
        return self.annotation_center
    def set_annotation_center(self, annotation_center):
        self.annotation_center = annotation_center
    def get_annotation_date(self):
        return self.annotation_date
    def set_annotation_date(self, annotation_date):
        self.annotation_date = annotation_date
    def _hasContent(self):
        if (
            self.TITLE is not None or
            self.DESCRIPTION is not None or
            self.STUDY_REF is not None or
            self.IMAGE_REF or
            self.ANNOTATION_REF or
            self.ANNOTATION_TYPE is not None or
            self.FILES is not None or
            self.ANNOTATION_LINKS is not None or
            self.ANNOTATION_ATTRIBUTES is not None or
            self.ANNOTATION_CODED_ATTRIBUTES is not None or
            super(AnnotationType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnnotationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnnotationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnnotationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnnotationType'):
        super(AnnotationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnnotationType')
        if self.annotation_center is not None and 'annotation_center' not in already_processed:
            already_processed.add('annotation_center')
            outfile.write(' annotation_center=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.annotation_center), input_name='annotation_center')), ))
        if self.annotation_date is not None and 'annotation_date' not in already_processed:
            already_processed.add('annotation_date')
            outfile.write(' annotation_date="%s"' % self.gds_format_datetime(self.annotation_date, input_name='annotation_date'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AnnotationType', fromsubclass_=False, pretty_print=True):
        super(AnnotationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            namespaceprefix_ = self.TITLE_nsprefix_ + ':' if (UseCapturedNS_ and self.TITLE_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TITLE), input_name='TITLE')), namespaceprefix_ , eol_))
        if self.DESCRIPTION is not None:
            namespaceprefix_ = self.DESCRIPTION_nsprefix_ + ':' if (UseCapturedNS_ and self.DESCRIPTION_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DESCRIPTION), input_name='DESCRIPTION')), namespaceprefix_ , eol_))
        if self.STUDY_REF is not None:
            namespaceprefix_ = self.STUDY_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.STUDY_REF_nsprefix_) else ''
            self.STUDY_REF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='STUDY_REF', pretty_print=pretty_print)
        for IMAGE_REF_ in self.IMAGE_REF:
            namespaceprefix_ = self.IMAGE_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.IMAGE_REF_nsprefix_) else ''
            IMAGE_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IMAGE_REF', pretty_print=pretty_print)
        for ANNOTATION_REF_ in self.ANNOTATION_REF:
            namespaceprefix_ = self.ANNOTATION_REF_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_REF_nsprefix_) else ''
            ANNOTATION_REF_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_REF', pretty_print=pretty_print)
        if self.ANNOTATION_TYPE is not None:
            namespaceprefix_ = self.ANNOTATION_TYPE_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_TYPE_nsprefix_) else ''
            self.ANNOTATION_TYPE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_TYPE', pretty_print=pretty_print)
        if self.FILES is not None:
            namespaceprefix_ = self.FILES_nsprefix_ + ':' if (UseCapturedNS_ and self.FILES_nsprefix_) else ''
            self.FILES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FILES', pretty_print=pretty_print)
        if self.ANNOTATION_LINKS is not None:
            namespaceprefix_ = self.ANNOTATION_LINKS_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_LINKS_nsprefix_) else ''
            self.ANNOTATION_LINKS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_LINKS', pretty_print=pretty_print)
        if self.ANNOTATION_ATTRIBUTES is not None:
            namespaceprefix_ = self.ANNOTATION_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_ATTRIBUTES_nsprefix_) else ''
            self.ANNOTATION_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_ATTRIBUTES', pretty_print=pretty_print)
        if self.ANNOTATION_CODED_ATTRIBUTES is not None:
            namespaceprefix_ = self.ANNOTATION_CODED_ATTRIBUTES_nsprefix_ + ':' if (UseCapturedNS_ and self.ANNOTATION_CODED_ATTRIBUTES_nsprefix_) else ''
            self.ANNOTATION_CODED_ATTRIBUTES.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ANNOTATION_CODED_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('annotation_center', node)
        if value is not None and 'annotation_center' not in already_processed:
            already_processed.add('annotation_center')
            self.annotation_center = value
        value = find_attr_value_('annotation_date', node)
        if value is not None and 'annotation_date' not in already_processed:
            already_processed.add('annotation_date')
            try:
                self.annotation_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (annotation_date): %s' % exp)
        super(AnnotationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TITLE':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'TITLE')
            value_ = self.gds_validate_string(value_, node, 'TITLE')
            self.TITLE = value_
            self.TITLE_nsprefix_ = child_.prefix
        elif nodeName_ == 'DESCRIPTION':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DESCRIPTION')
            value_ = self.gds_validate_string(value_, node, 'DESCRIPTION')
            self.DESCRIPTION = value_
            self.DESCRIPTION_nsprefix_ = child_.prefix
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'IMAGE_REF':
            obj_ = IMAGE_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IMAGE_REF.append(obj_)
            obj_.original_tagname_ = 'IMAGE_REF'
        elif nodeName_ == 'ANNOTATION_REF':
            obj_ = ANNOTATION_REFType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_REF.append(obj_)
            obj_.original_tagname_ = 'ANNOTATION_REF'
        elif nodeName_ == 'ANNOTATION_TYPE':
            obj_ = ANNOTATION_TYPEType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_TYPE = obj_
            obj_.original_tagname_ = 'ANNOTATION_TYPE'
        elif nodeName_ == 'FILES':
            obj_ = FILESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
        elif nodeName_ == 'ANNOTATION_LINKS':
            obj_ = ANNOTATION_LINKSType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_LINKS = obj_
            obj_.original_tagname_ = 'ANNOTATION_LINKS'
        elif nodeName_ == 'ANNOTATION_ATTRIBUTES':
            obj_ = ANNOTATION_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'ANNOTATION_ATTRIBUTES'
        elif nodeName_ == 'ANNOTATION_CODED_ATTRIBUTES':
            obj_ = ANNOTATION_CODED_ATTRIBUTESType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ANNOTATION_CODED_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'ANNOTATION_CODED_ATTRIBUTES'
        super(AnnotationType, self)._buildChildren(child_, node, nodeName_, True)
# end class AnnotationType


GDSClassesMapping = {
    'ANALYSIS': AnalysisType,
    'ANALYSIS_SET': AnalysisSetType,
    'ANNOTATION': AnnotationType,
    'ANNOTATION_SET': AnnotationSetType,
    'ASSEMBLY': AssemblyType,
    'ASSEMBLY_SET': AssemblySetType,
    'BPDATASET': BPDatasetType,
    'BPDATASETS': BPDatasetsType,
    'BP_SAMPLE': BPSampleType,
    'BP_SAMPLE_SET': BPSampleSetType,
    'CHECKLIST': ChecklistType,
    'CHECKLIST_SET': ChecklistSetType,
    'DAC': DacType,
    'DAC_SET': DacSetType,
    'DATASET': DatasetType,
    'DATASETS': DatasetsType,
    'EXPERIMENT': ExperimentType,
    'EXPERIMENT_SET': ExperimentSetType,
    'IMAGE': ImageType,
    'IMAGE_SET': ImageSetType,
    'POLICY': PolicyType,
    'POLICY_SET': PolicySetType,
    'PROJECT': ProjectType,
    'PROJECT_SET': ProjectSetType,
    'RUN': RunType,
    'RUN_SET': RunSetType,
    'SAMPLE': SampleType,
    'SAMPLE_SET': SampleSetType,
    'STUDY': StudyType,
    'STUDY_SET': StudySetType,
    'SUBMISSION': SubmissionType,
    'SUBMISSION_SET': SubmissionSetType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnnotationFileType'
        rootClass = AnnotationFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnnotationFileType'
        rootClass = AnnotationFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnnotationFileType'
        rootClass = AnnotationFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnnotationFileType'
        rootClass = AnnotationFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from schema import *\n\n')
        sys.stdout.write('import schema as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {}

__all__ = [
    "ABI_SOLIDType",
    "ACTIONSType33",
    "ACTIONType",
    "ADDType",
    "AMR_ANTIBIOGRAM",
    "ANALYSIS_ATTRIBUTESType",
    "ANALYSIS_LINKSType",
    "ANALYSIS_REFType",
    "ANALYSIS_REFType18",
    "ANALYSIS_TYPEType",
    "ANNOTATION_ATTRIBUTESType",
    "ANNOTATION_CODED_ATTRIBUTESType",
    "ANNOTATION_LINKSType",
    "ANNOTATION_REFType",
    "ANNOTATION_REFType2",
    "ANNOTATION_TYPEType",
    "ASSEMBLY_ATTRIBUTESType",
    "ASSEMBLY_LINKSType",
    "AnalysisFileType",
    "AnalysisSetType",
    "AnalysisType",
    "AnnotationFileType",
    "AnnotationSetType",
    "AnnotationType",
    "AssemblySetType",
    "AssemblyType",
    "AttributeType",
    "BASECALLType",
    "BGISEQType",
    "BIOLOGICAL_BEING",
    "BLOCK",
    "BPDatasetType",
    "BPDatasetsType",
    "BPSampleSetType",
    "BPSampleType",
    "CANCELType",
    "CAPILLARYType",
    "CHILD_PROJECTType",
    "CHROMOSOMESType",
    "CHROMOSOMEType",
    "COLLABORATORSType",
    "COMPLETE_GENOMICSType",
    "CONDITIONType",
    "CONTACTSType",
    "CONTACTSType31",
    "CONTACTType",
    "CONTACTType32",
    "COVID19_CONSENSUS",
    "COVID19_FILTERED_VCF",
    "CUSTOMType",
    "CUSTOM_FIELDSType",
    "ChecklistSetType",
    "ChecklistType",
    "CodedAttributeType",
    "DAC_ATTRIBUTESType",
    "DAC_LINKSType",
    "DAC_REFType",
    "DATASET_ATTRIBUTESType",
    "DATASET_CODED_ATTRIBUTESType",
    "DATASET_LINKSType",
    "DATA_BLOCKType",
    "DATA_USESType",
    "DATE_FIELD",
    "DESCRIPTION",
    "DESCRIPTORType",
    "DESCRIPTORType30",
    "DNBSEQType",
    "DacSetType",
    "DacType",
    "DataUseType",
    "DatasetType",
    "DatasetsType",
    "ENTREZ_LINKType",
    "EXPECTED_BASECALL_TABLEType",
    "EXPERIMENT_ATTRIBUTESType",
    "EXPERIMENT_LINKSType",
    "EXPERIMENT_REFType",
    "EXPERIMENT_REFType25",
    "EXT_IDType",
    "ExperimentSetType",
    "ExperimentType",
    "FIELDType",
    "FIELDType21",
    "FIELD_GROUPType",
    "FIELD_TYPEType",
    "FILESType",
    "FILESType22",
    "FILESType26",
    "FILESType7",
    "FILEType",
    "GENOME_MAPType",
    "GRAPHICAL_ANNOTATION",
    "GROSS_IMAGE",
    "HELICOSType",
    "HOLDType",
    "ID",
    "ILLUMINAType",
    "IMAGE_ATTRIBUTESType",
    "IMAGE_CODED_ATTRIBUTESType",
    "IMAGE_LINKSType",
    "IMAGE_REFType",
    "IMAGE_REFType1",
    "IMAGE_REFType6",
    "IMAGE_TYPEType",
    "ION_TORRENTType",
    "IdentifierType",
    "ImageFileType",
    "ImageSetType",
    "ImageType",
    "KILLType",
    "LIBRARY_LAYOUTType",
    "LOCUSType",
    "LS454Type",
    "LibraryDescriptorType",
    "LibraryType",
    "LinkType",
    "MESSAGESType",
    "MODIFYType",
    "NAME",
    "NameType",
    "ONTOLOGY_FIELDType",
    "OXFORD_NANOPOREType",
    "ObjectType",
    "OrganismType",
    "PACBIO_SMRTType",
    "PAIREDType",
    "PARENT_PROJECTType",
    "PATHOGEN_ANALYSIS",
    "PEER_PROJECTType",
    "PIPE_SECTIONType",
    "POLICY_ATTRIBUTESType",
    "POLICY_LINKSType",
    "POLICY_REFType",
    "POOLType",
    "PROJECT_ATTRIBUTESType",
    "PROJECT_LINKSType",
    "PROJECT_LINKType",
    "PROTECTType",
    "PipelineType",
    "PlatformType",
    "PolicySetType",
    "PolicyType",
    "PoolMemberType",
    "ProcessingType",
    "ProjectSetType",
    "ProjectType",
    "QualifiedNameType",
    "READ_LABELType",
    "READ_SPECType",
    "RECEIPT",
    "RECEIPTType",
    "REFERENCE_SEQUENCEType",
    "RELATED_PROJECTSType",
    "RELATED_PROJECTType",
    "RELATED_STUDIESType",
    "RELATED_STUDYType",
    "RELATIVE_ORDERType",
    "RELEASEType",
    "ROLLBACKType",
    "RUN_ATTRIBUTESType",
    "RUN_LINKSType",
    "RUN_REFType",
    "RUN_REFType17",
    "RUN_TYPEType",
    "RefObjectType",
    "ReferenceAssemblyType",
    "ReferenceSequenceType",
    "RunSetType",
    "RunType",
    "SAMPLE",
    "SAMPLE_ATTRIBUTESType",
    "SAMPLE_CODED_ATTRIBUTESType",
    "SAMPLE_LINKSType",
    "SAMPLE_NAMEType",
    "SAMPLE_PHENOTYPEType",
    "SAMPLE_REFType",
    "SAMPLE_REFType10",
    "SAMPLE_REFType16",
    "SAMPLE_REFType8",
    "SAMPLE_TYPEType",
    "SEQUENCEType",
    "SEQUENCE_ASSEMBLYType",
    "SEQUENCE_FLATFILEType",
    "SEQUENCE_VARIATIONType",
    "SEQUENCING_PROJECTType",
    "SINGLEType",
    "SLIDE",
    "SPECIMEN",
    "SPOT_DECODE_SPECType",
    "STANDARDType",
    "STUDY_ATTRIBUTESType",
    "STUDY_LINKSType",
    "STUDY_REFType",
    "STUDY_REFType11",
    "STUDY_REFType15",
    "STUDY_REFType24",
    "STUDY_REFType5",
    "STUDY_TYPEType",
    "SUBMISSION_ATTRIBUTESType",
    "SUBMISSION_LINKSType",
    "SUBMISSION_PROJECTType",
    "SUPPRESSType",
    "SampleDescriptorType",
    "SampleSetType",
    "SampleType",
    "SequencingDirectivesType",
    "SpotDescriptorType",
    "StudySetType",
    "StudyType",
    "SubmissionSetType",
    "SubmissionType",
    "TARGETED_LOCIType",
    "TAXONOMIC_REFERENCE_SETType",
    "TAXONType",
    "TAXON_FIELDType",
    "TEXT_AREA_FIELDType",
    "TEXT_CHOICE_FIELDType",
    "TEXT_FIELDType",
    "TEXT_VALUEType",
    "TRANSCRIPTOME_ASSEMBLYType",
    "UMBRELLA_PROJECTType",
    "UNITSType",
    "URLType",
    "URL_LINKType",
    "URL_LINKType23",
    "VALIDATEType",
    "WGS_SETType",
    "WSI_IMAGE",
    "XRefType"
]
